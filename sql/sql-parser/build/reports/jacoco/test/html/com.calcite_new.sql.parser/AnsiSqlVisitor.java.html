<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AnsiSqlVisitor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sql-parser</a> &gt; <a href="index.source.html" class="el_package">com.calcite_new.sql.parser</a> &gt; <span class="el_source">AnsiSqlVisitor.java</span></div><h1>AnsiSqlVisitor.java</h1><pre class="source lang-java linenums">package com.calcite_new.sql.parser;

import com.calcite_new.sql.parser.antlr.AnsiSqlBaseVisitor;
import com.calcite_new.sql.parser.antlr.AnsiSqlParser;
import org.antlr.v4.runtime.ParserRuleContext;
import org.antlr.v4.runtime.tree.ErrorNode;
import org.apache.calcite.sql.*;
import org.apache.calcite.sql.fun.SqlStdOperatorTable;
import org.apache.calcite.sql.parser.SqlParserPos;
import org.apache.calcite.util.ImmutableNullableList;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

<span class="fc" id="L16">public class AnsiSqlVisitor extends AnsiSqlBaseVisitor&lt;SqlNode&gt; {</span>

  @Override
  public SqlNode visitSelectStatement(AnsiSqlParser.SelectStatementContext ctx) {
<span class="fc" id="L20">    SqlNode select = visit(ctx.selectList());</span>
<span class="pc bpc" id="L21" title="1 of 2 branches missed.">    if (select.getKind() == SqlKind.IDENTIFIER) {</span>
<span class="nc" id="L22">      select = SqlNodeList.of(select);</span>
    }
<span class="fc" id="L24">    SqlNodeList selectList = (SqlNodeList) select;</span>
<span class="pc bpc" id="L25" title="1 of 2 branches missed.">    SqlNode from = ctx.fromClause() != null ? visit(ctx.fromClause()) : null;</span>
<span class="fc bfc" id="L26" title="All 2 branches covered.">    SqlNode where = ctx.whereClause() != null ? visit(ctx.whereClause()) : null;</span>
<span class="fc bfc" id="L27" title="All 2 branches covered.">    SqlNodeList groupBy = ctx.groupByClause() != null ?</span>
<span class="fc" id="L28">        (SqlNodeList) visit(ctx.groupByClause()) : null;</span>
<span class="fc bfc" id="L29" title="All 2 branches covered.">    SqlNode having = ctx.havingClause() != null ? visit(ctx.havingClause()) : null;</span>
<span class="fc bfc" id="L30" title="All 2 branches covered.">    SqlNodeList orderBy = ctx.orderByClause() != null ?</span>
<span class="fc" id="L31">        (SqlNodeList) visit(ctx.orderByClause()) : null;</span>
<span class="fc bfc" id="L32" title="All 2 branches covered.">    SqlNode limitClause = ctx.limitClause() != null ? visit(ctx.limitClause()) : null;</span>

<span class="pc bpc" id="L34" title="1 of 2 branches missed.">    boolean isDistinct = ctx.distinct() != null &amp;&amp;</span>
<span class="pc bnc" id="L35" title="All 2 branches missed.">        ctx.distinct().DISTINCT() != null;</span>

<span class="fc" id="L37">    return new SqlSelect(</span>
<span class="fc" id="L38">        getPos(ctx),</span>
<span class="pc bpc" id="L39" title="1 of 2 branches missed.">        isDistinct ? SqlNodeList.of(SqlLiteral.createBoolean(true, SqlParserPos.ZERO))</span>
<span class="fc" id="L40">            : SqlNodeList.EMPTY,</span>
        selectList,
        from,
        where,
        groupBy,
        having,
        null, // window
        null, // qualify
        orderBy,
        null, // offset
        limitClause,  // fetch
        null // hints
    );
  }

  @Override
  public SqlNode visitSelectList(AnsiSqlParser.SelectListContext ctx) {
<span class="fc" id="L57">    List&lt;SqlNode&gt; selectElements = ctx.children.stream().map(this::visit).filter(Objects::nonNull).toList();</span>
<span class="fc" id="L58">    return new SqlNodeList(selectElements, getPos(ctx));</span>
  }

  @Override
  public SqlNode visitOrderByClause(AnsiSqlParser.OrderByClauseContext ctx) {
<span class="fc" id="L63">    List&lt;SqlNode&gt; orderByElements = ctx.children.stream().map(this::visit).filter(Objects::nonNull).toList();</span>
<span class="fc" id="L64">    return new SqlNodeList(orderByElements, getPos(ctx));</span>
  }

  @Override
  public SqlNode visitOrderByElement(AnsiSqlParser.OrderByElementContext ctx) {
<span class="fc" id="L69">    SqlNode exprNode = ctx.expr().accept(this);</span>
<span class="pc bpc" id="L70" title="1 of 2 branches missed.">    assert ctx.getChildCount() &lt;= 2 : &quot;ORDER BY with more than 2 args not supported.&quot;;</span>
<span class="fc bfc" id="L71" title="All 2 branches covered.">    if (ctx.getChildCount() == 2) {</span>
<span class="pc bpc" id="L72" title="1 of 2 branches missed.">      if (ctx.children.get(1).getText().equals(SqlStdOperatorTable.DESC.toString())) {</span>
<span class="fc" id="L73">        return SqlStdOperatorTable.DESC.createCall(getPos(ctx), exprNode);</span>
      }
    }
<span class="fc" id="L76">    return exprNode;</span>
  }

  protected SqlParserPos getPos(ParserRuleContext ctx) {
<span class="fc" id="L80">    return new SqlParserPos(</span>
<span class="fc" id="L81">        ctx.start.getLine(),</span>
<span class="fc" id="L82">        ctx.start.getStartIndex(),</span>
<span class="fc" id="L83">        ctx.stop.getLine(),</span>
<span class="fc" id="L84">        ctx.stop.getStopIndex());</span>
  }

  //  @Override
//  protected SqlNode defaultResult() {
//    return SqlNodeList.EMPTY;
//  }


  @Override
  public SqlNode visitGroupByClause(AnsiSqlParser.GroupByClauseContext ctx) {
<span class="fc" id="L95">    List&lt;SqlNode&gt; groupByElements = ctx.children.stream().map(this::visit).filter(Objects::nonNull).toList();</span>
<span class="fc" id="L96">    return new SqlNodeList(groupByElements, SqlParserPos.ZERO);</span>
  }

  @Override
  public SqlNode visitSelectElement(AnsiSqlParser.SelectElementContext ctx) {
<span class="fc bfc" id="L101" title="All 2 branches covered.">    if (ctx.expr() == null) {</span>
<span class="fc" id="L102">      return SqlIdentifier.star(SqlParserPos.ZERO);</span>
    }
<span class="fc" id="L104">    return super.visitSelectElement(ctx);</span>
  }

  @Override
  public SqlNode visitErrorNode(ErrorNode node) {
<span class="nc" id="L109">    throw new RuntimeException(&quot;Parser error: &quot; + node.getText());</span>
  }

  @Override
  public SqlNode visitTableSource(AnsiSqlParser.TableSourceContext ctx) {
<span class="pc bpc" id="L114" title="1 of 2 branches missed.">    if (ctx.primaryTableSource() != null) {</span>
<span class="fc" id="L115">      SqlNode primary = visit(ctx.primaryTableSource());</span>
<span class="fc bfc" id="L116" title="All 2 branches covered.">      if (ctx.joinPart().isEmpty()) {</span>
<span class="fc" id="L117">        return primary;</span>
      }

<span class="fc" id="L120">      SqlNode result = primary;</span>
<span class="fc bfc" id="L121" title="All 2 branches covered.">      for (AnsiSqlParser.JoinPartContext join : ctx.joinPart()) {</span>
<span class="fc" id="L122">        SqlNode right = visit(join.primaryTableSource());</span>
<span class="pc bpc" id="L123" title="1 of 2 branches missed.">        SqlNode condition = join.ON() != null ? visit(join.expr()) : null;</span>

<span class="fc" id="L125">        SqlLiteral joinType = SqlLiteral.createSymbol(</span>
<span class="fc" id="L126">            getJoinType(join.joinType()),</span>
            SqlParserPos.ZERO
        );

<span class="fc" id="L130">        result = new SqlJoin(</span>
            SqlParserPos.ZERO,
            result,
<span class="fc" id="L133">            SqlLiteral.createBoolean(false, SqlParserPos.ZERO), // isNatural</span>
            joinType,
            right,
<span class="fc" id="L136">            SqlLiteral.createSymbol(</span>
                JoinConditionType.ON,
                SqlParserPos.ZERO
            ),
            condition
        );
<span class="fc" id="L142">      }</span>
<span class="fc" id="L143">      return result;</span>
    }
<span class="nc" id="L145">    return null;</span>
  }

  @Override
  public SqlNode visitPrimaryTableSource(AnsiSqlParser.PrimaryTableSourceContext ctx) {
<span class="pc bpc" id="L150" title="1 of 2 branches missed.">    if (ctx.tableName() != null) {</span>
<span class="fc" id="L151">      String tableName = ctx.tableName().ID().getText();</span>
<span class="fc" id="L152">      SqlIdentifier tableId = new SqlIdentifier(</span>
<span class="fc" id="L153">          List.of(tableName),</span>
          SqlParserPos.ZERO
      );

<span class="fc bfc" id="L157" title="All 2 branches covered.">      if (ctx.alias() != null) {</span>
<span class="fc" id="L158">        return new SqlBasicCall(</span>
            SqlStdOperatorTable.AS,
<span class="fc" id="L160">            ImmutableNullableList.copyOf(new SqlNode[]{</span>
                tableId,
                new SqlIdentifier(
<span class="fc" id="L163">                    ctx.alias().ID().getText(),</span>
                    SqlParserPos.ZERO
                )
            }),
            SqlParserPos.ZERO,
            null // function qualifier
        );
      }
<span class="fc" id="L171">      return tableId;</span>
    }
<span class="nc" id="L173">    return null;</span>
  }

  @Override
  public SqlNode visitWhereClause(AnsiSqlParser.WhereClauseContext ctx) {
<span class="fc" id="L178">    return visit(ctx.expr());</span>
  }

  @Override
  public SqlNode visitBinaryExpr(AnsiSqlParser.BinaryExprContext ctx) {
<span class="fc" id="L183">    SqlOperator operator = getOperator(ctx.op.getText());</span>
<span class="fc" id="L184">    SqlNode left = visit(ctx.expr(0));</span>
<span class="fc" id="L185">    SqlNode right = visit(ctx.expr(1));</span>

<span class="fc" id="L187">    return new SqlBasicCall(</span>
        operator,
<span class="fc" id="L189">        ImmutableNullableList.copyOf(new SqlNode[]{left, right}),</span>
        SqlParserPos.ZERO
    );
  }

//  @Override
//  public SqlNode visitFunctionExpr(AnsiSqlParser.FunctionExprContext ctx) {
//    ctx.functionCall().functionName()
//    return super.visitFunctionExpr(ctx);
//  }


  @Override
  public SqlNode visitStar(AnsiSqlParser.StarContext ctx) {
<span class="fc" id="L203">    return SqlIdentifier.star(SqlParserPos.ZERO);</span>
  }

  @Override
  public SqlNode visitFunctionCall(AnsiSqlParser.FunctionCallContext ctx) {
    // Get function name
<span class="fc" id="L209">    String functionName = ctx.functionName().ID().getText().toUpperCase();</span>

    // Get function arguments
    List&lt;SqlNode&gt; args;
<span class="fc bfc" id="L213" title="All 2 branches covered.">    if (ctx.star() != null) {</span>
<span class="fc" id="L214">      args = List.of(ctx.star().accept(this));</span>
    } else {
<span class="fc" id="L216">      args = ctx.expr().stream()</span>
<span class="fc" id="L217">          .map(this::visit)</span>
<span class="fc" id="L218">          .toList();</span>
    }
    // Handle special functions
<span class="pc bpc" id="L221" title="4 of 10 branches missed.">    return switch (functionName) {</span>
<span class="fc" id="L222">      case &quot;COUNT&quot; -&gt; new SqlBasicCall(</span>
          SqlStdOperatorTable.COUNT,
          args,
          SqlParserPos.ZERO
      );
<span class="fc" id="L227">      case &quot;SUM&quot; -&gt; new SqlBasicCall(</span>
          SqlStdOperatorTable.SUM,
          args,
          SqlParserPos.ZERO
      );
<span class="fc" id="L232">      case &quot;AVG&quot; -&gt; new SqlBasicCall(</span>
          SqlStdOperatorTable.AVG,
          args,
          SqlParserPos.ZERO
      );
<span class="fc" id="L237">      case &quot;MIN&quot; -&gt; new SqlBasicCall(</span>
          SqlStdOperatorTable.MIN,
          args,
          SqlParserPos.ZERO
      );
<span class="fc" id="L242">      case &quot;MAX&quot; -&gt; new SqlBasicCall(</span>
          SqlStdOperatorTable.MAX,
          args,
          SqlParserPos.ZERO
      );
<span class="nc" id="L247">      case &quot;UPPER&quot; -&gt; new SqlBasicCall(</span>
          SqlStdOperatorTable.UPPER,
          args,
          SqlParserPos.ZERO
      );
<span class="nc" id="L252">      case &quot;LOWER&quot; -&gt; new SqlBasicCall(</span>
          SqlStdOperatorTable.LOWER,
          args,
          SqlParserPos.ZERO
      );
<span class="nc" id="L257">      case &quot;SUBSTRING&quot;, &quot;SUBSTR&quot; -&gt; new SqlBasicCall(</span>
          SqlStdOperatorTable.SUBSTRING,
          args,
          SqlParserPos.ZERO
      );
<span class="nc" id="L262">      case &quot;CONCAT&quot; -&gt; new SqlBasicCall(</span>
          SqlStdOperatorTable.CONCAT,
          args,
          SqlParserPos.ZERO
      );
      default -&gt;
        // For unknown functions, create a custom function operator
<span class="fc" id="L269">          new SqlBasicCall(</span>
              new SqlUnresolvedFunction(
                  new SqlIdentifier(functionName, SqlParserPos.ZERO),
                  null,
                  null,
                  null,
                  null,
                  SqlFunctionCategory.USER_DEFINED_FUNCTION
              ),
              args,
              SqlParserPos.ZERO
          );
    };
  }

  @Override
  public SqlNode visitColumnRef(AnsiSqlParser.ColumnRefContext ctx) {
<span class="fc" id="L286">    List&lt;String&gt; names = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L287" title="All 2 branches covered.">    if (ctx.tableName() != null) {</span>
<span class="fc" id="L288">      names.add(ctx.tableName().ID().getText());</span>
    }
<span class="fc" id="L290">    names.add(ctx.columnName().ID().getText());</span>
<span class="fc" id="L291">    return new SqlIdentifier(names, SqlParserPos.ZERO);</span>
  }

  @Override
  public SqlNode visitLiteral(AnsiSqlParser.LiteralContext ctx) {
<span class="fc bfc" id="L296" title="All 2 branches covered.">    if (ctx.STRING_LITERAL() != null) {</span>
<span class="fc" id="L297">      String text = ctx.STRING_LITERAL().getText();</span>
      // Remove quotes
<span class="fc" id="L299">      text = text.substring(1, text.length() - 1);</span>
<span class="fc" id="L300">      return SqlLiteral.createCharString(text, SqlParserPos.ZERO);</span>
<span class="pc bpc" id="L301" title="1 of 2 branches missed.">    } else if (ctx.NUMBER() != null) {</span>
<span class="fc" id="L302">      return SqlLiteral.createExactNumeric(</span>
<span class="fc" id="L303">          ctx.NUMBER().getText(),</span>
          SqlParserPos.ZERO
      );
<span class="nc bnc" id="L306" title="All 2 branches missed.">    } else if (ctx.NULL() != null) {</span>
<span class="nc" id="L307">      return SqlLiteral.createNull(SqlParserPos.ZERO);</span>
    }
<span class="nc" id="L309">    return null;</span>
  }

  private SqlOperator getOperator(String op) {
<span class="pc bpc" id="L313" title="9 of 11 branches missed.">    return switch (op) {</span>
<span class="fc" id="L314">      case &quot;=&quot; -&gt; SqlStdOperatorTable.EQUALS;</span>
<span class="nc" id="L315">      case &quot;&lt;&gt;&quot; -&gt; SqlStdOperatorTable.NOT_EQUALS;</span>
<span class="fc" id="L316">      case &quot;&gt;&quot; -&gt; SqlStdOperatorTable.GREATER_THAN;</span>
<span class="nc" id="L317">      case &quot;&lt;&quot; -&gt; SqlStdOperatorTable.LESS_THAN;</span>
<span class="nc" id="L318">      case &quot;&gt;=&quot; -&gt; SqlStdOperatorTable.GREATER_THAN_OR_EQUAL;</span>
<span class="nc" id="L319">      case &quot;&lt;=&quot; -&gt; SqlStdOperatorTable.LESS_THAN_OR_EQUAL;</span>
<span class="nc" id="L320">      case &quot;+&quot; -&gt; SqlStdOperatorTable.PLUS;</span>
<span class="nc" id="L321">      case &quot;-&quot; -&gt; SqlStdOperatorTable.MINUS;</span>
<span class="nc" id="L322">      case &quot;*&quot; -&gt; SqlStdOperatorTable.MULTIPLY;</span>
<span class="nc" id="L323">      case &quot;/&quot; -&gt; SqlStdOperatorTable.DIVIDE;</span>
<span class="nc" id="L324">      default -&gt; throw new UnsupportedOperationException(&quot;Operator not supported: &quot; + op);</span>
    };
  }

  private JoinType getJoinType(AnsiSqlParser.JoinTypeContext ctx) {
<span class="fc bfc" id="L329" title="All 2 branches covered.">    if (ctx.INNER() != null) return JoinType.INNER;</span>
<span class="pc bpc" id="L330" title="1 of 2 branches missed.">    if (ctx.LEFT() != null) return JoinType.LEFT;</span>
<span class="pc bpc" id="L331" title="1 of 2 branches missed.">    if (ctx.RIGHT() != null) return JoinType.RIGHT;</span>
<span class="pc bpc" id="L332" title="1 of 2 branches missed.">    if (ctx.FULL() != null) return JoinType.FULL;</span>
<span class="pc bpc" id="L333" title="1 of 2 branches missed.">    if (ctx.CROSS() != null) return JoinType.CROSS;</span>
<span class="fc" id="L334">    return JoinType.INNER; // default</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>