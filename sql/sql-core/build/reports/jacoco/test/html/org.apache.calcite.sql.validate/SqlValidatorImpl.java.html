<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SqlValidatorImpl.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sql-core</a> &gt; <a href="index.source.html" class="el_package">org.apache.calcite.sql.validate</a> &gt; <span class="el_source">SqlValidatorImpl.java</span></div><h1>SqlValidatorImpl.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to you under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.calcite.sql.validate;

import com.calcite_new.core.dialect.sql.SqlDialect;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Sets;
import org.apache.calcite.linq4j.Ord;
import org.apache.calcite.linq4j.function.Functions;
import org.apache.calcite.plan.RelOptTable;
import org.apache.calcite.plan.RelOptUtil;
import org.apache.calcite.prepare.Prepare;
import org.apache.calcite.rel.type.*;
import org.apache.calcite.rex.RexNode;
import org.apache.calcite.rex.RexPatternFieldRef;
import org.apache.calcite.rex.RexVisitor;
import org.apache.calcite.runtime.*;
import org.apache.calcite.schema.ColumnStrategy;
import org.apache.calcite.schema.Table;
import org.apache.calcite.schema.impl.ModifiableViewTable;
import org.apache.calcite.sql.*;
import org.apache.calcite.sql.fun.SqlCase;
import org.apache.calcite.sql.fun.SqlInternalOperators;
import org.apache.calcite.sql.fun.SqlStdOperatorTable;
import org.apache.calcite.sql.parser.SqlParserPos;
import org.apache.calcite.sql.type.*;
import org.apache.calcite.sql.util.IdPair;
import org.apache.calcite.sql.util.SqlBasicVisitor;
import org.apache.calcite.sql.util.SqlShuttle;
import org.apache.calcite.sql.util.SqlVisitor;
import org.apache.calcite.sql.validate.implicit.TypeCoercion;
import org.apache.calcite.util.*;
import org.apache.calcite.util.trace.CalciteTrace;
import org.apiguardian.api.API;
import org.checkerframework.checker.nullness.qual.KeyFor;
import org.checkerframework.checker.nullness.qual.NonNull;
import org.checkerframework.checker.nullness.qual.Nullable;
import org.checkerframework.checker.nullness.qual.PolyNull;
import org.checkerframework.dataflow.qual.Pure;
import org.slf4j.Logger;

import java.math.BigDecimal;
import java.util.*;
import java.util.function.BiFunction;
import java.util.function.Consumer;
import java.util.function.Supplier;
import java.util.function.UnaryOperator;
import java.util.stream.Collectors;
import java.util.stream.StreamSupport;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkState;
import static java.util.Collections.emptyList;
import static java.util.Objects.requireNonNull;
import static org.apache.calcite.linq4j.Nullness.castNonNull;
import static org.apache.calcite.linq4j.Ord.forEach;
import static org.apache.calcite.sql.SqlUtil.stripAs;
import static org.apache.calcite.sql.type.NonNullableAccessors.getCharset;
import static org.apache.calcite.sql.type.NonNullableAccessors.getCollation;
import static org.apache.calcite.sql.validate.SqlNonNullableAccessors.*;
import static org.apache.calcite.util.Static.RESOURCE;
import static org.apache.calcite.util.Util.first;

/**
 * Default implementation of {@link SqlValidator}.
 */
public class SqlValidatorImpl implements SqlValidatorWithHints {
  //~ Static fields/initializers ---------------------------------------------

<span class="nc" id="L86">  public static final Logger TRACER = CalciteTrace.PARSER_LOGGER;</span>

  /**
   * Alias generated for the source table when rewriting UPDATE to MERGE.
   */
  public static final String UPDATE_SRC_ALIAS = &quot;SYS$SRC&quot;;

  /**
   * Alias generated for the target table when rewriting UPDATE to MERGE if no
   * alias was specified by the user.
   */
  public static final String UPDATE_TGT_ALIAS = &quot;SYS$TGT&quot;;

  /**
   * Alias prefix generated for source columns when rewriting UPDATE to MERGE.
   */
  public static final String UPDATE_ANON_PREFIX = &quot;SYS$ANON&quot;;

  //~ Instance fields --------------------------------------------------------

  private final SqlOperatorTable opTab;
  final SqlValidatorCatalogReader catalogReader;

  /**
   * Maps {@link SqlParserPos} strings to the {@link SqlIdentifier} identifier
   * objects at these positions.
   */
<span class="nc" id="L113">  protected final Map&lt;String, IdInfo&gt; idPositions = new HashMap&lt;&gt;();</span>

  /**
   * Maps {@link SqlNode query node} objects to the {@link SqlValidatorScope}
   * scope created from them.
   */
<span class="nc" id="L119">  protected final IdentityHashMap&lt;SqlNode, SqlValidatorScope&gt; scopes =</span>
      new IdentityHashMap&lt;&gt;();

  /**
   * Maps a {@link SqlSelect} and a {@link Clause} to the scope used by that
   * clause.
   */
<span class="nc" id="L126">  private final Map&lt;IdPair&lt;SqlSelect, Clause&gt;, SqlValidatorScope&gt;</span>
      clauseScopes = new HashMap&lt;&gt;();

  /**
   * The name-resolution scope of a LATERAL TABLE clause.
   */
<span class="nc" id="L132">  private @Nullable TableScope tableScope = null;</span>

  /**
   * Maps a {@link SqlNode node} to the
   * {@link SqlValidatorNamespace namespace} which describes what columns they
   * contain.
   */
<span class="nc" id="L139">  protected final IdentityHashMap&lt;SqlNode, SqlValidatorNamespace&gt; namespaces =</span>
      new IdentityHashMap&lt;&gt;();

  /**
   * Set of select expressions used as cursor definitions. In standard SQL,
   * only the top-level SELECT is a cursor; Calcite extends this with
   * cursors as inputs to table functions.
   */
<span class="nc" id="L147">  private final Set&lt;SqlNode&gt; cursorSet = Sets.newIdentityHashSet();</span>

  /**
   * Stack of objects that maintain information about function calls. A stack
   * is needed to handle nested function calls. The function call currently
   * being validated is at the top of the stack.
   */
<span class="nc" id="L154">  protected final Deque&lt;FunctionParamInfo&gt; functionCallStack =</span>
      new ArrayDeque&lt;&gt;();

  private int nextGeneratedId;
  protected final RelDataTypeFactory typeFactory;
  protected final RelDataType unknownType;
  private final RelDataType booleanType;
  private final SqlDialect dialect;

  protected final TimeFrameSet timeFrameSet;

  /**
   * Map of derived RelDataType for each node. This is an IdentityHashMap
   * since in some cases (such as null literals) we need to discriminate by
   * instance.
   */
<span class="nc" id="L170">  private final IdentityHashMap&lt;SqlNode, RelDataType&gt; nodeToTypeMap =</span>
      new IdentityHashMap&lt;&gt;();

  /** Provides the data for {@link #getValidatedOperandTypes(SqlCall)}. */
<span class="nc" id="L174">  public final IdentityHashMap&lt;SqlCall, List&lt;RelDataType&gt;&gt; callToOperandTypesMap =</span>
      new IdentityHashMap&lt;&gt;();

  private final AggFinder aggFinder;
  private final AggFinder aggOrOverFinder;
  private final AggFinder aggOrOverOrGroupFinder;
  private final AggFinder groupFinder;
  private final AggFinder overFinder;

  private Config config;

<span class="nc" id="L185">  private final Map&lt;SqlNode, SqlNode&gt; originalExprs = new HashMap&lt;&gt;();</span>

  private @Nullable SqlNode top;

  // TODO jvs 11-Dec-2008:  make this local to performUnconditionalRewrites
  // if it's OK to expand the signature of that method.
  private boolean validatingSqlMerge;

  private boolean inWindow;                        // Allow nested aggregates

<span class="nc" id="L195">  private final SqlValidatorImpl.ValidationErrorFunction validationErrorFunction =</span>
      new SqlValidatorImpl.ValidationErrorFunction();

  // TypeCoercion instance used for implicit type coercion.
  private final TypeCoercion typeCoercion;

  //~ Constructors -----------------------------------------------------------

  /**
   * Creates a validator.
   *
   * @param opTab         Operator table
   * @param catalogReader Catalog reader
   * @param typeFactory   Type factory
   * @param config        Config
   */
  public SqlValidatorImpl(
      SqlOperatorTable opTab,
      SqlValidatorCatalogReader catalogReader,
      RelDataTypeFactory typeFactory,
      Config config,
<span class="nc" id="L216">      SqlDialect dialect) {</span>
<span class="nc" id="L217">    this.opTab = requireNonNull(opTab, &quot;opTab&quot;);</span>
<span class="nc" id="L218">    this.catalogReader = requireNonNull(catalogReader, &quot;catalogReader&quot;);</span>
<span class="nc" id="L219">    this.typeFactory = requireNonNull(typeFactory, &quot;typeFactory&quot;);</span>
<span class="nc" id="L220">    final RelDataTypeSystem typeSystem = typeFactory.getTypeSystem();</span>
<span class="nc" id="L221">    this.timeFrameSet =</span>
<span class="nc" id="L222">        requireNonNull(typeSystem.deriveTimeFrameSet(TimeFrames.CORE),</span>
            &quot;timeFrameSet&quot;);
<span class="nc" id="L224">    this.config = requireNonNull(config, &quot;config&quot;);</span>
<span class="nc" id="L225">    this.dialect = dialect;</span>
    
    // It is assumed that unknown type is nullable by default
<span class="nc" id="L228">    unknownType = typeFactory.createTypeWithNullability(typeFactory.createUnknownType(), true);</span>
<span class="nc" id="L229">    booleanType = typeFactory.createSqlType(SqlTypeName.BOOLEAN);</span>

<span class="nc" id="L231">    final SqlNameMatcher nameMatcher = catalogReader.nameMatcher();</span>
<span class="nc" id="L232">    aggFinder = new AggFinder(opTab, false, true, false, null, nameMatcher);</span>
<span class="nc" id="L233">    aggOrOverFinder =</span>
        new AggFinder(opTab, true, true, false, null, nameMatcher);
<span class="nc" id="L235">    overFinder =</span>
        new AggFinder(opTab, true, false, false, aggOrOverFinder, nameMatcher);
<span class="nc" id="L237">    groupFinder = new AggFinder(opTab, false, false, true, null, nameMatcher);</span>
<span class="nc" id="L238">    aggOrOverOrGroupFinder =</span>
        new AggFinder(opTab, true, true, true, null, nameMatcher);
    @SuppressWarnings(&quot;argument.type.incompatible&quot;)
<span class="nc" id="L241">    TypeCoercion typeCoercion = config.typeCoercionFactory().create(typeFactory, this);</span>
<span class="nc" id="L242">    this.typeCoercion = typeCoercion;</span>

<span class="nc bnc" id="L244" title="All 2 branches missed.">    if (config.conformance().allowLenientCoercion()) {</span>
<span class="nc" id="L245">      final SqlTypeCoercionRule rules =</span>
<span class="nc" id="L246">          first(config.typeCoercionRules(),</span>
<span class="nc" id="L247">              SqlTypeCoercionRule.instance());</span>

      final ImmutableSet&lt;SqlTypeName&gt; arrayMapping =
<span class="nc" id="L250">          ImmutableSet.&lt;SqlTypeName&gt;builder()</span>
<span class="nc" id="L251">              .addAll(rules.getTypeMapping()</span>
<span class="nc" id="L252">                  .getOrDefault(SqlTypeName.ARRAY, ImmutableSet.of()))</span>
<span class="nc" id="L253">              .add(SqlTypeName.VARCHAR)</span>
<span class="nc" id="L254">              .add(SqlTypeName.CHAR)</span>
<span class="nc" id="L255">              .build();</span>

<span class="nc" id="L257">      Map&lt;SqlTypeName, ImmutableSet&lt;SqlTypeName&gt;&gt; mapping =</span>
<span class="nc" id="L258">          new HashMap&lt;&gt;(rules.getTypeMapping());</span>
<span class="nc" id="L259">      mapping.replace(SqlTypeName.ARRAY, arrayMapping);</span>
<span class="nc" id="L260">      SqlTypeCoercionRule rules2 = SqlTypeCoercionRule.instance(mapping);</span>

<span class="nc" id="L262">      SqlTypeCoercionRule.THREAD_PROVIDERS.set(rules2);</span>
<span class="nc bnc" id="L263" title="All 2 branches missed.">    } else if (config.typeCoercionRules() != null) {</span>
<span class="nc" id="L264">      SqlTypeCoercionRule.THREAD_PROVIDERS.set(config.typeCoercionRules());</span>
    }
<span class="nc" id="L266">  }</span>

  //~ Methods ----------------------------------------------------------------

  public SqlConformance getConformance() {
<span class="nc" id="L271">    return config.conformance();</span>
  }

  @Pure
  @Override public SqlValidatorCatalogReader getCatalogReader() {
<span class="nc" id="L276">    return catalogReader;</span>
  }

  @Pure
  @Override public SqlOperatorTable getOperatorTable() {
<span class="nc" id="L281">    return opTab;</span>
  }

  @Pure
  @Override public RelDataTypeFactory getTypeFactory() {
<span class="nc" id="L286">    return typeFactory;</span>
  }

  @Override public RelDataType getUnknownType() {
<span class="nc" id="L290">    return unknownType;</span>
  }

  @Override public TimeFrameSet getTimeFrameSet() {
<span class="nc" id="L294">    return timeFrameSet;</span>
  }

  @Override public SqlNodeList expandStar(SqlNodeList selectList,
      SqlSelect select, boolean includeSystemVars) {
<span class="nc" id="L299">    final List&lt;SqlNode&gt; list = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L300">    final PairList&lt;String, RelDataType&gt; types = PairList.of();</span>
<span class="nc bnc" id="L301" title="All 2 branches missed.">    for (final SqlNode selectItem : selectList) {</span>
<span class="nc" id="L302">      final RelDataType originalType = getValidatedNodeTypeIfKnown(selectItem);</span>
<span class="nc" id="L303">      expandSelectItem(selectItem, select, first(originalType, unknownType),</span>
<span class="nc" id="L304">          list, catalogReader.nameMatcher().createSet(), types,</span>
          includeSystemVars);
<span class="nc" id="L306">    }</span>
<span class="nc" id="L307">    getRawSelectScopeNonNull(select).setExpandedSelectList(list);</span>
<span class="nc" id="L308">    return new SqlNodeList(list, SqlParserPos.ZERO);</span>
  }

  @Override public void declareCursor(SqlSelect select,
      SqlValidatorScope parentScope) {
<span class="nc" id="L313">    cursorSet.add(select);</span>

    // add the cursor to a map that maps the cursor to its select based on
    // the position of the cursor relative to other cursors in that call
<span class="nc" id="L317">    FunctionParamInfo funcParamInfo =</span>
<span class="nc" id="L318">        requireNonNull(functionCallStack.peek(), &quot;functionCall&quot;);</span>
<span class="nc" id="L319">    Map&lt;Integer, SqlSelect&gt; cursorMap = funcParamInfo.cursorPosToSelectMap;</span>
<span class="nc" id="L320">    final int cursorCount = cursorMap.size();</span>
<span class="nc" id="L321">    cursorMap.put(cursorCount, select);</span>

    // create a namespace associated with the result of the select
    // that is the argument to the cursor constructor; register it
    // with a scope corresponding to the cursor
<span class="nc" id="L326">    SelectScope cursorScope =</span>
<span class="nc" id="L327">        new SelectScope(parentScope, getEmptyScope(), select);</span>
<span class="nc" id="L328">    clauseScopes.put(IdPair.of(select, Clause.CURSOR), cursorScope);</span>
<span class="nc" id="L329">    final SelectNamespace selectNs = createSelectNamespace(select, select);</span>
<span class="nc" id="L330">    final String alias = SqlValidatorUtil.alias(select, nextGeneratedId++);</span>
<span class="nc" id="L331">    registerNamespace(cursorScope, alias, selectNs, false);</span>
<span class="nc" id="L332">  }</span>

  @Override public void pushFunctionCall() {
<span class="nc" id="L335">    FunctionParamInfo funcInfo = new FunctionParamInfo();</span>
<span class="nc" id="L336">    functionCallStack.push(funcInfo);</span>
<span class="nc" id="L337">  }</span>

  @Override public void popFunctionCall() {
<span class="nc" id="L340">    functionCallStack.pop();</span>
<span class="nc" id="L341">  }</span>

  @Override public @Nullable String getParentCursor(String columnListParamName) {
<span class="nc" id="L344">    FunctionParamInfo funcParamInfo =</span>
<span class="nc" id="L345">        requireNonNull(functionCallStack.peek(), &quot;functionCall&quot;);</span>
<span class="nc" id="L346">    Map&lt;String, String&gt; parentCursorMap =</span>
        funcParamInfo.columnListParamToParentCursorMap;
<span class="nc" id="L348">    return parentCursorMap.get(columnListParamName);</span>
  }

  /**
   * If &lt;code&gt;selectItem&lt;/code&gt; is &quot;*&quot; or &quot;TABLE.*&quot;, expands it and returns
   * true; otherwise writes the unexpanded item.
   *
   * @param selectItem        Select-list item
   * @param select            Containing select clause
   * @param selectItems       List that expanded items are written to
   * @param aliases           Set of aliases
   * @param fields            List of field names and types, in alias order
   * @param includeSystemVars If true include system vars in lists
   * @return Whether the node was expanded
   */
  private boolean expandSelectItem(final SqlNode selectItem, SqlSelect select,
      RelDataType targetType, List&lt;SqlNode&gt; selectItems, Set&lt;String&gt; aliases,
      PairList&lt;String, RelDataType&gt; fields, boolean includeSystemVars) {
    final SqlValidatorScope selectScope;
    SqlNode expanded;
<span class="nc bnc" id="L368" title="All 2 branches missed.">    if (SqlValidatorUtil.isMeasure(selectItem)) {</span>
<span class="nc" id="L369">      selectScope = getMeasureScope(select);</span>
<span class="nc" id="L370">      expanded = selectItem;</span>
    } else {
<span class="nc" id="L372">      final SelectScope scope = (SelectScope) getWhereScope(select);</span>
<span class="nc bnc" id="L373" title="All 2 branches missed.">      if (expandStar(selectItems, aliases, fields, includeSystemVars, scope,</span>
          selectItem)) {
<span class="nc" id="L375">        return true;</span>
      }

      // Expand the select item: fully-qualify columns, and convert
      // parentheses-free functions such as LOCALTIME into explicit function
      // calls.
<span class="nc" id="L381">      selectScope = getSelectScope(select);</span>
<span class="nc" id="L382">      expanded = expandSelectExpr(selectItem, scope, select);</span>
    }
<span class="nc" id="L384">    final String alias =</span>
<span class="nc" id="L385">        SqlValidatorUtil.alias(selectItem, aliases.size());</span>

    // If expansion has altered the natural alias, supply an explicit 'AS'.
<span class="nc bnc" id="L388" title="All 2 branches missed.">    if (expanded != selectItem) {</span>
<span class="nc" id="L389">      String newAlias =</span>
<span class="nc" id="L390">          SqlValidatorUtil.alias(expanded, aliases.size());</span>
<span class="nc bnc" id="L391" title="All 2 branches missed.">      if (!Objects.equals(newAlias, alias)) {</span>
<span class="nc" id="L392">        expanded =</span>
<span class="nc" id="L393">            SqlStdOperatorTable.AS.createCall(</span>
<span class="nc" id="L394">                selectItem.getParserPosition(),</span>
                expanded,
                new SqlIdentifier(alias, SqlParserPos.ZERO));
<span class="nc" id="L397">        deriveTypeImpl(selectScope, expanded);</span>
      }
    }

<span class="nc" id="L401">    selectItems.add(expanded);</span>
<span class="nc" id="L402">    aliases.add(alias);</span>

<span class="nc" id="L404">    inferUnknownTypes(targetType, selectScope, expanded);</span>

<span class="nc" id="L406">    RelDataType type = deriveType(selectScope, expanded);</span>
    // Re-derive SELECT ITEM's data type that may be nullable in
    // AggregatingSelectScope when it appears in advanced grouping elements such
    // as CUBE, ROLLUP, GROUPING SETS. For example, in
    //   SELECT CASE WHEN c = 1 THEN '1' ELSE '23' END AS x
    //   FROM t
    //   GROUP BY CUBE(x)
    // the 'x' should be nullable even if x's literal values are not null.
<span class="nc bnc" id="L414" title="All 2 branches missed.">    if (selectScope instanceof AggregatingSelectScope) {</span>
<span class="nc" id="L415">      type = requireNonNull(selectScope.nullifyType(stripAs(expanded), type));</span>
    }
<span class="nc" id="L417">    setValidatedNodeType(expanded, type);</span>
<span class="nc" id="L418">    fields.add(alias, type);</span>
<span class="nc" id="L419">    return false;</span>
  }

  private static SqlNode expandExprFromJoin(SqlJoin join,
      SqlIdentifier identifier, SelectScope scope) {
<span class="nc bnc" id="L424" title="All 2 branches missed.">    if (join.getConditionType() != JoinConditionType.USING) {</span>
<span class="nc" id="L425">      return identifier;</span>
    }

<span class="nc" id="L428">    final Map&lt;String, String&gt; fieldAliases = getFieldAliases(scope);</span>

    for (String name
<span class="nc bnc" id="L431" title="All 2 branches missed.">        : SqlIdentifier.simpleNames((SqlNodeList) getCondition(join))) {</span>
<span class="nc bnc" id="L432" title="All 2 branches missed.">      if (identifier.getSimple().equals(name)) {</span>
<span class="nc" id="L433">        final List&lt;SqlNode&gt; qualifiedNode = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L434" title="All 2 branches missed.">        for (ScopeChild child : requireNonNull(scope, &quot;scope&quot;).children) {</span>
<span class="nc bnc" id="L435" title="All 2 branches missed.">          if (child.namespace.getRowType().getFieldNames().contains(name)) {</span>
<span class="nc" id="L436">            final SqlIdentifier exp =</span>
                new SqlIdentifier(
<span class="nc" id="L438">                    ImmutableList.of(child.name, name),</span>
<span class="nc" id="L439">                    identifier.getParserPosition());</span>
<span class="nc" id="L440">            qualifiedNode.add(exp);</span>
          }
<span class="nc" id="L442">        }</span>

<span class="nc bnc" id="L444" title="All 2 branches missed.">        assert qualifiedNode.size() == 2;</span>

        // If there is an alias for the column, no need to wrap the coalesce with an AS operator
<span class="nc" id="L447">        boolean haveAlias = fieldAliases.containsKey(name);</span>

<span class="nc" id="L449">        final SqlCall coalesceCall =</span>
<span class="nc" id="L450">            SqlStdOperatorTable.COALESCE.createCall(SqlParserPos.ZERO, qualifiedNode.get(0),</span>
<span class="nc" id="L451">            qualifiedNode.get(1));</span>

<span class="nc bnc" id="L453" title="All 2 branches missed.">        if (haveAlias) {</span>
<span class="nc" id="L454">          return coalesceCall;</span>
        } else {
<span class="nc" id="L456">          return SqlStdOperatorTable.AS.createCall(SqlParserPos.ZERO, coalesceCall,</span>
              new SqlIdentifier(name, SqlParserPos.ZERO));
        }
      }
<span class="nc" id="L460">    }</span>

    // Only need to try to expand the expr from the left input of join
    // since it is always left-deep join.
<span class="nc" id="L464">    final SqlNode node = join.getLeft();</span>
<span class="nc bnc" id="L465" title="All 2 branches missed.">    if (node instanceof SqlJoin) {</span>
<span class="nc" id="L466">      return expandExprFromJoin((SqlJoin) node, identifier, scope);</span>
    } else {
<span class="nc" id="L468">      return identifier;</span>
    }
  }

  private static Map&lt;String, String&gt; getFieldAliases(final SelectScope scope) {
<span class="nc" id="L473">    final ImmutableMap.Builder&lt;String, String&gt; fieldAliases = new ImmutableMap.Builder&lt;&gt;();</span>

<span class="nc bnc" id="L475" title="All 2 branches missed.">    for (SqlNode selectItem : scope.getNode().getSelectList()) {</span>
<span class="nc bnc" id="L476" title="All 2 branches missed.">      if (selectItem instanceof SqlCall) {</span>
<span class="nc" id="L477">        final SqlCall call = (SqlCall) selectItem;</span>
<span class="nc bnc" id="L478" title="All 2 branches missed.">        if (!(call.getOperator() instanceof SqlAsOperator)</span>
<span class="nc bnc" id="L479" title="All 2 branches missed.">            || !(call.operand(0) instanceof SqlIdentifier)) {</span>
<span class="nc" id="L480">          continue;</span>
        }

<span class="nc" id="L483">        final SqlIdentifier fieldIdentifier = call.operand(0);</span>
<span class="nc" id="L484">        fieldAliases.put(fieldIdentifier.getSimple(),</span>
<span class="nc" id="L485">            ((SqlIdentifier) call.operand(1)).getSimple());</span>
      }
<span class="nc" id="L487">    }</span>

<span class="nc" id="L489">    return fieldAliases.build();</span>
  }

  /** Returns the set of field names in the join condition specified by USING
   * or implicitly by NATURAL, de-duplicated and in order. */
  public @Nullable List&lt;String&gt; usingNames(SqlJoin join) {
<span class="nc bnc" id="L495" title="All 3 branches missed.">    switch (join.getConditionType()) {</span>
    case USING:
<span class="nc" id="L497">      SqlNodeList condition = (SqlNodeList) getCondition(join);</span>
<span class="nc" id="L498">      List&lt;String&gt; simpleNames = SqlIdentifier.simpleNames(condition);</span>
<span class="nc" id="L499">      return catalogReader.nameMatcher().distinctCopy(simpleNames);</span>

    case NONE:
<span class="nc bnc" id="L502" title="All 2 branches missed.">      if (join.isNatural()) {</span>
<span class="nc" id="L503">        return deriveNaturalJoinColumnList(join);</span>
      }
<span class="nc" id="L505">      return null;</span>

    default:
<span class="nc" id="L508">      return null;</span>
    }
  }

  private List&lt;String&gt; deriveNaturalJoinColumnList(SqlJoin join) {
<span class="nc" id="L513">    return SqlValidatorUtil.deriveNaturalJoinColumnList(</span>
<span class="nc" id="L514">        catalogReader.nameMatcher(),</span>
<span class="nc" id="L515">        getNamespaceOrThrow(join.getLeft()).getRowType(),</span>
<span class="nc" id="L516">        getNamespaceOrThrow(join.getRight()).getRowType());</span>
  }

  private static SqlNode expandCommonColumn(SqlSelect sqlSelect,
      SqlNode selectItem, SelectScope scope, SqlValidatorImpl validator) {
<span class="nc bnc" id="L521" title="All 2 branches missed.">    if (!(selectItem instanceof SqlIdentifier)) {</span>
<span class="nc" id="L522">      return selectItem;</span>
    }

<span class="nc" id="L525">    final SqlNode from = sqlSelect.getFrom();</span>
<span class="nc bnc" id="L526" title="All 2 branches missed.">    if (!(from instanceof SqlJoin)) {</span>
<span class="nc" id="L527">      return selectItem;</span>
    }

<span class="nc" id="L530">    final SqlIdentifier identifier = (SqlIdentifier) selectItem;</span>
<span class="nc bnc" id="L531" title="All 2 branches missed.">    if (!identifier.isSimple()) {</span>
<span class="nc bnc" id="L532" title="All 2 branches missed.">      if (!validator.config().conformance().allowQualifyingCommonColumn()) {</span>
<span class="nc" id="L533">        validateQualifiedCommonColumn((SqlJoin) from, identifier, scope, validator);</span>
      }
<span class="nc" id="L535">      return selectItem;</span>
    }

<span class="nc" id="L538">    return expandExprFromJoin((SqlJoin) from, identifier, scope);</span>
  }

  private static void validateQualifiedCommonColumn(SqlJoin join,
      SqlIdentifier identifier, SelectScope scope, SqlValidatorImpl validator) {
<span class="nc" id="L543">    List&lt;String&gt; names = validator.usingNames(join);</span>
<span class="nc bnc" id="L544" title="All 2 branches missed.">    if (names == null) {</span>
      // Not USING or NATURAL.
<span class="nc" id="L546">      return;</span>
    }

    // First we should make sure that the first component is the table name.
    // Then check whether the qualified identifier contains common column.
<span class="nc bnc" id="L551" title="All 2 branches missed.">    for (ScopeChild child : scope.children) {</span>
<span class="nc bnc" id="L552" title="All 2 branches missed.">      if (Objects.equals(child.name, identifier.getComponent(0).toString())) {</span>
<span class="nc bnc" id="L553" title="All 2 branches missed.">        if (names.contains(identifier.getComponent(1).toString())) {</span>
<span class="nc" id="L554">          throw validator.newValidationError(identifier,</span>
<span class="nc" id="L555">              RESOURCE.disallowsQualifyingCommonColumn(identifier.toString()));</span>
        }
      }
<span class="nc" id="L558">    }</span>

    // Only need to try to validate the expr from the left input of join
    // since it is always left-deep join.
<span class="nc" id="L562">    final SqlNode node = join.getLeft();</span>
<span class="nc bnc" id="L563" title="All 2 branches missed.">    if (node instanceof SqlJoin) {</span>
<span class="nc" id="L564">      validateQualifiedCommonColumn((SqlJoin) node, identifier, scope, validator);</span>
    }
<span class="nc" id="L566">  }</span>

  private boolean expandStar(List&lt;SqlNode&gt; selectItems, Set&lt;String&gt; aliases,
      PairList&lt;String, RelDataType&gt; fields, boolean includeSystemVars,
      SelectScope scope, SqlNode node) {
<span class="nc bnc" id="L571" title="All 2 branches missed.">    if (!(node instanceof SqlIdentifier)) {</span>
<span class="nc" id="L572">      return false;</span>
    }
<span class="nc" id="L574">    final SqlIdentifier identifier = (SqlIdentifier) node;</span>
<span class="nc bnc" id="L575" title="All 2 branches missed.">    if (!identifier.isStar()) {</span>
<span class="nc" id="L576">      return false;</span>
    }
<span class="nc" id="L578">    final int originalSize = selectItems.size();</span>
<span class="nc" id="L579">    final SqlParserPos startPosition = identifier.getParserPosition();</span>
<span class="nc bnc" id="L580" title="All 2 branches missed.">    switch (identifier.names.size()) {</span>
    case 1:
<span class="nc" id="L582">      SqlNode from = scope.getNode().getFrom();</span>
<span class="nc bnc" id="L583" title="All 2 branches missed.">      if (from == null) {</span>
<span class="nc" id="L584">        throw newValidationError(identifier, RESOURCE.selectStarRequiresFrom());</span>
      }

<span class="nc" id="L587">      boolean hasDynamicStruct = false;</span>
<span class="nc bnc" id="L588" title="All 2 branches missed.">      for (ScopeChild child : scope.children) {</span>
<span class="nc" id="L589">        final int before = fields.size();</span>
<span class="nc bnc" id="L590" title="All 2 branches missed.">        if (child.namespace.getRowType().isDynamicStruct()) {</span>
<span class="nc" id="L591">          hasDynamicStruct = true;</span>
          // don't expand star if the underneath table is dynamic.
          // Treat this star as a special field in validation/conversion and
          // wait until execution time to expand this star.
<span class="nc" id="L595">          final SqlNode exp =</span>
              new SqlIdentifier(
<span class="nc" id="L597">                  ImmutableList.of(child.name,</span>
                      DynamicRecordType.DYNAMIC_STAR_PREFIX),
                  startPosition);
<span class="nc" id="L600">          addToSelectList(</span>
               selectItems,
               aliases,
               fields,
               exp,
               scope,
               includeSystemVars);
<span class="nc" id="L607">        } else {</span>
<span class="nc" id="L608">          final SqlNode from2 = SqlNonNullableAccessors.getNode(child);</span>
<span class="nc" id="L609">          final SqlValidatorNamespace fromNs = getNamespaceOrThrow(from2, scope);</span>
<span class="nc" id="L610">          final RelDataType rowType = fromNs.getRowType();</span>
<span class="nc bnc" id="L611" title="All 2 branches missed.">          for (RelDataTypeField field : rowType.getFieldList()) {</span>
<span class="nc" id="L612">            String columnName = field.getName();</span>

            // TODO: do real implicit collation here
<span class="nc" id="L615">            final SqlIdentifier exp =</span>
                new SqlIdentifier(
<span class="nc" id="L617">                    ImmutableList.of(child.name, columnName),</span>
                    startPosition);
            // Don't add expanded rolled up columns
<span class="nc bnc" id="L620" title="All 2 branches missed.">            if (!isRolledUpColumn(exp, scope)) {</span>
<span class="nc" id="L621">              addOrExpandField(</span>
                      selectItems,
                      aliases,
                      fields,
                      includeSystemVars,
                      scope,
                      exp,
                      field);
            }
<span class="nc" id="L630">          }</span>
        }
<span class="nc bnc" id="L632" title="All 2 branches missed.">        if (child.nullable) {</span>
<span class="nc bnc" id="L633" title="All 2 branches missed.">          for (int i = before; i &lt; fields.size(); i++) {</span>
<span class="nc" id="L634">            final Map.Entry&lt;String, RelDataType&gt; entry = fields.get(i);</span>
<span class="nc" id="L635">            final RelDataType type = entry.getValue();</span>
<span class="nc bnc" id="L636" title="All 2 branches missed.">            if (!type.isNullable()) {</span>
<span class="nc" id="L637">              fields.set(i,</span>
<span class="nc" id="L638">                  entry.getKey(),</span>
<span class="nc" id="L639">                  typeFactory.createTypeWithNullability(type, true));</span>
            }
          }
        }
<span class="nc" id="L643">      }</span>
      // If NATURAL JOIN or USING is present, move key fields to the front of
      // the list, per standard SQL. Disabled if there are dynamic fields.
<span class="nc bnc" id="L646" title="All 2 branches missed.">      if (!hasDynamicStruct || Bug.CALCITE_2400_FIXED) {</span>
        // If some fields before star identifier,
        // we should move offset.
<span class="nc" id="L649">        int offset = Math.min(calculatePermuteOffset(selectItems), originalSize);</span>
<span class="nc" id="L650">        new Permute(from, offset).permute(selectItems, fields);</span>
      }
<span class="nc" id="L652">      return true;</span>

    default:
<span class="nc" id="L655">      final SqlIdentifier prefixId = identifier.skipLast(1);</span>
<span class="nc" id="L656">      final SqlValidatorScope.ResolvedImpl resolved =</span>
          new SqlValidatorScope.ResolvedImpl();
<span class="nc" id="L658">      final SqlNameMatcher nameMatcher =</span>
<span class="nc" id="L659">          scope.validator.catalogReader.nameMatcher();</span>
<span class="nc" id="L660">      scope.resolve(prefixId.names, nameMatcher, true, resolved);</span>
<span class="nc bnc" id="L661" title="All 2 branches missed.">      if (resolved.count() == 0) {</span>
        // e.g. &quot;select s.t.* from e&quot;
        // or &quot;select r.* from e&quot;
<span class="nc" id="L664">        throw newValidationError(prefixId,</span>
<span class="nc" id="L665">            RESOURCE.unknownIdentifier(prefixId.toString()));</span>
      }
<span class="nc" id="L667">      final RelDataType rowType = resolved.only().rowType();</span>
<span class="nc bnc" id="L668" title="All 2 branches missed.">      if (rowType.isDynamicStruct()) {</span>
        // don't expand star if the underneath table is dynamic.
<span class="nc" id="L670">        addToSelectList(</span>
            selectItems,
            aliases,
            fields,
<span class="nc" id="L674">            prefixId.plus(DynamicRecordType.DYNAMIC_STAR_PREFIX, startPosition),</span>
            scope,
            includeSystemVars);
<span class="nc bnc" id="L677" title="All 2 branches missed.">      } else if (rowType.isStruct()) {</span>
<span class="nc bnc" id="L678" title="All 2 branches missed.">        for (RelDataTypeField field : rowType.getFieldList()) {</span>
<span class="nc" id="L679">          String columnName = field.getName();</span>

          // TODO: do real implicit collation here
<span class="nc" id="L682">          addOrExpandField(</span>
              selectItems,
              aliases,
              fields,
              includeSystemVars,
              scope,
<span class="nc" id="L688">              prefixId.plus(columnName, startPosition),</span>
              field);
<span class="nc" id="L690">        }</span>
      } else {
<span class="nc" id="L692">        throw newValidationError(prefixId, RESOURCE.starRequiresRecordType());</span>
      }
<span class="nc" id="L694">      return true;</span>
    }
  }

  private static int calculatePermuteOffset(List&lt;SqlNode&gt; selectItems) {
<span class="nc bnc" id="L699" title="All 2 branches missed.">    for (int i = 0; i &lt; selectItems.size(); i++) {</span>
<span class="nc" id="L700">      SqlNode selectItem = selectItems.get(i);</span>
<span class="nc" id="L701">      SqlNode col = stripAs(selectItem);</span>
<span class="nc bnc" id="L702" title="All 2 branches missed.">      if (col.getKind() == SqlKind.IDENTIFIER</span>
<span class="nc bnc" id="L703" title="All 2 branches missed.">          &amp;&amp; selectItem.getKind() != SqlKind.AS) {</span>
<span class="nc" id="L704">        return i;</span>
      }
    }
<span class="nc" id="L707">    return 0;</span>
  }

  private SqlNode maybeCast(SqlNode node, RelDataType currentType,
      RelDataType desiredType) {
<span class="nc bnc" id="L712" title="All 2 branches missed.">    return SqlTypeUtil.equalSansNullability(typeFactory, currentType, desiredType)</span>
<span class="nc" id="L713">        ? node</span>
<span class="nc" id="L714">        : SqlStdOperatorTable.CAST.createCall(SqlParserPos.ZERO,</span>
<span class="nc" id="L715">            node, SqlTypeUtil.convertTypeToSpec(desiredType));</span>
  }

  private boolean addOrExpandField(List&lt;SqlNode&gt; selectItems, Set&lt;String&gt; aliases,
      PairList&lt;String, RelDataType&gt; fields, boolean includeSystemVars,
      SelectScope scope, SqlIdentifier id, RelDataTypeField field) {
<span class="nc bnc" id="L721" title="All 2 branches missed.">    switch (field.getType().getStructKind()) {</span>
    case PEEK_FIELDS:
    case PEEK_FIELDS_DEFAULT:
<span class="nc" id="L724">      final SqlNode starExp = id.plusStar();</span>
<span class="nc" id="L725">      expandStar(</span>
          selectItems,
          aliases,
          fields,
          includeSystemVars,
          scope,
          starExp);
<span class="nc" id="L732">      return true;</span>

    default:
<span class="nc" id="L735">      addToSelectList(</span>
          selectItems,
          aliases,
          fields,
          id,
          scope,
          includeSystemVars);
    }

<span class="nc" id="L744">    return false;</span>
  }

  @Override public SqlNode validate(SqlNode topNode) {
<span class="nc" id="L748">    SqlValidatorScope scope = new TFEmptyScope(dialect, this);</span>
<span class="nc" id="L749">    scope = new CatalogScope(scope, ImmutableList.of(&quot;CATALOG&quot;));</span>
<span class="nc" id="L750">    final SqlNode topNode2 = validateScopedExpression(topNode, scope);</span>
<span class="nc" id="L751">    final RelDataType type = getValidatedNodeType(topNode2);</span>
<span class="nc" id="L752">    Util.discard(type);</span>
<span class="nc" id="L753">    return topNode2;</span>
  }

  @Override public List&lt;SqlMoniker&gt; lookupHints(SqlNode topNode, SqlParserPos pos) {
<span class="nc" id="L757">    SqlValidatorScope scope = new TFEmptyScope(dialect, this);</span>
<span class="nc" id="L758">    SqlNode outermostNode = performUnconditionalRewrites(topNode, false);</span>
<span class="nc" id="L759">    cursorSet.add(outermostNode);</span>
<span class="nc bnc" id="L760" title="All 2 branches missed.">    if (outermostNode.isA(SqlKind.TOP_LEVEL)) {</span>
<span class="nc" id="L761">      registerQuery(</span>
          scope,
          null,
          outermostNode,
          outermostNode,
          null,
          false);
    }
<span class="nc" id="L769">    final SqlValidatorNamespace ns = getNamespace(outermostNode);</span>
<span class="nc bnc" id="L770" title="All 2 branches missed.">    if (ns == null) {</span>
<span class="nc" id="L771">      throw new AssertionError(&quot;Not a query: &quot; + outermostNode);</span>
    }
<span class="nc" id="L773">    Collection&lt;SqlMoniker&gt; hintList = Sets.newTreeSet(SqlMoniker.COMPARATOR);</span>
<span class="nc" id="L774">    lookupSelectHints(ns, pos, hintList);</span>
<span class="nc" id="L775">    return ImmutableList.copyOf(hintList);</span>
  }

  @Override public @Nullable SqlMoniker lookupQualifiedName(SqlNode topNode, SqlParserPos pos) {
<span class="nc" id="L779">    final String posString = pos.toString();</span>
<span class="nc" id="L780">    IdInfo info = idPositions.get(posString);</span>
<span class="nc bnc" id="L781" title="All 2 branches missed.">    if (info != null) {</span>
<span class="nc" id="L782">      final SqlQualified qualified = info.scope.fullyQualify(info.id);</span>
<span class="nc" id="L783">      return new SqlIdentifierMoniker(qualified.identifier);</span>
    } else {
<span class="nc" id="L785">      return null;</span>
    }
  }

  /**
   * Looks up completion hints for a syntactically correct select SQL that has
   * been parsed into an expression tree.
   *
   * @param select   the Select node of the parsed expression tree
   * @param pos      indicates the position in the sql statement we want to get
   *                 completion hints for
   * @param hintList list of {@link SqlMoniker} (sql identifiers) that can
   *                 fill in at the indicated position
   */
  void lookupSelectHints(
      SqlSelect select,
      SqlParserPos pos,
      Collection&lt;SqlMoniker&gt; hintList) {
<span class="nc" id="L803">    IdInfo info = idPositions.get(pos.toString());</span>
<span class="nc bnc" id="L804" title="All 2 branches missed.">    if (info == null) {</span>
<span class="nc" id="L805">      SqlNode fromNode = select.getFrom();</span>
<span class="nc" id="L806">      final SqlValidatorScope fromScope = getFromScope(select);</span>
<span class="nc" id="L807">      lookupFromHints(fromNode, fromScope, pos, hintList);</span>
<span class="nc" id="L808">    } else {</span>
<span class="nc" id="L809">      lookupNameCompletionHints(info.scope, info.id.names,</span>
<span class="nc" id="L810">          info.id.getParserPosition(), hintList);</span>
    }
<span class="nc" id="L812">  }</span>

  private void lookupSelectHints(
      SqlValidatorNamespace ns,
      SqlParserPos pos,
      Collection&lt;SqlMoniker&gt; hintList) {
<span class="nc" id="L818">    final SqlNode node = ns.getNode();</span>
<span class="nc bnc" id="L819" title="All 2 branches missed.">    if (node instanceof SqlSelect) {</span>
<span class="nc" id="L820">      lookupSelectHints((SqlSelect) node, pos, hintList);</span>
    }
<span class="nc" id="L822">  }</span>

  private void lookupFromHints(
      @Nullable SqlNode node,
      SqlValidatorScope scope,
      SqlParserPos pos,
      Collection&lt;SqlMoniker&gt; hintList) {
<span class="nc bnc" id="L829" title="All 2 branches missed.">    if (node == null) {</span>
      // This can happen in cases like &quot;select * _suggest_&quot;, so from clause is absent
<span class="nc" id="L831">      return;</span>
    }
<span class="nc" id="L833">    final SqlValidatorNamespace ns = getNamespaceOrThrow(node);</span>
<span class="nc bnc" id="L834" title="All 2 branches missed.">    if (ns.isWrapperFor(IdentifierNamespace.class)) {</span>
<span class="nc" id="L835">      IdentifierNamespace idNs = ns.unwrap(IdentifierNamespace.class);</span>
<span class="nc" id="L836">      final SqlIdentifier id = idNs.getId();</span>
<span class="nc bnc" id="L837" title="All 2 branches missed.">      for (int i = 0; i &lt; id.names.size(); i++) {</span>
<span class="nc bnc" id="L838" title="All 2 branches missed.">        if (pos.toString().equals(</span>
<span class="nc" id="L839">            id.getComponent(i).getParserPosition().toString())) {</span>
<span class="nc" id="L840">          final List&lt;SqlMoniker&gt; objNames = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L841">          SqlValidatorUtil.getSchemaObjectMonikers(</span>
<span class="nc" id="L842">              getCatalogReader(),</span>
<span class="nc" id="L843">              id.names.subList(0, i + 1),</span>
              objNames);
<span class="nc bnc" id="L845" title="All 2 branches missed.">          for (SqlMoniker objName : objNames) {</span>
<span class="nc bnc" id="L846" title="All 2 branches missed.">            if (objName.getType() != SqlMonikerType.FUNCTION) {</span>
<span class="nc" id="L847">              hintList.add(objName);</span>
            }
<span class="nc" id="L849">          }</span>
<span class="nc" id="L850">          return;</span>
        }
      }
    }
<span class="nc bnc" id="L854" title="All 2 branches missed.">    switch (node.getKind()) {</span>
    case JOIN:
<span class="nc" id="L856">      lookupJoinHints((SqlJoin) node, scope, pos, hintList);</span>
<span class="nc" id="L857">      break;</span>
    default:
<span class="nc" id="L859">      lookupSelectHints(ns, pos, hintList);</span>
      break;
    }
<span class="nc" id="L862">  }</span>

  private void lookupJoinHints(
      SqlJoin join,
      SqlValidatorScope scope,
      SqlParserPos pos,
      Collection&lt;SqlMoniker&gt; hintList) {
<span class="nc" id="L869">    SqlNode left = join.getLeft();</span>
<span class="nc" id="L870">    SqlNode right = join.getRight();</span>
<span class="nc" id="L871">    SqlNode condition = join.getCondition();</span>
<span class="nc" id="L872">    lookupFromHints(left, scope, pos, hintList);</span>
<span class="nc bnc" id="L873" title="All 2 branches missed.">    if (!hintList.isEmpty()) {</span>
<span class="nc" id="L874">      return;</span>
    }
<span class="nc" id="L876">    lookupFromHints(right, scope, pos, hintList);</span>
<span class="nc bnc" id="L877" title="All 2 branches missed.">    if (!hintList.isEmpty()) {</span>
<span class="nc" id="L878">      return;</span>
    }
<span class="nc" id="L880">    final JoinConditionType conditionType = join.getConditionType();</span>
<span class="nc bnc" id="L881" title="All 2 branches missed.">    switch (conditionType) {</span>
    case ON:
<span class="nc" id="L883">      requireNonNull(condition, () -&gt; &quot;join.getCondition() for &quot; + join)</span>
<span class="nc" id="L884">          .findValidOptions(this,</span>
<span class="nc" id="L885">              getScopeOrThrow(join),</span>
              pos, hintList);
<span class="nc" id="L887">      return;</span>
    default:

      // No suggestions.
      // Not supporting hints for other types such as 'Using' yet.
    }
<span class="nc" id="L893">  }</span>

  /**
   * Populates a list of all the valid alternatives for an identifier.
   *
   * @param scope    Validation scope
   * @param names    Components of the identifier
   * @param pos      position
   * @param hintList a list of valid options
   */
  public final void lookupNameCompletionHints(
      SqlValidatorScope scope,
      List&lt;String&gt; names,
      SqlParserPos pos,
      Collection&lt;SqlMoniker&gt; hintList) {
    // Remove the last part of name - it is a dummy
<span class="nc" id="L909">    List&lt;String&gt; subNames = Util.skipLast(names);</span>

<span class="nc bnc" id="L911" title="All 2 branches missed.">    if (!subNames.isEmpty()) {</span>
      // If there's a prefix, resolve it to a namespace.
<span class="nc" id="L913">      SqlValidatorNamespace ns = null;</span>
<span class="nc bnc" id="L914" title="All 2 branches missed.">      for (String name : subNames) {</span>
<span class="nc bnc" id="L915" title="All 2 branches missed.">        if (ns == null) {</span>
<span class="nc" id="L916">          final SqlValidatorScope.ResolvedImpl resolved =</span>
              new SqlValidatorScope.ResolvedImpl();
<span class="nc" id="L918">          final SqlNameMatcher nameMatcher = catalogReader.nameMatcher();</span>
<span class="nc" id="L919">          scope.resolve(ImmutableList.of(name), nameMatcher, false, resolved);</span>
<span class="nc bnc" id="L920" title="All 2 branches missed.">          if (resolved.count() == 1) {</span>
<span class="nc" id="L921">            ns = resolved.only().namespace;</span>
          }
<span class="nc" id="L923">        } else {</span>
<span class="nc" id="L924">          ns = ns.lookupChild(name);</span>
        }
<span class="nc bnc" id="L926" title="All 2 branches missed.">        if (ns == null) {</span>
<span class="nc" id="L927">          break;</span>
        }
<span class="nc" id="L929">      }</span>
<span class="nc bnc" id="L930" title="All 2 branches missed.">      if (ns != null) {</span>
<span class="nc" id="L931">        RelDataType rowType = ns.getRowType();</span>
<span class="nc bnc" id="L932" title="All 2 branches missed.">        if (rowType.isStruct()) {</span>
<span class="nc bnc" id="L933" title="All 2 branches missed.">          for (RelDataTypeField field : rowType.getFieldList()) {</span>
<span class="nc" id="L934">            hintList.add(</span>
                new SqlMonikerImpl(
<span class="nc" id="L936">                    field.getName(),</span>
                    SqlMonikerType.COLUMN));
<span class="nc" id="L938">          }</span>
        }
      }

      // builtin function names are valid completion hints when the
      // identifier has only 1 name part
<span class="nc" id="L944">      findAllValidFunctionNames(names, this, hintList, pos);</span>
<span class="nc" id="L945">    } else {</span>
      // No prefix; use the children of the current scope (that is,
      // the aliases in the FROM clause)
<span class="nc" id="L948">      scope.findAliases(hintList);</span>

      // If there's only one alias, add all child columns
<span class="nc" id="L951">      SelectScope selectScope =</span>
<span class="nc" id="L952">          SqlValidatorUtil.getEnclosingSelectScope(scope);</span>
<span class="nc bnc" id="L953" title="All 2 branches missed.">      if ((selectScope != null)</span>
<span class="nc bnc" id="L954" title="All 2 branches missed.">          &amp;&amp; (selectScope.getChildren().size() == 1)) {</span>
<span class="nc" id="L955">        RelDataType rowType =</span>
<span class="nc" id="L956">            selectScope.getChildren().get(0).getRowType();</span>
<span class="nc bnc" id="L957" title="All 2 branches missed.">        for (RelDataTypeField field : rowType.getFieldList()) {</span>
<span class="nc" id="L958">          hintList.add(</span>
              new SqlMonikerImpl(
<span class="nc" id="L960">                  field.getName(),</span>
                  SqlMonikerType.COLUMN));
<span class="nc" id="L962">        }</span>
      }
    }

<span class="nc" id="L966">    findAllValidUdfNames(names, this, hintList);</span>
<span class="nc" id="L967">  }</span>

  private static void findAllValidUdfNames(
      List&lt;String&gt; names,
      SqlValidator validator,
      Collection&lt;SqlMoniker&gt; result) {
<span class="nc" id="L973">    final List&lt;SqlMoniker&gt; objNames = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L974">    SqlValidatorUtil.getSchemaObjectMonikers(</span>
<span class="nc" id="L975">        validator.getCatalogReader(),</span>
        names,
        objNames);
<span class="nc bnc" id="L978" title="All 2 branches missed.">    for (SqlMoniker objName : objNames) {</span>
<span class="nc bnc" id="L979" title="All 2 branches missed.">      if (objName.getType() == SqlMonikerType.FUNCTION) {</span>
<span class="nc" id="L980">        result.add(objName);</span>
      }
<span class="nc" id="L982">    }</span>
<span class="nc" id="L983">  }</span>

  private static void findAllValidFunctionNames(
      List&lt;String&gt; names,
      SqlValidator validator,
      Collection&lt;SqlMoniker&gt; result,
      SqlParserPos pos) {
    // a function name can only be 1 part
<span class="nc bnc" id="L991" title="All 2 branches missed.">    if (names.size() &gt; 1) {</span>
<span class="nc" id="L992">      return;</span>
    }
<span class="nc bnc" id="L994" title="All 2 branches missed.">    for (SqlOperator op : validator.getOperatorTable().getOperatorList()) {</span>
<span class="nc" id="L995">      SqlIdentifier curOpId =</span>
          new SqlIdentifier(
<span class="nc" id="L997">              op.getName(),</span>
              pos);

<span class="nc" id="L1000">      final SqlCall call = validator.makeNullaryCall(curOpId);</span>
<span class="nc bnc" id="L1001" title="All 2 branches missed.">      if (call != null) {</span>
<span class="nc" id="L1002">        result.add(</span>
            new SqlMonikerImpl(
<span class="nc" id="L1004">                op.getName(),</span>
                SqlMonikerType.FUNCTION));
      } else {
<span class="nc bnc" id="L1007" title="All 2 branches missed.">        if ((op.getSyntax() == SqlSyntax.FUNCTION)</span>
<span class="nc bnc" id="L1008" title="All 2 branches missed.">            || (op.getSyntax() == SqlSyntax.PREFIX)) {</span>
<span class="nc bnc" id="L1009" title="All 2 branches missed.">          if (op.getOperandTypeChecker() != null) {</span>
<span class="nc" id="L1010">            String sig = op.getAllowedSignatures();</span>
<span class="nc" id="L1011">            sig = sig.replace(&quot;'&quot;, &quot;&quot;);</span>
<span class="nc" id="L1012">            result.add(</span>
                new SqlMonikerImpl(
                    sig,
                    SqlMonikerType.FUNCTION));
<span class="nc" id="L1016">            continue;</span>
          }
<span class="nc" id="L1018">          result.add(</span>
              new SqlMonikerImpl(
<span class="nc" id="L1020">                  op.getName(),</span>
                  SqlMonikerType.FUNCTION));
        }
      }
<span class="nc" id="L1024">    }</span>
<span class="nc" id="L1025">  }</span>

  @Override public SqlNode validateParameterizedExpression(
      SqlNode topNode,
      final Map&lt;String, RelDataType&gt; nameToTypeMap) {
<span class="nc" id="L1030">    SqlValidatorScope scope = new ParameterScope(this, nameToTypeMap);</span>
<span class="nc" id="L1031">    return validateScopedExpression(topNode, scope);</span>
  }

  private SqlNode validateScopedExpression(
      SqlNode topNode,
      SqlValidatorScope scope) {
<span class="nc" id="L1037">    SqlNode outermostNode = performUnconditionalRewrites(topNode, false);</span>
<span class="nc" id="L1038">    cursorSet.add(outermostNode);</span>
<span class="nc" id="L1039">    top = outermostNode;</span>
<span class="nc" id="L1040">    TRACER.trace(&quot;After unconditional rewrite: {}&quot;, outermostNode);</span>
<span class="nc bnc" id="L1041" title="All 2 branches missed.">    if (outermostNode.isA(SqlKind.TOP_LEVEL)) {</span>
<span class="nc" id="L1042">      registerQuery(scope, null, outermostNode, outermostNode, null, false);</span>
    }
<span class="nc" id="L1044">    outermostNode.validate(this, scope);</span>
<span class="nc bnc" id="L1045" title="All 2 branches missed.">    if (!outermostNode.isA(SqlKind.TOP_LEVEL)) {</span>
      // force type derivation so that we can provide it to the
      // caller later without needing the scope
<span class="nc" id="L1048">      deriveType(scope, outermostNode);</span>
    }
<span class="nc" id="L1050">    TRACER.trace(&quot;After validation: {}&quot;, outermostNode);</span>
<span class="nc" id="L1051">    return outermostNode;</span>
  }

  @Override public void validateQuery(SqlNode node, SqlValidatorScope scope,
      RelDataType targetRowType) {
<span class="nc" id="L1056">    final SqlValidatorNamespace ns = getNamespaceOrThrow(node, scope);</span>
<span class="nc bnc" id="L1057" title="All 2 branches missed.">    if (node.getKind() == SqlKind.TABLESAMPLE) {</span>
<span class="nc" id="L1058">      List&lt;SqlNode&gt; operands = ((SqlCall) node).getOperandList();</span>
<span class="nc" id="L1059">      SqlSampleSpec sampleSpec = SqlLiteral.sampleValue(operands.get(1));</span>
<span class="nc bnc" id="L1060" title="All 2 branches missed.">      if (sampleSpec instanceof SqlSampleSpec.SqlTableSampleSpec) {</span>
        // The sampling percentage must be between 0 (0%) and 1 (100%).
<span class="nc" id="L1062">        BigDecimal samplePercentage =</span>
            ((SqlSampleSpec.SqlTableSampleSpec) sampleSpec).sampleRate;
        // Check the samplePercentage whether is between 0 and 1
<span class="nc bnc" id="L1065" title="All 2 branches missed.">        if (samplePercentage.compareTo(BigDecimal.ZERO) &lt; 0</span>
<span class="nc bnc" id="L1066" title="All 2 branches missed.">            || samplePercentage.compareTo(BigDecimal.ONE) &gt; 0) {</span>
<span class="nc" id="L1067">          throw SqlUtil.newContextException(node.getParserPosition(),</span>
<span class="nc" id="L1068">              RESOURCE.invalidSampleSize());</span>
        }
<span class="nc" id="L1070">        validateFeature(RESOURCE.sQLFeature_T613(), node.getParserPosition());</span>
<span class="nc bnc" id="L1071" title="All 2 branches missed.">      } else if (sampleSpec</span>
          instanceof SqlSampleSpec.SqlSubstitutionSampleSpec) {
<span class="nc" id="L1073">        validateFeature(RESOURCE.sQLFeatureExt_T613_Substitution(),</span>
<span class="nc" id="L1074">            node.getParserPosition());</span>
      }
    }

<span class="nc" id="L1078">    validateNamespace(ns, targetRowType);</span>
<span class="nc bnc" id="L1079" title="All 2 branches missed.">    switch (node.getKind()) {</span>
    case EXTEND:
      // Until we have a dedicated namespace for EXTEND
<span class="nc" id="L1082">      deriveType(requireNonNull(scope, &quot;scope&quot;), node);</span>
<span class="nc" id="L1083">      break;</span>
    default:
      break;
    }
<span class="nc bnc" id="L1087" title="All 4 branches missed.">    if (node == top &amp;&amp; !config.embeddedQuery()) {</span>
<span class="nc" id="L1088">      validateModality(node);</span>
    }
<span class="nc" id="L1090">    validateAccess(</span>
        node,
<span class="nc" id="L1092">        ns.getTable(),</span>
        SqlAccessEnum.SELECT);

<span class="nc" id="L1095">    validateSnapshot(node, scope, ns);</span>
<span class="nc" id="L1096">  }</span>

  /**
   * Validates a namespace.
   *
   * @param namespace Namespace
   * @param targetRowType Desired row type, must not be null, may be the data
   *                      type 'unknown'.
   */
  protected void validateNamespace(final SqlValidatorNamespace namespace,
      RelDataType targetRowType) {
<span class="nc" id="L1107">    namespace.validate(targetRowType);</span>
<span class="nc" id="L1108">    final SqlNode node = namespace.getNode();</span>
<span class="nc bnc" id="L1109" title="All 2 branches missed.">    if (node != null) {</span>
<span class="nc" id="L1110">      RelDataType type = namespace.getType();</span>

<span class="nc bnc" id="L1112" title="All 2 branches missed.">      if (node == top) {</span>
        // A top-level namespace must not return any must-filter fields.
        // A non-top-level namespace (e.g. a subquery) may return must-filter
        // fields; these are neutralized if the consuming query filters on them.
<span class="nc" id="L1116">        final ImmutableBitSet mustFilterFields =</span>
<span class="nc" id="L1117">            namespace.getMustFilterFields();</span>
<span class="nc bnc" id="L1118" title="All 2 branches missed.">        if (!mustFilterFields.isEmpty()) {</span>
          // Set of field names, sorted alphabetically for determinism.
<span class="nc" id="L1120">          Set&lt;String&gt; fieldNameSet =</span>
<span class="nc" id="L1121">              StreamSupport.stream(mustFilterFields.spliterator(), false)</span>
<span class="nc" id="L1122">                  .map(namespace.getRowType().getFieldNames()::get)</span>
<span class="nc" id="L1123">                  .collect(Collectors.toCollection(TreeSet::new));</span>
<span class="nc" id="L1124">          throw newValidationError(node,</span>
<span class="nc" id="L1125">              RESOURCE.mustFilterFieldsMissing(fieldNameSet.toString()));</span>
        }

<span class="nc bnc" id="L1128" title="All 2 branches missed.">        if (!config.embeddedQuery()) {</span>
<span class="nc" id="L1129">          type = SqlTypeUtil.fromMeasure(typeFactory, type);</span>
        }
      }
<span class="nc" id="L1132">      setValidatedNodeType(node, type);</span>
    }
<span class="nc" id="L1134">  }</span>

  @Override public SqlValidatorScope getEmptyScope() {
<span class="nc" id="L1137">    return new TFEmptyScope(dialect, this);</span>
  }

  private SqlValidatorScope getScope(SqlSelect select, Clause clause) {
<span class="nc" id="L1141">    return requireNonNull(</span>
<span class="nc" id="L1142">        clauseScopes.get(IdPair.of(select, clause)),</span>
<span class="nc" id="L1143">        () -&gt; &quot;no &quot; + clause + &quot; scope for &quot; + select);</span>
  }

  public SqlValidatorScope getCursorScope(SqlSelect select) {
<span class="nc" id="L1147">    return getScope(select, Clause.CURSOR);</span>
  }

  @Override public SqlValidatorScope getWhereScope(SqlSelect select) {
<span class="nc" id="L1151">    return getScope(select, Clause.WHERE);</span>
  }

  @Override public SqlValidatorScope getSelectScope(SqlSelect select) {
<span class="nc" id="L1155">    return getScope(select, Clause.SELECT);</span>
  }

  @Override public SqlValidatorScope getMeasureScope(SqlSelect select) {
<span class="nc" id="L1159">    return getScope(select, Clause.MEASURE);</span>
  }

  @Override public @Nullable SelectScope getRawSelectScope(SqlSelect select) {
<span class="nc" id="L1163">    SqlValidatorScope scope = clauseScopes.get(IdPair.of(select, Clause.SELECT));</span>
<span class="nc bnc" id="L1164" title="All 2 branches missed.">    if (scope instanceof AggregatingSelectScope) {</span>
<span class="nc" id="L1165">      scope = ((AggregatingSelectScope) scope).getParent();</span>
    }
<span class="nc" id="L1167">    return (SelectScope) scope;</span>
  }

  private SelectScope getRawSelectScopeNonNull(SqlSelect select) {
<span class="nc" id="L1171">    return requireNonNull(getRawSelectScope(select),</span>
<span class="nc" id="L1172">        () -&gt; &quot;getRawSelectScope for &quot; + select);</span>
  }

  @Override public SqlValidatorScope getHavingScope(SqlSelect select) {
    // Yes, it's the same as getSelectScope
<span class="nc" id="L1177">    return getScope(select, Clause.SELECT);</span>
  }

  @Override public SqlValidatorScope getGroupScope(SqlSelect select) {
    // Yes, it's the same as getWhereScope
<span class="nc" id="L1182">    return getScope(select, Clause.WHERE);</span>
  }

  @Override public SqlValidatorScope getFromScope(SqlSelect select) {
<span class="nc" id="L1186">    return requireNonNull(scopes.get(select),</span>
<span class="nc" id="L1187">        () -&gt; &quot;no scope for &quot; + select);</span>
  }

  @Override public SqlValidatorScope getOrderScope(SqlSelect select) {
<span class="nc" id="L1191">    return getScope(select, Clause.ORDER);</span>
  }

  @Override public SqlValidatorScope getMatchRecognizeScope(SqlMatchRecognize node) {
<span class="nc" id="L1195">    return getScopeOrThrow(node);</span>
  }

  @Override public SqlValidatorScope getLambdaScope(SqlLambda node) {
<span class="nc" id="L1199">    return getScopeOrThrow(node);</span>
  }

  @Override public SqlValidatorScope getJoinScope(SqlNode node) {
<span class="nc" id="L1203">    return requireNonNull(scopes.get(stripAs(node)),</span>
<span class="nc" id="L1204">        () -&gt; &quot;scope for &quot; + node);</span>
  }

  @Override public SqlValidatorScope getOverScope(SqlNode node) {
<span class="nc" id="L1208">    return getScopeOrThrow(node);</span>
  }

  @Override public SqlValidatorScope getWithScope(SqlNode withItem) {
<span class="nc bnc" id="L1212" title="All 2 branches missed.">    assert withItem.getKind() == SqlKind.WITH_ITEM;</span>
<span class="nc" id="L1213">    return getScopeOrThrow(withItem);</span>
  }

  private SqlValidatorScope getScopeOrThrow(SqlNode node) {
<span class="nc" id="L1217">    return requireNonNull(scopes.get(node), () -&gt; &quot;scope for &quot; + node);</span>
  }

  private @Nullable SqlValidatorNamespace getNamespace(SqlNode node,
      SqlValidatorScope scope) {
<span class="nc bnc" id="L1222" title="All 4 branches missed.">    if (node instanceof SqlIdentifier &amp;&amp; scope instanceof DelegatingScope) {</span>
<span class="nc" id="L1223">      final SqlIdentifier id = (SqlIdentifier) node;</span>
<span class="nc" id="L1224">      final DelegatingScope idScope =</span>
<span class="nc" id="L1225">          (DelegatingScope) ((DelegatingScope) scope).getParent();</span>
<span class="nc" id="L1226">      return getNamespace(id, idScope);</span>
<span class="nc bnc" id="L1227" title="All 2 branches missed.">    } else if (node instanceof SqlCall) {</span>
      // Handle extended identifiers.
<span class="nc" id="L1229">      final SqlCall call = (SqlCall) node;</span>
<span class="nc bnc" id="L1230" title="All 4 branches missed.">      switch (call.getOperator().getKind()) {</span>
      case TABLE_REF:
<span class="nc" id="L1232">        return getNamespace(call.operand(0), scope);</span>
      case EXTEND:
<span class="nc" id="L1234">        final SqlNode operand0 = call.getOperandList().get(0);</span>
<span class="nc bnc" id="L1235" title="All 2 branches missed.">        final SqlIdentifier identifier = operand0.getKind() == SqlKind.TABLE_REF</span>
<span class="nc" id="L1236">            ? ((SqlCall) operand0).operand(0)</span>
<span class="nc" id="L1237">            : (SqlIdentifier) operand0;</span>
<span class="nc" id="L1238">        final DelegatingScope idScope = (DelegatingScope) scope;</span>
<span class="nc" id="L1239">        return getNamespace(identifier, idScope);</span>
      case AS:
<span class="nc" id="L1241">        final SqlNode nested = call.getOperandList().get(0);</span>
<span class="nc bnc" id="L1242" title="All 2 branches missed.">        switch (nested.getKind()) {</span>
        case TABLE_REF:
        case EXTEND:
<span class="nc" id="L1245">          return getNamespace(nested, scope);</span>
        default:
<span class="nc" id="L1247">          break;</span>
        }
        break;
      default:
        break;
      }
    }
<span class="nc" id="L1254">    return getNamespace(node);</span>
  }

  private @Nullable SqlValidatorNamespace getNamespace(SqlIdentifier id,
      @Nullable DelegatingScope scope) {
<span class="nc bnc" id="L1259" title="All 2 branches missed.">    if (id.isSimple()) {</span>
<span class="nc" id="L1260">      final SqlNameMatcher nameMatcher = catalogReader.nameMatcher();</span>
<span class="nc" id="L1261">      final SqlValidatorScope.ResolvedImpl resolved =</span>
          new SqlValidatorScope.ResolvedImpl();
<span class="nc" id="L1263">      requireNonNull(scope, () -&gt; &quot;scope needed to lookup &quot; + id)</span>
<span class="nc" id="L1264">          .resolve(id.names, nameMatcher, false, resolved);</span>
<span class="nc bnc" id="L1265" title="All 2 branches missed.">      if (resolved.count() == 1) {</span>
<span class="nc" id="L1266">        return resolved.only().namespace;</span>
      }
    }
<span class="nc" id="L1269">    return getNamespace(id);</span>
  }

  @Override public @Nullable SqlValidatorNamespace getNamespace(SqlNode node) {
<span class="nc bnc" id="L1273" title="All 3 branches missed.">    switch (node.getKind()) {</span>
    case AS:

      // AS has a namespace if it has a column list 'AS t (c1, c2, ...)'
<span class="nc" id="L1277">      final SqlValidatorNamespace ns = namespaces.get(node);</span>
<span class="nc bnc" id="L1278" title="All 2 branches missed.">      if (ns != null) {</span>
<span class="nc" id="L1279">        return ns;</span>
      }
      // fall through
    case TABLE_REF:
    case SNAPSHOT:
    case OVER:
    case COLLECTION_TABLE:
    case ORDER_BY:
    case TABLESAMPLE:
<span class="nc" id="L1288">      return getNamespace(((SqlCall) node).operand(0));</span>
    default:
<span class="nc" id="L1290">      return namespaces.get(node);</span>
    }
  }

  /**
   * Namespace for the given node.
   *
   * @param node node to compute the namespace for
   * @return namespace for the given node, never null
   * @see #getNamespace(SqlNode)
   */
  @API(since = &quot;1.27&quot;, status = API.Status.INTERNAL)
  SqlValidatorNamespace getNamespaceOrThrow(SqlNode node) {
<span class="nc" id="L1303">    return requireNonNull(</span>
<span class="nc" id="L1304">        getNamespace(node),</span>
<span class="nc" id="L1305">        () -&gt; &quot;namespace for &quot; + node);</span>
  }

  /**
   * Namespace for the given node.
   *
   * @param node node to compute the namespace for
   * @param scope namespace scope
   * @return namespace for the given node, never null
   * @see #getNamespace(SqlNode)
   */
  @API(since = &quot;1.27&quot;, status = API.Status.INTERNAL)
  SqlValidatorNamespace getNamespaceOrThrow(SqlNode node,
      SqlValidatorScope scope) {
<span class="nc" id="L1319">    return requireNonNull(</span>
<span class="nc" id="L1320">        getNamespace(node, scope),</span>
<span class="nc" id="L1321">        () -&gt; &quot;namespace for &quot; + node + &quot;, scope &quot; + scope);</span>
  }

  /**
   * Namespace for the given node.
   *
   * @param id identifier to resolve
   * @param scope namespace scope
   * @return namespace for the given node, never null
   * @see #getNamespace(SqlIdentifier, DelegatingScope)
   */
  @API(since = &quot;1.26&quot;, status = API.Status.INTERNAL)
  SqlValidatorNamespace getNamespaceOrThrow(SqlIdentifier id,
      @Nullable DelegatingScope scope) {
<span class="nc" id="L1335">    return requireNonNull(</span>
<span class="nc" id="L1336">        getNamespace(id, scope),</span>
<span class="nc" id="L1337">        () -&gt; &quot;namespace for &quot; + id + &quot;, scope &quot; + scope);</span>
  }

  private void handleOffsetFetch(@Nullable SqlNode offset, @Nullable SqlNode fetch) {
<span class="nc bnc" id="L1341" title="All 2 branches missed.">    if (offset instanceof SqlDynamicParam) {</span>
<span class="nc" id="L1342">      setValidatedNodeType(offset,</span>
<span class="nc" id="L1343">          typeFactory.createSqlType(SqlTypeName.INTEGER));</span>
    }
<span class="nc bnc" id="L1345" title="All 2 branches missed.">    if (fetch instanceof SqlDynamicParam) {</span>
<span class="nc" id="L1346">      setValidatedNodeType(fetch,</span>
<span class="nc" id="L1347">          typeFactory.createSqlType(SqlTypeName.INTEGER));</span>
    }
<span class="nc" id="L1349">  }</span>

  /**
   * Performs expression rewrites which are always used unconditionally. These
   * rewrites massage the expression tree into a standard form so that the
   * rest of the validation logic can be simpler.
   *
   * &lt;p&gt;Returns null if and only if the original expression is null.
   *
   * @param node      expression to be rewritten
   * @param underFrom whether node appears directly under a FROM clause
   * @return rewritten expression, or null if the original expression is null
   */
  protected @PolyNull SqlNode performUnconditionalRewrites(
      @PolyNull SqlNode node,
      boolean underFrom) {
<span class="nc bnc" id="L1365" title="All 2 branches missed.">    if (node == null) {</span>
<span class="nc" id="L1366">      return null;</span>
    }

    // first transform operands and invoke generic call rewrite
<span class="nc bnc" id="L1370" title="All 2 branches missed.">    if (node instanceof SqlCall) {</span>
<span class="nc bnc" id="L1371" title="All 2 branches missed.">      if (node instanceof SqlMerge) {</span>
<span class="nc" id="L1372">        validatingSqlMerge = true;</span>
      }
<span class="nc" id="L1374">      SqlCall call = (SqlCall) node;</span>
<span class="nc" id="L1375">      final SqlKind kind = call.getKind();</span>
<span class="nc" id="L1376">      final List&lt;SqlNode&gt; operands = call.getOperandList();</span>
<span class="nc bnc" id="L1377" title="All 2 branches missed.">      for (int i = 0; i &lt; operands.size(); i++) {</span>
<span class="nc" id="L1378">        SqlNode operand = operands.get(i);</span>
        boolean childUnderFrom;
<span class="nc bnc" id="L1380" title="All 2 branches missed.">        if (kind == SqlKind.SELECT) {</span>
<span class="nc bnc" id="L1381" title="All 2 branches missed.">          childUnderFrom = i == SqlSelect.FROM_OPERAND;</span>
<span class="nc bnc" id="L1382" title="All 4 branches missed.">        } else if (kind == SqlKind.AS &amp;&amp; (i == 0)) {</span>
          // for an aliased expression, it is under FROM if
          // the AS expression is under FROM
<span class="nc" id="L1385">          childUnderFrom = underFrom;</span>
        } else {
<span class="nc" id="L1387">          childUnderFrom = false;</span>
        }
<span class="nc" id="L1389">        SqlNode newOperand =</span>
<span class="nc" id="L1390">            performUnconditionalRewrites(operand, childUnderFrom);</span>
<span class="nc bnc" id="L1391" title="All 4 branches missed.">        if (newOperand != null &amp;&amp; newOperand != operand) {</span>
<span class="nc" id="L1392">          call.setOperand(i, newOperand);</span>
        }
      }

<span class="nc bnc" id="L1396" title="All 2 branches missed.">      if (call.getOperator() instanceof SqlUnresolvedFunction) {</span>
<span class="nc bnc" id="L1397" title="All 2 branches missed.">        assert call instanceof SqlBasicCall;</span>
<span class="nc" id="L1398">        final SqlUnresolvedFunction function =</span>
<span class="nc" id="L1399">            (SqlUnresolvedFunction) call.getOperator();</span>
        // This function hasn't been resolved yet.  Perform
        // a half-hearted resolution now in case it's a
        // builtin function requiring special casing.  If it's
        // not, we'll handle it later during overload resolution.
<span class="nc" id="L1404">        final List&lt;SqlOperator&gt; overloads = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L1405">        opTab.lookupOperatorOverloads(function.getNameAsId(),</span>
<span class="nc" id="L1406">            function.getFunctionType(), SqlSyntax.FUNCTION, overloads,</span>
<span class="nc" id="L1407">            catalogReader.nameMatcher());</span>
<span class="nc bnc" id="L1408" title="All 2 branches missed.">        if (overloads.size() == 1) {</span>
<span class="nc" id="L1409">          ((SqlBasicCall) call).setOperator(overloads.get(0));</span>
        }
      }
<span class="nc bnc" id="L1412" title="All 2 branches missed.">      if (config.callRewrite()) {</span>
<span class="nc" id="L1413">        node = call.getOperator().rewriteCall(this, call);</span>
      }
<span class="nc bnc" id="L1415" title="All 2 branches missed.">    } else if (node instanceof SqlNodeList) {</span>
<span class="nc" id="L1416">      final SqlNodeList list = (SqlNodeList) node;</span>
<span class="nc bnc" id="L1417" title="All 2 branches missed.">      for (int i = 0; i &lt; list.size(); i++) {</span>
<span class="nc" id="L1418">        SqlNode operand = list.get(i);</span>
<span class="nc" id="L1419">        SqlNode newOperand =</span>
<span class="nc" id="L1420">            performUnconditionalRewrites(</span>
                operand,
                false);
<span class="nc bnc" id="L1423" title="All 2 branches missed.">        if (newOperand != null) {</span>
<span class="nc" id="L1424">          list.set(i, newOperand);</span>
        }
      }
    }

    // now transform node itself
<span class="nc" id="L1430">    final SqlKind kind = node.getKind();</span>
<span class="nc bnc" id="L1431" title="All 7 branches missed.">    switch (kind) {</span>
    case VALUES:
      // Do not rewrite VALUES clauses.
      // At some point we used to rewrite VALUES(...) clauses
      // to (SELECT * FROM VALUES(...)) but this was problematic
      // in various cases such as FROM (VALUES(...)) [ AS alias ]
      // where the rewrite was invoked over and over making the
      // expression grow indefinitely.
<span class="nc" id="L1439">      return node;</span>
    case ORDER_BY: {
<span class="nc" id="L1441">      SqlOrderBy orderBy = (SqlOrderBy) node;</span>
<span class="nc" id="L1442">      handleOffsetFetch(orderBy.offset, orderBy.fetch);</span>
<span class="nc bnc" id="L1443" title="All 2 branches missed.">      if (orderBy.query instanceof SqlSelect) {</span>
<span class="nc" id="L1444">        SqlSelect select = (SqlSelect) orderBy.query;</span>

        // Don't clobber existing ORDER BY.  It may be needed for
        // an order-sensitive function like RANK.
<span class="nc bnc" id="L1448" title="All 2 branches missed.">        if (select.getOrderList() == null) {</span>
          // push ORDER BY into existing select
<span class="nc" id="L1450">          select.setOrderBy(orderBy.orderList);</span>
<span class="nc" id="L1451">          select.setOffset(orderBy.offset);</span>
<span class="nc" id="L1452">          select.setFetch(orderBy.fetch);</span>
<span class="nc" id="L1453">          return select;</span>
        }
      }
<span class="nc bnc" id="L1456" title="All 4 branches missed.">      if (orderBy.query instanceof SqlWith</span>
          &amp;&amp; ((SqlWith) orderBy.query).body instanceof SqlSelect) {
<span class="nc" id="L1458">        SqlWith with = (SqlWith) orderBy.query;</span>
<span class="nc" id="L1459">        SqlSelect select = (SqlSelect) with.body;</span>

        // Don't clobber existing ORDER BY.  It may be needed for
        // an order-sensitive function like RANK.
<span class="nc bnc" id="L1463" title="All 2 branches missed.">        if (select.getOrderList() == null) {</span>
          // push ORDER BY into existing select
<span class="nc" id="L1465">          select.setOrderBy(orderBy.orderList);</span>
<span class="nc" id="L1466">          select.setOffset(orderBy.offset);</span>
<span class="nc" id="L1467">          select.setFetch(orderBy.fetch);</span>
<span class="nc" id="L1468">          return with;</span>
        }
      }
<span class="nc" id="L1471">      final SqlNodeList selectList = new SqlNodeList(SqlParserPos.ZERO);</span>
<span class="nc" id="L1472">      selectList.add(SqlIdentifier.star(SqlParserPos.ZERO));</span>
      final SqlNodeList orderList;
<span class="nc" id="L1474">      SqlSelect innerSelect = getInnerSelect(node);</span>
<span class="nc bnc" id="L1475" title="All 4 branches missed.">      if (innerSelect != null &amp;&amp; isAggregate(innerSelect)) {</span>
<span class="nc" id="L1476">        orderList = SqlNode.clone(orderBy.orderList);</span>
        // We assume that ORDER BY item does not have ASC etc.
        // We assume that ORDER BY item is present in SELECT list.
<span class="nc bnc" id="L1479" title="All 2 branches missed.">        for (int i = 0; i &lt; orderList.size(); i++) {</span>
<span class="nc" id="L1480">          SqlNode sqlNode = orderList.get(i);</span>
<span class="nc" id="L1481">          SqlNodeList selectList2 = SqlNonNullableAccessors.getSelectList(innerSelect);</span>
<span class="nc bnc" id="L1482" title="All 2 branches missed.">          for (Ord&lt;SqlNode&gt; sel : Ord.zip(selectList2)) {</span>
<span class="nc bnc" id="L1483" title="All 2 branches missed.">            if (stripAs(sel.e).equalsDeep(sqlNode, Litmus.IGNORE)) {</span>
<span class="nc" id="L1484">              orderList.set(i,</span>
<span class="nc" id="L1485">                  SqlLiteral.createExactNumeric(Integer.toString(sel.i + 1),</span>
                      SqlParserPos.ZERO));
            }
<span class="nc" id="L1488">          }</span>
        }
      } else {
<span class="nc" id="L1491">        orderList = orderBy.orderList;</span>
      }
<span class="nc" id="L1493">      return new SqlSelect(SqlParserPos.ZERO, null, selectList, orderBy.query,</span>
          null, null, null, null, null, orderList, orderBy.offset,
          orderBy.fetch, null);
    }

    case EXPLICIT_TABLE: {
      // (TABLE t) is equivalent to (SELECT * FROM t)
<span class="nc" id="L1500">      SqlCall call = (SqlCall) node;</span>
<span class="nc" id="L1501">      final SqlNodeList selectList = new SqlNodeList(SqlParserPos.ZERO);</span>
<span class="nc" id="L1502">      selectList.add(SqlIdentifier.star(SqlParserPos.ZERO));</span>
<span class="nc" id="L1503">      return new SqlSelect(SqlParserPos.ZERO, null, selectList, call.operand(0),</span>
          null, null, null, null, null, null, null, null, null);
    }

    case DELETE: {
<span class="nc" id="L1508">      SqlDelete call = (SqlDelete) node;</span>
<span class="nc" id="L1509">      SqlSelect select = createSourceSelectForDelete(call);</span>
<span class="nc" id="L1510">      call.setSourceSelect(select);</span>
<span class="nc" id="L1511">      break;</span>
    }

    case UPDATE: {
<span class="nc" id="L1515">      SqlUpdate call = (SqlUpdate) node;</span>
<span class="nc" id="L1516">      SqlSelect select = createSourceSelectForUpdate(call);</span>
<span class="nc" id="L1517">      call.setSourceSelect(select);</span>

      // See if we're supposed to rewrite UPDATE to MERGE
      // (unless this is the UPDATE clause of a MERGE,
      // in which case leave it alone).
<span class="nc bnc" id="L1522" title="All 2 branches missed.">      if (!validatingSqlMerge) {</span>
<span class="nc" id="L1523">        SqlNode selfJoinSrcExpr =</span>
<span class="nc" id="L1524">            getSelfJoinExprForUpdate(</span>
<span class="nc" id="L1525">                call.getTargetTable(),</span>
                UPDATE_SRC_ALIAS);
<span class="nc bnc" id="L1527" title="All 2 branches missed.">        if (selfJoinSrcExpr != null) {</span>
<span class="nc" id="L1528">          node = rewriteUpdateToMerge(call, selfJoinSrcExpr);</span>
        }
<span class="nc" id="L1530">      }</span>
      break;
    }

    case MERGE: {
<span class="nc" id="L1535">      SqlMerge call = (SqlMerge) node;</span>
<span class="nc" id="L1536">      rewriteMerge(call);</span>
<span class="nc" id="L1537">      break;</span>
    }
    default:
      break;
    }
<span class="nc" id="L1542">    return node;</span>
  }

  private static @Nullable SqlSelect getInnerSelect(SqlNode node) {
    for (;;) {
<span class="nc bnc" id="L1547" title="All 2 branches missed.">      if (node instanceof SqlSelect) {</span>
<span class="nc" id="L1548">        return (SqlSelect) node;</span>
<span class="nc bnc" id="L1549" title="All 2 branches missed.">      } else if (node instanceof SqlOrderBy) {</span>
<span class="nc" id="L1550">        node = ((SqlOrderBy) node).query;</span>
<span class="nc bnc" id="L1551" title="All 2 branches missed.">      } else if (node instanceof SqlWith) {</span>
<span class="nc" id="L1552">        node = ((SqlWith) node).body;</span>
      } else {
<span class="nc" id="L1554">        return null;</span>
      }
    }
  }

  private static void rewriteMerge(SqlMerge call) {
    SqlNodeList selectList;
<span class="nc" id="L1561">    SqlUpdate updateStmt = call.getUpdateCall();</span>
<span class="nc bnc" id="L1562" title="All 2 branches missed.">    if (updateStmt != null) {</span>
      // if we have an update statement, just clone the select list
      // from the update statement's source since it's the same as
      // what we want for the select list of the merge source -- '*'
      // followed by the update set expressions
<span class="nc" id="L1567">      SqlSelect sourceSelect = SqlNonNullableAccessors.getSourceSelect(updateStmt);</span>
<span class="nc" id="L1568">      selectList = SqlNode.clone(SqlNonNullableAccessors.getSelectList(sourceSelect));</span>
<span class="nc" id="L1569">    } else {</span>
      // otherwise, just use select *
<span class="nc" id="L1571">      selectList = new SqlNodeList(SqlParserPos.ZERO);</span>
<span class="nc" id="L1572">      selectList.add(SqlIdentifier.star(SqlParserPos.ZERO));</span>
    }
<span class="nc" id="L1574">    SqlNode targetTable = call.getTargetTable();</span>
<span class="nc bnc" id="L1575" title="All 2 branches missed.">    if (call.getAlias() != null) {</span>
<span class="nc" id="L1576">      targetTable =</span>
<span class="nc" id="L1577">          SqlValidatorUtil.addAlias(</span>
              targetTable,
<span class="nc" id="L1579">              call.getAlias().getSimple());</span>
    }

    // Provided there is an insert substatement, the source select for
    // the merge is a left outer join between the source in the USING
    // clause and the target table; otherwise, the join is just an
    // inner join.  Need to clone the source table reference in order
    // for validation to work
<span class="nc" id="L1587">    SqlNode sourceTableRef = call.getSourceTableRef();</span>
<span class="nc" id="L1588">    SqlInsert insertCall = call.getInsertCall();</span>
<span class="nc bnc" id="L1589" title="All 2 branches missed.">    JoinType joinType = (insertCall == null) ? JoinType.INNER : JoinType.LEFT;</span>
<span class="nc" id="L1590">    final SqlNode leftJoinTerm = SqlNode.clone(sourceTableRef);</span>
<span class="nc" id="L1591">    SqlNode outerJoin =</span>
        new SqlJoin(SqlParserPos.ZERO,
            leftJoinTerm,
<span class="nc" id="L1594">            SqlLiteral.createBoolean(false, SqlParserPos.ZERO),</span>
<span class="nc" id="L1595">            joinType.symbol(SqlParserPos.ZERO),</span>
            targetTable,
<span class="nc" id="L1597">            JoinConditionType.ON.symbol(SqlParserPos.ZERO),</span>
<span class="nc" id="L1598">            call.getCondition());</span>
<span class="nc" id="L1599">    SqlSelect select =</span>
        new SqlSelect(SqlParserPos.ZERO, null, selectList, outerJoin, null,
            null, null, null, null, null, null, null, null);
<span class="nc" id="L1602">    call.setSourceSelect(select);</span>

    // Source for the insert call is a select of the source table
    // reference with the select list being the value expressions;
    // note that the values clause has already been converted to a
    // select on the values row constructor; so we need to extract
    // that via the from clause on the select
<span class="nc bnc" id="L1609" title="All 2 branches missed.">    if (insertCall != null) {</span>
<span class="nc" id="L1610">      SqlCall valuesCall = (SqlCall) insertCall.getSource();</span>
<span class="nc" id="L1611">      SqlCall rowCall = valuesCall.operand(0);</span>
<span class="nc" id="L1612">      selectList =</span>
          new SqlNodeList(
<span class="nc" id="L1614">              rowCall.getOperandList(),</span>
              SqlParserPos.ZERO);
<span class="nc" id="L1616">      final SqlNode insertSource = SqlNode.clone(sourceTableRef);</span>
<span class="nc" id="L1617">      select =</span>
          new SqlSelect(SqlParserPos.ZERO, null, selectList, insertSource, null,
              null, null, null, null, null, null, null, null);
<span class="nc" id="L1620">      insertCall.setSource(select);</span>
    }
<span class="nc" id="L1622">  }</span>

  private SqlNode rewriteUpdateToMerge(
      SqlUpdate updateCall,
      SqlNode selfJoinSrcExpr) {
    // Make sure target has an alias.
<span class="nc" id="L1628">    SqlIdentifier updateAlias = updateCall.getAlias();</span>
<span class="nc bnc" id="L1629" title="All 2 branches missed.">    if (updateAlias == null) {</span>
<span class="nc" id="L1630">      updateAlias = new SqlIdentifier(UPDATE_TGT_ALIAS, SqlParserPos.ZERO);</span>
<span class="nc" id="L1631">      updateCall.setAlias(updateAlias);</span>
    }
<span class="nc" id="L1633">    SqlNode selfJoinTgtExpr =</span>
<span class="nc" id="L1634">        getSelfJoinExprForUpdate(</span>
<span class="nc" id="L1635">            updateCall.getTargetTable(),</span>
<span class="nc" id="L1636">            updateAlias.getSimple());</span>
<span class="nc" id="L1637">    requireNonNull(selfJoinTgtExpr, &quot;selfJoinTgtExpr&quot;);</span>

    // Create join condition between source and target exprs,
    // creating a conjunction with the user-level WHERE
    // clause if one was supplied
<span class="nc" id="L1642">    SqlNode condition = updateCall.getCondition();</span>
<span class="nc" id="L1643">    SqlNode selfJoinCond =</span>
<span class="nc" id="L1644">        SqlStdOperatorTable.EQUALS.createCall(</span>
            SqlParserPos.ZERO,
            selfJoinSrcExpr,
            selfJoinTgtExpr);
<span class="nc bnc" id="L1648" title="All 2 branches missed.">    if (condition == null) {</span>
<span class="nc" id="L1649">      condition = selfJoinCond;</span>
    } else {
<span class="nc" id="L1651">      condition =</span>
<span class="nc" id="L1652">          SqlStdOperatorTable.AND.createCall(</span>
              SqlParserPos.ZERO,
              selfJoinCond,
              condition);
    }
<span class="nc" id="L1657">    SqlNode target =</span>
<span class="nc" id="L1658">        updateCall.getTargetTable().clone(SqlParserPos.ZERO);</span>

    // For the source, we need to anonymize the fields, so
    // that for a statement like UPDATE T SET I = I + 1,
    // there's no ambiguity for the &quot;I&quot; in &quot;I + 1&quot;;
    // this is OK because the source and target have
    // identical values due to the self-join.
    // Note that we anonymize the source rather than the
    // target because downstream, the optimizer rules
    // don't want to see any projection on top of the target.
<span class="nc" id="L1668">    IdentifierNamespace ns =</span>
        new IdentifierNamespace(this, target, null,
<span class="nc" id="L1670">            castNonNull(null));</span>
<span class="nc" id="L1671">    RelDataType rowType = ns.getRowType();</span>
<span class="nc" id="L1672">    SqlNode source = updateCall.getTargetTable().clone(SqlParserPos.ZERO);</span>
<span class="nc" id="L1673">    final SqlNodeList selectList = new SqlNodeList(SqlParserPos.ZERO);</span>
<span class="nc" id="L1674">    int i = 1;</span>
<span class="nc bnc" id="L1675" title="All 2 branches missed.">    for (RelDataTypeField field : rowType.getFieldList()) {</span>
<span class="nc" id="L1676">      SqlIdentifier col =</span>
          new SqlIdentifier(
<span class="nc" id="L1678">              field.getName(),</span>
              SqlParserPos.ZERO);
<span class="nc" id="L1680">      selectList.add(</span>
<span class="nc" id="L1681">          SqlValidatorUtil.addAlias(col, UPDATE_ANON_PREFIX + i));</span>
<span class="nc" id="L1682">      ++i;</span>
<span class="nc" id="L1683">    }</span>
<span class="nc" id="L1684">    source =</span>
        new SqlSelect(SqlParserPos.ZERO, null, selectList, source, null, null,
            null, null, null, null, null, null, null);
<span class="nc" id="L1687">    source = SqlValidatorUtil.addAlias(source, UPDATE_SRC_ALIAS);</span>
<span class="nc" id="L1688">    SqlMerge mergeCall =</span>
<span class="nc" id="L1689">        new SqlMerge(updateCall.getParserPosition(), target, condition, source,</span>
<span class="nc" id="L1690">            updateCall, null, null, updateCall.getAlias());</span>
<span class="nc" id="L1691">    rewriteMerge(mergeCall);</span>
<span class="nc" id="L1692">    return mergeCall;</span>
  }

  /**
   * Allows a subclass to provide information about how to convert an UPDATE
   * into a MERGE via self-join. If this method returns null, then no such
   * conversion takes place. Otherwise, this method should return a suitable
   * unique identifier expression for the given table.
   *
   * @param table identifier for table being updated
   * @param alias alias to use for qualifying columns in expression, or null
   *              for unqualified references; if this is equal to
   *              {@value #UPDATE_SRC_ALIAS}, then column references have been
   *              anonymized to &quot;SYS$ANONx&quot;, where x is the 1-based column
   *              number.
   * @return expression for unique identifier, or null to prevent conversion
   */
  protected @Nullable SqlNode getSelfJoinExprForUpdate(
      SqlNode table,
      String alias) {
<span class="nc" id="L1712">    return null;</span>
  }

  /**
   * Creates the SELECT statement that putatively feeds rows into an UPDATE
   * statement to be updated.
   *
   * @param call Call to the UPDATE operator
   * @return select statement
   */
  protected SqlSelect createSourceSelectForUpdate(SqlUpdate call) {
<span class="nc" id="L1723">    final SqlNodeList selectList = new SqlNodeList(SqlParserPos.ZERO);</span>
<span class="nc" id="L1724">    selectList.add(SqlIdentifier.star(SqlParserPos.ZERO));</span>
<span class="nc" id="L1725">    int ordinal = 0;</span>
<span class="nc bnc" id="L1726" title="All 2 branches missed.">    for (SqlNode exp : call.getSourceExpressionList()) {</span>
      // Force unique aliases to avoid a duplicate for Y with
      // SET X=Y
<span class="nc" id="L1729">      String alias = SqlUtil.deriveAliasFromOrdinal(ordinal);</span>
<span class="nc" id="L1730">      selectList.add(SqlValidatorUtil.addAlias(exp, alias));</span>
<span class="nc" id="L1731">      ++ordinal;</span>
<span class="nc" id="L1732">    }</span>
<span class="nc" id="L1733">    SqlNode sourceTable = call.getTargetTable();</span>
<span class="nc" id="L1734">    SqlIdentifier alias = call.getAlias();</span>
<span class="nc bnc" id="L1735" title="All 2 branches missed.">    if (alias != null) {</span>
<span class="nc" id="L1736">      sourceTable =</span>
<span class="nc" id="L1737">          SqlValidatorUtil.addAlias(</span>
              sourceTable,
<span class="nc" id="L1739">              alias.getSimple());</span>
    }
<span class="nc" id="L1741">    return new SqlSelect(SqlParserPos.ZERO, null, selectList, sourceTable,</span>
<span class="nc" id="L1742">        call.getCondition(), null, null, null, null, null, null, null, null);</span>
  }

  /**
   * Creates the SELECT statement that putatively feeds rows into a DELETE
   * statement to be deleted.
   *
   * @param call Call to the DELETE operator
   * @return select statement
   */
  protected SqlSelect createSourceSelectForDelete(SqlDelete call) {
<span class="nc" id="L1753">    final SqlNodeList selectList = new SqlNodeList(SqlParserPos.ZERO);</span>
<span class="nc" id="L1754">    selectList.add(SqlIdentifier.star(SqlParserPos.ZERO));</span>
<span class="nc" id="L1755">    SqlNode sourceTable = call.getTargetTable();</span>
<span class="nc" id="L1756">    SqlIdentifier alias = call.getAlias();</span>
<span class="nc bnc" id="L1757" title="All 2 branches missed.">    if (alias != null) {</span>
<span class="nc" id="L1758">      sourceTable =</span>
<span class="nc" id="L1759">          SqlValidatorUtil.addAlias(</span>
              sourceTable,
<span class="nc" id="L1761">              alias.getSimple());</span>
    }
<span class="nc" id="L1763">    return new SqlSelect(SqlParserPos.ZERO, null, selectList, sourceTable,</span>
<span class="nc" id="L1764">        call.getCondition(), null, null, null, null, null, null, null, null);</span>
  }

  /**
   * Returns null if there is no common type. E.g. if the rows have a
   * different number of columns.
   */
  @Nullable RelDataType getTableConstructorRowType(
      SqlCall values,
      SqlValidatorScope scope) {
<span class="nc" id="L1774">    final List&lt;SqlNode&gt; rows = values.getOperandList();</span>
<span class="nc bnc" id="L1775" title="All 2 branches missed.">    assert !rows.isEmpty();</span>
<span class="nc" id="L1776">    final List&lt;RelDataType&gt; rowTypes = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1777" title="All 2 branches missed.">    for (final SqlNode row : rows) {</span>
<span class="nc bnc" id="L1778" title="All 2 branches missed.">      assert row.getKind() == SqlKind.ROW;</span>
<span class="nc" id="L1779">      SqlCall rowConstructor = (SqlCall) row;</span>

      // REVIEW jvs 10-Sept-2003: Once we support single-row queries as
      // rows, need to infer aliases from there.
<span class="nc" id="L1783">      final List&lt;String&gt; aliasList = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L1784">      final List&lt;RelDataType&gt; typeList = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1785" title="All 2 branches missed.">      for (Ord&lt;SqlNode&gt; column : Ord.zip(rowConstructor.getOperandList())) {</span>
<span class="nc" id="L1786">        final String alias = SqlValidatorUtil.alias(column.e, column.i);</span>
<span class="nc" id="L1787">        aliasList.add(alias);</span>
<span class="nc" id="L1788">        final RelDataType type = deriveType(scope, column.e);</span>
<span class="nc" id="L1789">        typeList.add(type);</span>
<span class="nc" id="L1790">      }</span>
<span class="nc" id="L1791">      rowTypes.add(typeFactory.createStructType(typeList, aliasList));</span>
<span class="nc" id="L1792">    }</span>
<span class="nc bnc" id="L1793" title="All 2 branches missed.">    if (rows.size() == 1) {</span>
      // TODO jvs 10-Oct-2005:  get rid of this workaround once
      // leastRestrictive can handle all cases
<span class="nc" id="L1796">      return rowTypes.get(0);</span>
    }
<span class="nc" id="L1798">    return typeFactory.leastRestrictive(rowTypes);</span>
  }

  @Override public RelDataType getValidatedNodeType(SqlNode node) {
<span class="nc" id="L1802">    RelDataType type = getValidatedNodeTypeIfKnown(node);</span>
<span class="nc bnc" id="L1803" title="All 2 branches missed.">    if (type == null) {</span>
<span class="nc bnc" id="L1804" title="All 2 branches missed.">      if (node.getKind() == SqlKind.IDENTIFIER) {</span>
<span class="nc" id="L1805">        throw newValidationError(node, RESOURCE.unknownIdentifier(node.toString()));</span>
      }
<span class="nc" id="L1807">      throw Util.needToImplement(node);</span>
    } else {
<span class="nc" id="L1809">      return type;</span>
    }
  }

  @Override public @Nullable RelDataType getValidatedNodeTypeIfKnown(SqlNode node) {
<span class="nc" id="L1814">    final RelDataType type = nodeToTypeMap.get(node);</span>
<span class="nc bnc" id="L1815" title="All 2 branches missed.">    if (type != null) {</span>
<span class="nc" id="L1816">      return type;</span>
    }
<span class="nc" id="L1818">    final SqlValidatorNamespace ns = getNamespace(node);</span>
<span class="nc bnc" id="L1819" title="All 2 branches missed.">    if (ns != null) {</span>
<span class="nc" id="L1820">      return ns.getType();</span>
    }
<span class="nc" id="L1822">    final SqlNode original = originalExprs.get(node);</span>
<span class="nc bnc" id="L1823" title="All 4 branches missed.">    if (original != null &amp;&amp; original != node) {</span>
<span class="nc" id="L1824">      return getValidatedNodeTypeIfKnown(original);</span>
    }
<span class="nc bnc" id="L1826" title="All 2 branches missed.">    if (node instanceof SqlIdentifier) {</span>
<span class="nc" id="L1827">      return getCatalogReader().getNamedType((SqlIdentifier) node);</span>
    }
<span class="nc" id="L1829">    return null;</span>
  }

  @Override public @Nullable List&lt;RelDataType&gt; getValidatedOperandTypes(SqlCall call) {
<span class="nc" id="L1833">    return callToOperandTypesMap.get(call);</span>
  }

  /**
   * Saves the type of a {@link SqlNode}, now that it has been validated.
   *
   * &lt;p&gt;Unlike the base class method, this method is not deprecated.
   * It is available from within Calcite, but is not part of the public API.
   *
   * @param node A SQL parse tree node, never null
   * @param type Its type; must not be null
   */
  @Override public final void setValidatedNodeType(SqlNode node, RelDataType type) {
<span class="nc" id="L1846">    requireNonNull(type, &quot;type&quot;);</span>
<span class="nc" id="L1847">    requireNonNull(node, &quot;node&quot;);</span>
<span class="nc bnc" id="L1848" title="All 2 branches missed.">    if (type.equals(unknownType)) {</span>
      // don't set anything until we know what it is, and don't overwrite
      // a known type with the unknown type
<span class="nc" id="L1851">      return;</span>
    }
<span class="nc" id="L1853">    nodeToTypeMap.put(node, type);</span>
<span class="nc" id="L1854">  }</span>

  @Override public void removeValidatedNodeType(SqlNode node) {
<span class="nc" id="L1857">    nodeToTypeMap.remove(node);</span>
<span class="nc" id="L1858">  }</span>

  @Override public @Nullable SqlCall makeNullaryCall(SqlIdentifier id) {
<span class="nc bnc" id="L1861" title="All 4 branches missed.">    if (id.names.size() == 1 &amp;&amp; !id.isComponentQuoted(0)) {</span>
<span class="nc" id="L1862">      final List&lt;SqlOperator&gt; list = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L1863">      opTab.lookupOperatorOverloads(id, null, SqlSyntax.FUNCTION, list,</span>
<span class="nc" id="L1864">          catalogReader.nameMatcher());</span>
<span class="nc bnc" id="L1865" title="All 2 branches missed.">      for (SqlOperator operator : list) {</span>
<span class="nc bnc" id="L1866" title="All 2 branches missed.">        if (operator.getSyntax() == SqlSyntax.FUNCTION_ID) {</span>
          // Even though this looks like an identifier, it is a
          // actually a call to a function. Construct a fake
          // call to this function, so we can use the regular
          // operator validation.
<span class="nc" id="L1871">          return new SqlBasicCall(operator, ImmutableList.of(),</span>
<span class="nc" id="L1872">              id.getParserPosition(), null).withExpanded(true);</span>
        }
<span class="nc" id="L1874">      }</span>
    }
<span class="nc" id="L1876">    return null;</span>
  }

  @Override public RelDataType deriveType(
      SqlValidatorScope scope,
      SqlNode expr) {
<span class="nc" id="L1882">    requireNonNull(scope, &quot;scope&quot;);</span>
<span class="nc" id="L1883">    requireNonNull(expr, &quot;expr&quot;);</span>

    // if we already know the type, no need to re-derive
<span class="nc" id="L1886">    RelDataType type = nodeToTypeMap.get(expr);</span>
<span class="nc bnc" id="L1887" title="All 2 branches missed.">    if (type != null) {</span>
<span class="nc" id="L1888">      return type;</span>
    }
<span class="nc" id="L1890">    final SqlValidatorNamespace ns = getNamespace(expr);</span>
<span class="nc bnc" id="L1891" title="All 2 branches missed.">    if (ns != null) {</span>
<span class="nc" id="L1892">      return ns.getType();</span>
    }
<span class="nc" id="L1894">    type = deriveTypeImpl(scope, expr);</span>
<span class="nc" id="L1895">    requireNonNull(type, &quot;SqlValidator.deriveTypeInternal returned null&quot;);</span>
<span class="nc" id="L1896">    setValidatedNodeType(expr, type);</span>
<span class="nc" id="L1897">    return type;</span>
  }

  /**
   * Derives the type of a node, never null.
   */
  RelDataType deriveTypeImpl(
      SqlValidatorScope scope,
      SqlNode operand) {
<span class="nc" id="L1906">    DeriveTypeVisitor v = new DeriveTypeVisitor(scope);</span>
<span class="nc" id="L1907">    final RelDataType type = operand.accept(v);</span>
<span class="nc" id="L1908">    return requireNonNull(scope.nullifyType(operand, type));</span>
  }

  @Override public RelDataType deriveConstructorType(
      SqlValidatorScope scope,
      SqlCall call,
      SqlFunction unresolvedConstructor,
      @Nullable SqlFunction resolvedConstructor,
      List&lt;RelDataType&gt; argTypes) {
<span class="nc" id="L1917">    SqlIdentifier sqlIdentifier = unresolvedConstructor.getSqlIdentifier();</span>
<span class="nc" id="L1918">    requireNonNull(sqlIdentifier, &quot;sqlIdentifier&quot;);</span>
<span class="nc" id="L1919">    RelDataType type = catalogReader.getNamedType(sqlIdentifier);</span>
<span class="nc bnc" id="L1920" title="All 2 branches missed.">    if (type == null) {</span>
      // TODO jvs 12-Feb-2005:  proper type name formatting
<span class="nc" id="L1922">      throw newValidationError(sqlIdentifier,</span>
<span class="nc" id="L1923">          RESOURCE.unknownDatatypeName(sqlIdentifier.toString()));</span>
    }

<span class="nc bnc" id="L1926" title="All 2 branches missed.">    if (resolvedConstructor == null) {</span>
<span class="nc bnc" id="L1927" title="All 2 branches missed.">      if (call.operandCount() &gt; 0) {</span>
        // This is not a default constructor invocation, and
        // no user-defined constructor could be found
<span class="nc" id="L1930">        throw handleUnresolvedFunction(call, unresolvedConstructor, argTypes,</span>
            null);
      }
    } else {
<span class="nc" id="L1934">      SqlCall testCall =</span>
<span class="nc" id="L1935">          resolvedConstructor.createCall(</span>
<span class="nc" id="L1936">              call.getParserPosition(),</span>
<span class="nc" id="L1937">              call.getOperandList());</span>
<span class="nc" id="L1938">      RelDataType returnType =</span>
<span class="nc" id="L1939">          resolvedConstructor.validateOperands(</span>
              this,
              scope,
              testCall);
<span class="nc bnc" id="L1943" title="All 2 branches missed.">      assert type == returnType;</span>
    }

<span class="nc bnc" id="L1946" title="All 2 branches missed.">    if (config.identifierExpansion()) {</span>
<span class="nc bnc" id="L1947" title="All 2 branches missed.">      if (resolvedConstructor != null) {</span>
<span class="nc" id="L1948">        ((SqlBasicCall) call).setOperator(resolvedConstructor);</span>
      } else {
        // fake a fully-qualified call to the default constructor
<span class="nc" id="L1951">        ((SqlBasicCall) call).setOperator(</span>
            new SqlFunction(
<span class="nc" id="L1953">                requireNonNull(type.getSqlIdentifier(), () -&gt; &quot;sqlIdentifier of &quot; + type),</span>
<span class="nc" id="L1954">                ReturnTypes.explicit(type),</span>
                null,
                null,
                null,
                SqlFunctionCategory.USER_DEFINED_CONSTRUCTOR));
      }
    }
<span class="nc" id="L1961">    return type;</span>
  }

  @Override public CalciteException handleUnresolvedFunction(SqlCall call,
      SqlOperator unresolvedFunction, List&lt;RelDataType&gt; argTypes,
      @Nullable List&lt;String&gt; argNames) {
    // For builtins, we can give a better error message
<span class="nc" id="L1968">    final List&lt;SqlOperator&gt; overloads = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L1969">    opTab.lookupOperatorOverloads(unresolvedFunction.getNameAsId(), null,</span>
<span class="nc" id="L1970">        SqlSyntax.FUNCTION, overloads, catalogReader.nameMatcher());</span>
<span class="nc bnc" id="L1971" title="All 2 branches missed.">    if (overloads.size() == 1) {</span>
<span class="nc" id="L1972">      SqlFunction fun = (SqlFunction) overloads.get(0);</span>
<span class="nc bnc" id="L1973" title="All 2 branches missed.">      if ((fun.getSqlIdentifier() == null)</span>
<span class="nc bnc" id="L1974" title="All 2 branches missed.">          &amp;&amp; (fun.getSyntax() != SqlSyntax.FUNCTION_ID)) {</span>
<span class="nc" id="L1975">        final int expectedArgCount =</span>
<span class="nc" id="L1976">            fun.getOperandCountRange().getMin();</span>
<span class="nc" id="L1977">        throw newValidationError(call,</span>
<span class="nc" id="L1978">            RESOURCE.invalidArgCount(call.getOperator().getName(),</span>
                expectedArgCount));
      }
    }

    final String signature;
<span class="nc bnc" id="L1984" title="All 2 branches missed.">    if (unresolvedFunction instanceof SqlFunction) {</span>
<span class="nc" id="L1985">      final SqlOperandTypeChecker typeChecking =</span>
          new AssignableOperandTypeChecker(argTypes, argNames);
<span class="nc" id="L1987">      signature =</span>
<span class="nc" id="L1988">          typeChecking.getAllowedSignatures(unresolvedFunction,</span>
<span class="nc" id="L1989">              unresolvedFunction.getName());</span>
<span class="nc" id="L1990">    } else {</span>
<span class="nc" id="L1991">      signature = unresolvedFunction.getName();</span>
    }
<span class="nc" id="L1993">    throw newValidationError(call,</span>
<span class="nc" id="L1994">        RESOURCE.validatorUnknownFunction(signature));</span>
  }

  protected void inferUnknownTypes(
      RelDataType inferredType,
      SqlValidatorScope scope,
      SqlNode node) {
<span class="nc" id="L2001">    requireNonNull(inferredType, &quot;inferredType&quot;);</span>
<span class="nc" id="L2002">    requireNonNull(scope, &quot;scope&quot;);</span>
<span class="nc" id="L2003">    requireNonNull(node, &quot;node&quot;);</span>
<span class="nc" id="L2004">    final SqlValidatorScope newScope = scopes.get(node);</span>
<span class="nc bnc" id="L2005" title="All 2 branches missed.">    if (newScope != null) {</span>
<span class="nc" id="L2006">      scope = newScope;</span>
    }
<span class="nc" id="L2008">    boolean isNullLiteral = SqlUtil.isNullLiteral(node, false);</span>
<span class="nc bnc" id="L2009" title="All 4 branches missed.">    if ((node instanceof SqlDynamicParam) || isNullLiteral) {</span>
<span class="nc bnc" id="L2010" title="All 2 branches missed.">      if (inferredType.equals(unknownType)) {</span>
<span class="nc bnc" id="L2011" title="All 2 branches missed.">        if (isNullLiteral) {</span>
<span class="nc bnc" id="L2012" title="All 2 branches missed.">          if (config.typeCoercionEnabled()) {</span>
            // derive type of null literal
<span class="nc" id="L2014">            deriveType(scope, node);</span>
<span class="nc" id="L2015">            return;</span>
          } else {
<span class="nc" id="L2017">            throw newValidationError(node, RESOURCE.nullIllegal());</span>
          }
        } else {
<span class="nc" id="L2020">          throw newValidationError(node, RESOURCE.dynamicParamIllegal());</span>
        }
      }

      // REVIEW:  should dynamic parameter types always be nullable?
<span class="nc" id="L2025">      RelDataType newInferredType =</span>
<span class="nc" id="L2026">          typeFactory.createTypeWithNullability(inferredType, true);</span>
<span class="nc bnc" id="L2027" title="All 2 branches missed.">      if (SqlTypeUtil.inCharFamily(inferredType)) {</span>
<span class="nc" id="L2028">        newInferredType =</span>
<span class="nc" id="L2029">            typeFactory.createTypeWithCharsetAndCollation(</span>
                newInferredType,
<span class="nc" id="L2031">                getCharset(inferredType),</span>
<span class="nc" id="L2032">                getCollation(inferredType));</span>
      }
<span class="nc" id="L2034">      setValidatedNodeType(node, newInferredType);</span>
<span class="nc bnc" id="L2035" title="All 2 branches missed.">    } else if (node instanceof SqlNodeList) {</span>
<span class="nc" id="L2036">      SqlNodeList nodeList = (SqlNodeList) node;</span>
<span class="nc bnc" id="L2037" title="All 2 branches missed.">      if (inferredType.isStruct()) {</span>
<span class="nc bnc" id="L2038" title="All 2 branches missed.">        if (inferredType.getFieldCount() != nodeList.size()) {</span>
          // this can happen when we're validating an INSERT
          // where the source and target degrees are different;
          // bust out, and the error will be detected higher up
<span class="nc" id="L2042">          return;</span>
        }
      }
<span class="nc" id="L2045">      int i = 0;</span>
<span class="nc bnc" id="L2046" title="All 2 branches missed.">      for (SqlNode child : nodeList) {</span>
        RelDataType type;
<span class="nc bnc" id="L2048" title="All 2 branches missed.">        if (inferredType.isStruct()) {</span>
<span class="nc" id="L2049">          type = inferredType.getFieldList().get(i).getType();</span>
<span class="nc" id="L2050">          ++i;</span>
        } else {
<span class="nc" id="L2052">          type = inferredType;</span>
        }
<span class="nc" id="L2054">        inferUnknownTypes(type, scope, child);</span>
<span class="nc" id="L2055">      }</span>
<span class="nc bnc" id="L2056" title="All 2 branches missed.">    } else if (node instanceof SqlCase) {</span>
<span class="nc" id="L2057">      final SqlCase caseCall = (SqlCase) node;</span>

      final RelDataType whenType =
<span class="nc bnc" id="L2060" title="All 2 branches missed.">          caseCall.getValueOperand() == null ? booleanType : unknownType;</span>
<span class="nc bnc" id="L2061" title="All 2 branches missed.">      for (SqlNode sqlNode : caseCall.getWhenOperands()) {</span>
<span class="nc" id="L2062">        inferUnknownTypes(whenType, scope, sqlNode);</span>
<span class="nc" id="L2063">      }</span>
<span class="nc" id="L2064">      RelDataType returnType = deriveType(scope, node);</span>
<span class="nc bnc" id="L2065" title="All 2 branches missed.">      for (SqlNode sqlNode : caseCall.getThenOperands()) {</span>
<span class="nc" id="L2066">        inferUnknownTypes(returnType, scope, sqlNode);</span>
<span class="nc" id="L2067">      }</span>

<span class="nc" id="L2069">      SqlNode elseOperand =</span>
<span class="nc" id="L2070">          requireNonNull(caseCall.getElseOperand(),</span>
<span class="nc" id="L2071">              () -&gt; &quot;elseOperand for &quot; + caseCall);</span>
<span class="nc bnc" id="L2072" title="All 2 branches missed.">      if (!SqlUtil.isNullLiteral(elseOperand, false)) {</span>
<span class="nc" id="L2073">        inferUnknownTypes(</span>
            returnType,
            scope,
            elseOperand);
      } else {
<span class="nc" id="L2078">        setValidatedNodeType(elseOperand, returnType);</span>
      }
<span class="nc bnc" id="L2080" title="All 2 branches missed.">    } else if (node.getKind()  == SqlKind.AS) {</span>
      // For AS operator, only infer the operand not the alias
<span class="nc" id="L2082">      inferUnknownTypes(inferredType, scope, ((SqlCall) node).operand(0));</span>
<span class="nc bnc" id="L2083" title="All 2 branches missed.">    } else if (node.getKind() == SqlKind.MEASURE) {</span>
      // For MEASURE operator, use the measure scope (which has additional
      // aliases available)
<span class="nc bnc" id="L2086" title="All 2 branches missed.">      if (scope instanceof SelectScope) {</span>
<span class="nc" id="L2087">        scope = getMeasureScope(((SelectScope) scope).getNode());</span>
      }
<span class="nc" id="L2089">      inferUnknownTypes(inferredType, scope, ((SqlCall) node).operand(0));</span>
<span class="nc bnc" id="L2090" title="All 2 branches missed.">    } else if (node instanceof SqlCall) {</span>
<span class="nc" id="L2091">      final SqlCall call = (SqlCall) node;</span>
<span class="nc" id="L2092">      final SqlOperandTypeInference operandTypeInference =</span>
<span class="nc" id="L2093">          call.getOperator().getOperandTypeInference();</span>
<span class="nc" id="L2094">      final SqlCallBinding callBinding = new SqlCallBinding(this, scope, call);</span>
<span class="nc" id="L2095">      final List&lt;SqlNode&gt; operands = callBinding.operands();</span>
<span class="nc" id="L2096">      final RelDataType[] operandTypes = new RelDataType[operands.size()];</span>
<span class="nc" id="L2097">      Arrays.fill(operandTypes, unknownType);</span>
      // TODO:  eventually should assert(operandTypeInference != null)
      // instead; for now just eat it
<span class="nc bnc" id="L2100" title="All 2 branches missed.">      if (operandTypeInference != null) {</span>
<span class="nc" id="L2101">        operandTypeInference.inferOperandTypes(</span>
            callBinding,
            inferredType,
            operandTypes);
      }
<span class="nc bnc" id="L2106" title="All 2 branches missed.">      for (int i = 0; i &lt; operands.size(); ++i) {</span>
<span class="nc" id="L2107">        final SqlNode operand = operands.get(i);</span>
<span class="nc bnc" id="L2108" title="All 2 branches missed.">        if (operand != null) {</span>
<span class="nc" id="L2109">          inferUnknownTypes(operandTypes[i], scope, operand);</span>
        }
      }
    }
<span class="nc" id="L2113">  }</span>

  /**
   * Adds an expression to a select list, ensuring that its alias does not
   * clash with any existing expressions on the list.
   */
  protected void addToSelectList(
      List&lt;SqlNode&gt; list,
      Set&lt;String&gt; aliases,
      List&lt;Map.Entry&lt;String, RelDataType&gt;&gt; fieldList,
      SqlNode exp,
      SelectScope scope,
      final boolean includeSystemVars) {
<span class="nc" id="L2126">    final @Nullable String alias = SqlValidatorUtil.alias(exp);</span>
<span class="nc" id="L2127">    String uniqueAlias =</span>
<span class="nc" id="L2128">        SqlValidatorUtil.uniquify(</span>
            alias, aliases, SqlValidatorUtil.EXPR_SUGGESTER);
<span class="nc bnc" id="L2130" title="All 2 branches missed.">    if (!Objects.equals(alias, uniqueAlias)) {</span>
<span class="nc" id="L2131">      exp = SqlValidatorUtil.addAlias(exp, uniqueAlias);</span>
    }
<span class="nc" id="L2133">    ((PairList&lt;String, RelDataType&gt;) fieldList)</span>
<span class="nc" id="L2134">        .add(uniqueAlias, deriveType(scope, exp));</span>
<span class="nc" id="L2135">    list.add(exp);</span>
<span class="nc" id="L2136">  }</span>

  @Override public @Nullable String deriveAlias(
      SqlNode node,
      int ordinal) {
<span class="nc bnc" id="L2141" title="All 2 branches missed.">    return ordinal &lt; 0 ? SqlValidatorUtil.alias(node)</span>
<span class="nc" id="L2142">        : SqlValidatorUtil.alias(node, ordinal);</span>
  }

  protected boolean shouldAllowIntermediateOrderBy() {
<span class="nc" id="L2146">    return true;</span>
  }

  private void registerMatchRecognize(
      SqlValidatorScope parentScope,
      SqlValidatorScope usingScope,
      SqlMatchRecognize call,
      SqlNode enclosingNode,
      @Nullable String alias,
      boolean forceNullable) {

<span class="nc" id="L2157">    final MatchRecognizeNamespace matchRecognizeNamespace =</span>
<span class="nc" id="L2158">        createMatchRecognizeNameSpace(call, enclosingNode);</span>
<span class="nc" id="L2159">    registerNamespace(usingScope, alias, matchRecognizeNamespace, forceNullable);</span>

<span class="nc" id="L2161">    final MatchRecognizeScope matchRecognizeScope =</span>
        new MatchRecognizeScope(parentScope, call);
<span class="nc" id="L2163">    scopes.put(call, matchRecognizeScope);</span>

    // parse input query
<span class="nc" id="L2166">    SqlNode expr = call.getTableRef();</span>
<span class="nc" id="L2167">    SqlNode newExpr =</span>
<span class="nc" id="L2168">        registerFrom(usingScope, matchRecognizeScope, true, expr,</span>
            expr, null, null, forceNullable, false);
<span class="nc bnc" id="L2170" title="All 2 branches missed.">    if (expr != newExpr) {</span>
<span class="nc" id="L2171">      call.setOperand(0, newExpr);</span>
    }
<span class="nc" id="L2173">  }</span>

  protected MatchRecognizeNamespace createMatchRecognizeNameSpace(
      SqlMatchRecognize call,
      SqlNode enclosingNode) {
<span class="nc" id="L2178">    return new MatchRecognizeNamespace(this, call, enclosingNode);</span>
  }

  private void registerPivot(
      SqlValidatorScope parentScope,
      SqlValidatorScope usingScope,
      SqlPivot pivot,
      SqlNode enclosingNode,
      @Nullable String alias,
      boolean forceNullable) {
<span class="nc" id="L2188">    final PivotNamespace namespace =</span>
<span class="nc" id="L2189">        createPivotNameSpace(pivot, enclosingNode);</span>
<span class="nc" id="L2190">    registerNamespace(usingScope, alias, namespace, forceNullable);</span>

<span class="nc" id="L2192">    final SqlValidatorScope scope =</span>
        new PivotScope(parentScope, pivot);
<span class="nc" id="L2194">    scopes.put(pivot, scope);</span>

    // parse input query
<span class="nc" id="L2197">    SqlNode expr = pivot.query;</span>
<span class="nc" id="L2198">    SqlNode newExpr =</span>
<span class="nc" id="L2199">        registerFrom(parentScope, scope, true, expr,</span>
            expr, null, null, forceNullable, false);
<span class="nc bnc" id="L2201" title="All 2 branches missed.">    if (expr != newExpr) {</span>
<span class="nc" id="L2202">      pivot.setOperand(0, newExpr);</span>
    }
<span class="nc" id="L2204">  }</span>

  protected PivotNamespace createPivotNameSpace(SqlPivot call,
      SqlNode enclosingNode) {
<span class="nc" id="L2208">    return new PivotNamespace(this, call, enclosingNode);</span>
  }

  private void registerUnpivot(
      SqlValidatorScope parentScope,
      SqlValidatorScope usingScope,
      SqlUnpivot call,
      SqlNode enclosingNode,
      @Nullable String alias,
      boolean forceNullable) {
<span class="nc" id="L2218">    final UnpivotNamespace namespace =</span>
<span class="nc" id="L2219">        createUnpivotNameSpace(call, enclosingNode);</span>
<span class="nc" id="L2220">    registerNamespace(usingScope, alias, namespace, forceNullable);</span>

<span class="nc" id="L2222">    final SqlValidatorScope scope =</span>
        new UnpivotScope(parentScope, call);
<span class="nc" id="L2224">    scopes.put(call, scope);</span>

    // parse input query
<span class="nc" id="L2227">    SqlNode expr = call.query;</span>
<span class="nc" id="L2228">    SqlNode newExpr =</span>
<span class="nc" id="L2229">        registerFrom(parentScope, scope, true, expr,</span>
            expr, null, null, forceNullable, false);
<span class="nc bnc" id="L2231" title="All 2 branches missed.">    if (expr != newExpr) {</span>
<span class="nc" id="L2232">      call.setOperand(0, newExpr);</span>
    }
<span class="nc" id="L2234">  }</span>

  protected UnpivotNamespace createUnpivotNameSpace(SqlUnpivot call,
      SqlNode enclosingNode) {
<span class="nc" id="L2238">    return new UnpivotNamespace(this, call, enclosingNode);</span>
  }

  /**
   * Registers a new namespace, and adds it as a child of its parent scope.
   * Derived class can override this method to tinker with namespaces as they
   * are created.
   *
   * @param usingScope    Parent scope (which will want to look for things in
   *                      this namespace)
   * @param alias         Alias by which parent will refer to this namespace
   * @param ns            Namespace
   * @param forceNullable Whether to force the type of namespace to be nullable
   */
  protected void registerNamespace(
      @Nullable SqlValidatorScope usingScope,
      @Nullable String alias,
      SqlValidatorNamespace ns,
      boolean forceNullable) {
<span class="nc" id="L2257">    SqlValidatorNamespace namespace =</span>
<span class="nc" id="L2258">        namespaces.get(requireNonNull(ns.getNode(), () -&gt; &quot;ns.getNode() for &quot; + ns));</span>
<span class="nc bnc" id="L2259" title="All 2 branches missed.">    if (namespace == null) {</span>
<span class="nc" id="L2260">      namespaces.put(requireNonNull(ns.getNode()), ns);</span>
<span class="nc" id="L2261">      namespace = ns;</span>
    }
<span class="nc bnc" id="L2263" title="All 2 branches missed.">    if (usingScope != null) {</span>
<span class="nc bnc" id="L2264" title="All 2 branches missed.">      if (alias == null) {</span>
<span class="nc" id="L2265">        throw new IllegalArgumentException(&quot;Registering namespace &quot; + ns</span>
            + &quot;, into scope &quot; + usingScope + &quot;, so alias must not be null&quot;);
      }
<span class="nc" id="L2268">      usingScope.addChild(namespace, alias, forceNullable);</span>
    }
<span class="nc" id="L2270">  }</span>

  /**
   * Registers scopes and namespaces implied a relational expression in the
   * FROM clause.
   *
   * &lt;p&gt;{@code parentScope0} and {@code usingScope} are often the same. They
   * differ when the namespace are not visible within the parent. (Example
   * needed.)
   *
   * &lt;p&gt;Likewise, {@code enclosingNode} and {@code node} are often the same.
   * {@code enclosingNode} is the topmost node within the FROM clause, from
   * which any decorations like an alias (&lt;code&gt;AS alias&lt;/code&gt;) or a table
   * sample clause are stripped away to get {@code node}. Both are recorded in
   * the namespace.
   *
   * @param parentScope0  Parent scope that this scope turns to in order to
   *                      resolve objects
   * @param usingScope    Scope whose child list this scope should add itself to
   * @param register      Whether to register this scope as a child of
   *                      {@code usingScope}
   * @param node          Node which namespace is based on
   * @param enclosingNode Outermost node for namespace, including decorations
   *                      such as alias and sample clause
   * @param alias         Alias
   * @param extendList    Definitions of extended columns
   * @param forceNullable Whether to force the type of namespace to be
   *                      nullable because it is in an outer join
   * @param lateral       Whether LATERAL is specified, so that items to the
   *                      left of this in the JOIN tree are visible in the
   *                      scope
   * @return registered node, usually the same as {@code node}
   */
  // CHECKSTYLE: OFF
  // CheckStyle thinks this method is too long
  private SqlNode registerFrom(
      SqlValidatorScope parentScope0,
      SqlValidatorScope usingScope,
      boolean register,
      final SqlNode node,
      SqlNode enclosingNode,
      @Nullable String alias,
      @Nullable SqlNodeList extendList,
      boolean forceNullable,
      final boolean lateral) {
<span class="nc" id="L2315">    final SqlKind kind = node.getKind();</span>

    SqlNode expr;
    SqlNode newExpr;

    // Add an alias if necessary.
<span class="nc" id="L2321">    SqlNode newNode = node;</span>
<span class="nc bnc" id="L2322" title="All 2 branches missed.">    if (alias == null) {</span>
<span class="nc bnc" id="L2323" title="All 3 branches missed.">      switch (kind) {</span>
      case IDENTIFIER:
      case OVER:
<span class="nc" id="L2326">        alias = SqlValidatorUtil.alias(node);</span>
<span class="nc bnc" id="L2327" title="All 2 branches missed.">        if (alias == null) {</span>
<span class="nc" id="L2328">          alias = SqlValidatorUtil.alias(node, nextGeneratedId++);</span>
        }
<span class="nc bnc" id="L2330" title="All 2 branches missed.">        if (config.identifierExpansion()) {</span>
<span class="nc" id="L2331">          newNode = SqlValidatorUtil.addAlias(node, alias);</span>
        }
        break;

      case SELECT:
      case UNION:
      case INTERSECT:
      case EXCEPT:
      case VALUES:
      case UNNEST:
      case OTHER_FUNCTION:
      case COLLECTION_TABLE:
      case PIVOT:
      case UNPIVOT:
      case MATCH_RECOGNIZE:
      case WITH:
        // give this anonymous construct a name since later
        // query processing stages rely on it
<span class="nc" id="L2349">        alias = SqlValidatorUtil.alias(node, nextGeneratedId++);</span>
<span class="nc bnc" id="L2350" title="All 2 branches missed.">        if (config.identifierExpansion()) {</span>
          // Since we're expanding identifiers, we should make the
          // aliases explicit too, otherwise the expanded query
          // will not be consistent if we convert back to SQL, e.g.
          // &quot;select EXPR$1.EXPR$2 from values (1)&quot;.
<span class="nc" id="L2355">          newNode = SqlValidatorUtil.addAlias(node, alias);</span>
        }
        break;
      default:
        break;
      }
    }

    final SqlValidatorScope parentScope;
<span class="nc bnc" id="L2364" title="All 2 branches missed.">    if (lateral) {</span>
<span class="nc" id="L2365">      SqlValidatorScope s = usingScope;</span>
<span class="nc bnc" id="L2366" title="All 2 branches missed.">      while (s instanceof JoinScope) {</span>
<span class="nc" id="L2367">        s = ((JoinScope) s).getUsingScope();</span>
      }
<span class="nc bnc" id="L2369" title="All 2 branches missed.">      final SqlNode node2 = s != null ? s.getNode() : node;</span>
<span class="nc" id="L2370">      final TableScope tableScope = new TableScope(parentScope0, node2);</span>
<span class="nc bnc" id="L2371" title="All 2 branches missed.">      if (usingScope instanceof ListScope) {</span>
<span class="nc bnc" id="L2372" title="All 2 branches missed.">        for (ScopeChild child : ((ListScope) usingScope).children) {</span>
<span class="nc" id="L2373">          tableScope.addChild(child.namespace, child.name, child.nullable);</span>
<span class="nc" id="L2374">        }</span>
      }
<span class="nc" id="L2376">      parentScope = tableScope;</span>
<span class="nc" id="L2377">    } else {</span>
<span class="nc" id="L2378">      parentScope = parentScope0;</span>
    }

    SqlCall call;
    SqlNode operand;
    SqlNode newOperand;

<span class="nc bnc" id="L2385" title="All 16 branches missed.">    switch (kind) {</span>
    case AS:
<span class="nc" id="L2387">      call = (SqlCall) node;</span>
<span class="nc bnc" id="L2388" title="All 2 branches missed.">      if (alias == null) {</span>
<span class="nc" id="L2389">        alias = String.valueOf(call.operand(1));</span>
      }
<span class="nc" id="L2391">      expr = call.operand(0);</span>
<span class="nc bnc" id="L2392" title="All 2 branches missed.">      final boolean needAliasNamespace = call.operandCount() &gt; 2</span>
<span class="nc bnc" id="L2393" title="All 4 branches missed.">          || expr.getKind() == SqlKind.VALUES || expr.getKind() == SqlKind.UNNEST</span>
<span class="nc bnc" id="L2394" title="All 2 branches missed.">          || expr.getKind() == SqlKind.COLLECTION_TABLE;</span>
<span class="nc bnc" id="L2395" title="All 2 branches missed.">      newExpr =</span>
<span class="nc" id="L2396">          registerFrom(</span>
              parentScope,
              usingScope,
              !needAliasNamespace,
              expr,
              enclosingNode,
              alias,
              extendList,
              forceNullable,
              lateral);
<span class="nc bnc" id="L2406" title="All 2 branches missed.">      if (newExpr != expr) {</span>
<span class="nc" id="L2407">        call.setOperand(0, newExpr);</span>
      }

      // If alias has a column list, introduce a namespace to translate
      // column names. We skipped registering it just now.
<span class="nc bnc" id="L2412" title="All 2 branches missed.">      if (needAliasNamespace) {</span>
<span class="nc" id="L2413">        registerNamespace(</span>
            usingScope,
            alias,
            new AliasNamespace(this, call, enclosingNode),
            forceNullable);
      }
<span class="nc" id="L2419">      return node;</span>

    case MATCH_RECOGNIZE:
<span class="nc" id="L2422">      registerMatchRecognize(parentScope, usingScope,</span>
          (SqlMatchRecognize) node, enclosingNode, alias, forceNullable);
<span class="nc" id="L2424">      return node;</span>

    case PIVOT:
<span class="nc" id="L2427">      registerPivot(parentScope, usingScope, (SqlPivot) node, enclosingNode,</span>
          alias, forceNullable);
<span class="nc" id="L2429">      return node;</span>

    case UNPIVOT:
<span class="nc" id="L2432">      registerUnpivot(parentScope, usingScope, (SqlUnpivot) node, enclosingNode,</span>
          alias, forceNullable);
<span class="nc" id="L2434">      return node;</span>

    case TABLESAMPLE:
<span class="nc" id="L2437">      call = (SqlCall) node;</span>
<span class="nc" id="L2438">      expr = call.operand(0);</span>
<span class="nc" id="L2439">      newExpr =</span>
<span class="nc" id="L2440">          registerFrom(</span>
              parentScope,
              usingScope,
              true,
              expr,
              enclosingNode,
              alias,
              extendList,
              forceNullable,
              lateral);
<span class="nc bnc" id="L2450" title="All 2 branches missed.">      if (newExpr != expr) {</span>
<span class="nc" id="L2451">        call.setOperand(0, newExpr);</span>
      }
<span class="nc" id="L2453">      return node;</span>

    case JOIN:
<span class="nc" id="L2456">      final SqlJoin join = (SqlJoin) node;</span>
<span class="nc" id="L2457">      final JoinScope joinScope =</span>
          new JoinScope(parentScope, usingScope, join);
<span class="nc" id="L2459">      scopes.put(join, joinScope);</span>
<span class="nc" id="L2460">      final SqlNode left = join.getLeft();</span>
<span class="nc" id="L2461">      final SqlNode right = join.getRight();</span>
<span class="nc" id="L2462">      boolean forceLeftNullable = forceNullable;</span>
<span class="nc" id="L2463">      boolean forceRightNullable = forceNullable;</span>
<span class="nc bnc" id="L2464" title="All 4 branches missed.">      switch (join.getJoinType()) {</span>
      case LEFT:
      case LEFT_ASOF:
<span class="nc" id="L2467">        forceRightNullable = true;</span>
<span class="nc" id="L2468">        break;</span>
      case RIGHT:
<span class="nc" id="L2470">        forceLeftNullable = true;</span>
<span class="nc" id="L2471">        break;</span>
      case FULL:
<span class="nc" id="L2473">        forceLeftNullable = true;</span>
<span class="nc" id="L2474">        forceRightNullable = true;</span>
<span class="nc" id="L2475">        break;</span>
      default:
        break;
      }
<span class="nc" id="L2479">      final SqlNode newLeft =</span>
<span class="nc" id="L2480">          registerFrom(</span>
              parentScope,
              joinScope,
              true,
              left,
              left,
              null,
              null,
              forceLeftNullable,
              lateral);
<span class="nc bnc" id="L2490" title="All 2 branches missed.">      if (newLeft != left) {</span>
<span class="nc" id="L2491">        join.setLeft(newLeft);</span>
      }
<span class="nc" id="L2493">      final SqlNode newRight =</span>
<span class="nc" id="L2494">          registerFrom(</span>
              parentScope,
              joinScope,
              true,
              right,
              right,
              null,
              null,
              forceRightNullable,
              lateral);
<span class="nc bnc" id="L2504" title="All 2 branches missed.">      if (newRight != right) {</span>
<span class="nc" id="L2505">        join.setRight(newRight);</span>
      }
<span class="nc" id="L2507">      scopes.putIfAbsent(stripAs(join.getRight()), parentScope);</span>
<span class="nc" id="L2508">      scopes.putIfAbsent(stripAs(join.getLeft()), parentScope);</span>
<span class="nc" id="L2509">      registerSubQueries(joinScope, join.getCondition());</span>
<span class="nc" id="L2510">      final JoinNamespace joinNamespace = new JoinNamespace(this, join);</span>
<span class="nc" id="L2511">      registerNamespace(null, null, joinNamespace, forceNullable);</span>
<span class="nc" id="L2512">      return join;</span>

    case IDENTIFIER:
<span class="nc" id="L2515">      final SqlIdentifier id = (SqlIdentifier) node;</span>
<span class="nc" id="L2516">      final IdentifierNamespace newNs =</span>
          new IdentifierNamespace(
              this, id, extendList, enclosingNode,
              parentScope);
<span class="nc bnc" id="L2520" title="All 2 branches missed.">      registerNamespace(register ? usingScope : null, alias, newNs,</span>
          forceNullable);
<span class="nc bnc" id="L2522" title="All 2 branches missed.">      if (tableScope == null) {</span>
<span class="nc" id="L2523">        tableScope = new TableScope(parentScope, node);</span>
      }
<span class="nc" id="L2525">      tableScope.addChild(newNs, requireNonNull(alias, &quot;alias&quot;), forceNullable);</span>
<span class="nc bnc" id="L2526" title="All 4 branches missed.">      if (extendList != null &amp;&amp; !extendList.isEmpty()) {</span>
<span class="nc" id="L2527">        return enclosingNode;</span>
      }
<span class="nc" id="L2529">      return newNode;</span>

    case LATERAL:
<span class="nc" id="L2532">      return registerFrom(</span>
          parentScope,
          usingScope,
          register,
<span class="nc" id="L2536">          ((SqlCall) node).operand(0),</span>
          enclosingNode,
          alias,
          extendList,
          forceNullable,
          true);

    case COLLECTION_TABLE:
<span class="nc" id="L2544">      call = (SqlCall) node;</span>
<span class="nc" id="L2545">      operand = call.operand(0);</span>
<span class="nc" id="L2546">      newOperand =</span>
<span class="nc" id="L2547">          registerFrom(</span>
              parentScope,
              usingScope,
              register,
              operand,
              enclosingNode,
              alias,
              extendList,
              forceNullable, lateral);
<span class="nc bnc" id="L2556" title="All 2 branches missed.">      if (newOperand != operand) {</span>
<span class="nc" id="L2557">        call.setOperand(0, newOperand);</span>
      }
      // If the operator is SqlWindowTableFunction, restricts the scope as
      // its first operand's (the table) scope.
<span class="nc bnc" id="L2561" title="All 2 branches missed.">      if (operand instanceof SqlBasicCall) {</span>
<span class="nc" id="L2562">        final SqlBasicCall call1 = (SqlBasicCall) operand;</span>
<span class="nc" id="L2563">        final SqlOperator op = call1.getOperator();</span>
<span class="nc bnc" id="L2564" title="All 2 branches missed.">        if (op instanceof SqlWindowTableFunction</span>
<span class="nc bnc" id="L2565" title="All 2 branches missed.">            &amp;&amp; call1.operand(0).getKind() == SqlKind.SELECT) {</span>
<span class="nc" id="L2566">          scopes.put(node, getSelectScope(call1.operand(0)));</span>
<span class="nc" id="L2567">          return newNode;</span>
        }
      }
      // Put the usingScope which can be a JoinScope
      // or a SelectScope, in order to see the left items
      // of the JOIN tree.
<span class="nc" id="L2573">      scopes.put(node, usingScope);</span>
<span class="nc" id="L2574">      return newNode;</span>

    case UNNEST:
<span class="nc bnc" id="L2577" title="All 2 branches missed.">      if (!lateral) {</span>
<span class="nc" id="L2578">        return registerFrom(parentScope, usingScope, register, node,</span>
            enclosingNode, alias, extendList, forceNullable, true);
      }
    // fall through
    case SELECT:
    case UNION:
    case INTERSECT:
    case EXCEPT:
    case VALUES:
    case WITH:
    case OTHER_FUNCTION:
<span class="nc bnc" id="L2589" title="All 2 branches missed.">      if (alias == null) {</span>
<span class="nc" id="L2590">        alias = SqlValidatorUtil.alias(node, nextGeneratedId++);</span>
      }
<span class="nc" id="L2592">      registerQuery(</span>
          parentScope,
<span class="nc bnc" id="L2594" title="All 2 branches missed.">          register ? usingScope : null,</span>
          node,
          enclosingNode,
          alias,
          forceNullable);
<span class="nc" id="L2599">      return newNode;</span>

    case OVER:
<span class="nc bnc" id="L2602" title="All 2 branches missed.">      if (!shouldAllowOverRelation()) {</span>
<span class="nc" id="L2603">        throw Util.unexpected(kind);</span>
      }
<span class="nc" id="L2605">      call = (SqlCall) node;</span>
<span class="nc" id="L2606">      final OverScope overScope = new OverScope(usingScope, call);</span>
<span class="nc" id="L2607">      scopes.put(call, overScope);</span>
<span class="nc" id="L2608">      operand = call.operand(0);</span>
<span class="nc" id="L2609">      newOperand =</span>
<span class="nc" id="L2610">          registerFrom(</span>
              parentScope,
              overScope,
              true,
              operand,
              enclosingNode,
              alias,
              extendList,
              forceNullable,
              lateral);
<span class="nc bnc" id="L2620" title="All 2 branches missed.">      if (newOperand != operand) {</span>
<span class="nc" id="L2621">        call.setOperand(0, newOperand);</span>
      }

<span class="nc bnc" id="L2624" title="All 2 branches missed.">      for (ScopeChild child : overScope.children) {</span>
<span class="nc bnc" id="L2625" title="All 2 branches missed.">        registerNamespace(register ? usingScope : null, child.name,</span>
            child.namespace, forceNullable);
<span class="nc" id="L2627">      }</span>

<span class="nc" id="L2629">      return newNode;</span>

    case TABLE_REF:
<span class="nc" id="L2632">      call = (SqlCall) node;</span>
<span class="nc" id="L2633">      registerFrom(parentScope,</span>
          usingScope,
          register,
<span class="nc" id="L2636">          call.operand(0),</span>
          enclosingNode,
          alias,
          extendList,
          forceNullable,
          lateral);
<span class="nc bnc" id="L2642" title="All 4 branches missed.">      if (extendList != null &amp;&amp; !extendList.isEmpty()) {</span>
<span class="nc" id="L2643">        return enclosingNode;</span>
      }
<span class="nc" id="L2645">      return newNode;</span>

    case EXTEND:
<span class="nc" id="L2648">      final SqlCall extend = (SqlCall) node;</span>
<span class="nc" id="L2649">      return registerFrom(parentScope,</span>
          usingScope,
          true,
<span class="nc" id="L2652">          extend.getOperandList().get(0),</span>
          extend,
          alias,
<span class="nc" id="L2655">          (SqlNodeList) extend.getOperandList().get(1),</span>
          forceNullable,
          lateral);

    case SNAPSHOT:
<span class="nc" id="L2660">      call = (SqlCall) node;</span>
<span class="nc" id="L2661">      operand = call.operand(0);</span>
<span class="nc" id="L2662">      newOperand =</span>
<span class="nc" id="L2663">          registerFrom(parentScope,</span>
              usingScope,
              register,
              operand,
              enclosingNode,
              alias,
              extendList,
              forceNullable,
              lateral);
<span class="nc bnc" id="L2672" title="All 2 branches missed.">      if (newOperand != operand) {</span>
<span class="nc" id="L2673">        call.setOperand(0, newOperand);</span>
      }
      // Put the usingScope which can be a JoinScope
      // or a SelectScope, in order to see the left items
      // of the JOIN tree.
<span class="nc" id="L2678">      scopes.put(node, usingScope);</span>
<span class="nc" id="L2679">      return newNode;</span>

    default:
<span class="nc" id="L2682">      throw Util.unexpected(kind);</span>
    }
  }
  // CHECKSTYLE: ON

  protected boolean shouldAllowOverRelation() {
<span class="nc" id="L2688">    return false;</span>
  }

  /**
   * Creates a namespace for a &lt;code&gt;SELECT&lt;/code&gt; node. Derived class may
   * override this factory method.
   *
   * @param select        Select node
   * @param enclosingNode Enclosing node
   * @return Select namespace
   */
  protected SelectNamespace createSelectNamespace(
      SqlSelect select,
      SqlNode enclosingNode) {
<span class="nc" id="L2702">    return new SelectNamespace(this, select, enclosingNode);</span>
  }

  /**
   * Creates a namespace for a set operation (&lt;code&gt;UNION&lt;/code&gt;, &lt;code&gt;
   * INTERSECT&lt;/code&gt;, or &lt;code&gt;EXCEPT&lt;/code&gt;). Derived class may override
   * this factory method.
   *
   * @param call          Call to set operation
   * @param enclosingNode Enclosing node
   * @return Set operation namespace
   */
  protected SetopNamespace createSetopNamespace(
      SqlCall call,
      SqlNode enclosingNode) {
<span class="nc" id="L2717">    return new SetopNamespace(this, call, enclosingNode);</span>
  }

  /**
   * Registers a query in a parent scope.
   *
   * @param parentScope Parent scope which this scope turns to in order to
   *                    resolve objects
   * @param usingScope  Scope whose child list this scope should add itself to
   * @param node        Query node
   * @param alias       Name of this query within its parent. Must be specified
   *                    if usingScope != null
   */
  protected void registerQuery(
      SqlValidatorScope parentScope,
      @Nullable SqlValidatorScope usingScope,
      SqlNode node,
      SqlNode enclosingNode,
      @Nullable String alias,
      boolean forceNullable) {
<span class="nc bnc" id="L2737" title="All 4 branches missed.">    checkArgument(usingScope == null || alias != null);</span>
<span class="nc" id="L2738">    registerQuery(</span>
        parentScope,
        usingScope,
        node,
        enclosingNode,
        alias,
        forceNullable,
        true);
<span class="nc" id="L2746">  }</span>

  /**
   * Registers a query in a parent scope.
   *
   * @param parentScope Parent scope which this scope turns to in order to
   *                    resolve objects
   * @param usingScope  Scope whose child list this scope should add itself to
   * @param node        Query node
   * @param alias       Name of this query within its parent. Must be specified
   *                    if usingScope != null
   * @param checkUpdate if true, validate that the update feature is supported
   *                    if validating the update statement
   */
  private void registerQuery(
      SqlValidatorScope parentScope,
      @Nullable SqlValidatorScope usingScope,
      SqlNode node,
      SqlNode enclosingNode,
      @Nullable String alias,
      boolean forceNullable,
      boolean checkUpdate) {
<span class="nc" id="L2768">    requireNonNull(node, &quot;node&quot;);</span>
<span class="nc" id="L2769">    requireNonNull(enclosingNode, &quot;enclosingNode&quot;);</span>
<span class="nc bnc" id="L2770" title="All 4 branches missed.">    checkArgument(usingScope == null || alias != null);</span>

    SqlCall call;
    List&lt;SqlNode&gt; operands;
<span class="nc bnc" id="L2774" title="All 15 branches missed.">    switch (node.getKind()) {</span>
    case SELECT:
<span class="nc" id="L2776">      final SqlSelect select = (SqlSelect) node;</span>
<span class="nc" id="L2777">      final SelectNamespace selectNs =</span>
<span class="nc" id="L2778">          createSelectNamespace(select, enclosingNode);</span>
<span class="nc" id="L2779">      registerNamespace(usingScope, alias, selectNs, forceNullable);</span>
<span class="nc" id="L2780">      final SqlValidatorScope windowParentScope =</span>
<span class="nc" id="L2781">          first(usingScope, parentScope);</span>
<span class="nc" id="L2782">      SelectScope selectScope =</span>
          new SelectScope(parentScope, windowParentScope, select);
<span class="nc" id="L2784">      scopes.put(select, selectScope);</span>

      // Start by registering the WHERE clause
<span class="nc" id="L2787">      clauseScopes.put(IdPair.of(select, Clause.WHERE), selectScope);</span>
<span class="nc" id="L2788">      registerOperandSubQueries(</span>
          selectScope,
          select,
          SqlSelect.WHERE_OPERAND);

      // Register subqueries in the QUALIFY clause
<span class="nc" id="L2794">      registerOperandSubQueries(</span>
          selectScope,
          select,
          SqlSelect.QUALIFY_OPERAND);

      // Register FROM with the inherited scope 'parentScope', not
      // 'selectScope', otherwise tables in the FROM clause would be
      // able to see each other.
<span class="nc" id="L2802">      final SqlNode from = select.getFrom();</span>
<span class="nc bnc" id="L2803" title="All 2 branches missed.">      if (from != null) {</span>
<span class="nc" id="L2804">        final SqlNode newFrom =</span>
<span class="nc" id="L2805">            registerFrom(</span>
                parentScope,
                selectScope,
                true,
                from,
                from,
                null,
                null,
                false,
                false);
<span class="nc bnc" id="L2815" title="All 2 branches missed.">        if (newFrom != from) {</span>
<span class="nc" id="L2816">          select.setFrom(newFrom);</span>
        }
      }

      // If this is an aggregate query, the SELECT list and HAVING
      // clause use a different scope, where you can only reference
      // columns which are in the GROUP BY clause.
      final SqlValidatorScope selectScope2 =
<span class="nc bnc" id="L2824" title="All 2 branches missed.">          isAggregate(select)</span>
<span class="nc" id="L2825">              ? new AggregatingSelectScope(selectScope, select, false)</span>
<span class="nc" id="L2826">              : selectScope;</span>
<span class="nc" id="L2827">      clauseScopes.put(IdPair.of(select, Clause.SELECT), selectScope2);</span>
<span class="nc" id="L2828">      clauseScopes.put(IdPair.of(select, Clause.MEASURE),</span>
          new MeasureScope(selectScope, select));
<span class="nc bnc" id="L2830" title="All 2 branches missed.">      if (select.getGroup() != null) {</span>
<span class="nc" id="L2831">        GroupByScope groupByScope =</span>
<span class="nc" id="L2832">            new GroupByScope(selectScope, select.getGroup(), select);</span>
<span class="nc" id="L2833">        clauseScopes.put(IdPair.of(select, Clause.GROUP_BY), groupByScope);</span>
<span class="nc" id="L2834">        registerSubQueries(groupByScope, select.getGroup());</span>
      }
<span class="nc" id="L2836">      registerOperandSubQueries(</span>
          selectScope2,
          select,
          SqlSelect.HAVING_OPERAND);
<span class="nc" id="L2840">      registerSubQueries(selectScope2,</span>
<span class="nc" id="L2841">          SqlNonNullableAccessors.getSelectList(select));</span>
<span class="nc" id="L2842">      final SqlNodeList orderList = select.getOrderList();</span>
<span class="nc bnc" id="L2843" title="All 2 branches missed.">      if (orderList != null) {</span>
        // If the query is 'SELECT DISTINCT', restrict the columns
        // available to the ORDER BY clause.
        final SqlValidatorScope selectScope3 =
<span class="nc bnc" id="L2847" title="All 2 branches missed.">            select.isDistinct()</span>
<span class="nc" id="L2848">                ? new AggregatingSelectScope(selectScope, select, true)</span>
<span class="nc" id="L2849">                : selectScope2;</span>
<span class="nc" id="L2850">        OrderByScope orderScope =</span>
            new OrderByScope(selectScope3, orderList, select);
<span class="nc" id="L2852">        clauseScopes.put(IdPair.of(select, Clause.ORDER), orderScope);</span>
<span class="nc" id="L2853">        registerSubQueries(orderScope, orderList);</span>

<span class="nc bnc" id="L2855" title="All 2 branches missed.">        if (!isAggregate(select)) {</span>
          // Since this is not an aggregate query,
          // there cannot be any aggregates in the ORDER BY clause.
<span class="nc" id="L2858">          SqlNode agg = aggFinder.findAgg(orderList);</span>
<span class="nc bnc" id="L2859" title="All 2 branches missed.">          if (agg != null) {</span>
<span class="nc" id="L2860">            throw newValidationError(agg, RESOURCE.aggregateIllegalInOrderBy());</span>
          }
        }
<span class="nc" id="L2863">      }</span>
      break;

    case INTERSECT:
<span class="nc" id="L2867">      validateFeature(RESOURCE.sQLFeature_F302(), node.getParserPosition());</span>
<span class="nc" id="L2868">      registerSetop(</span>
          parentScope,
          usingScope,
          node,
          node,
          alias,
          forceNullable);
<span class="nc" id="L2875">      break;</span>

    case EXCEPT:
<span class="nc" id="L2878">      validateFeature(RESOURCE.sQLFeature_E071_03(), node.getParserPosition());</span>
<span class="nc" id="L2879">      registerSetop(</span>
          parentScope,
          usingScope,
          node,
          node,
          alias,
          forceNullable);
<span class="nc" id="L2886">      break;</span>

    case UNION:
<span class="nc" id="L2889">      registerSetop(</span>
          parentScope,
          usingScope,
          node,
          enclosingNode,
          alias,
          forceNullable);
<span class="nc" id="L2896">      break;</span>

    case LAMBDA:
<span class="nc" id="L2899">      call = (SqlCall) node;</span>
<span class="nc" id="L2900">      SqlLambdaScope lambdaScope =</span>
          new SqlLambdaScope(parentScope, (SqlLambda) call);
<span class="nc" id="L2902">      scopes.put(call, lambdaScope);</span>
<span class="nc" id="L2903">      final LambdaNamespace lambdaNamespace =</span>
          new LambdaNamespace(this, (SqlLambda) call, node);
<span class="nc" id="L2905">      registerNamespace(</span>
          usingScope,
          alias,
          lambdaNamespace,
          forceNullable);
<span class="nc" id="L2910">      operands = call.getOperandList();</span>
<span class="nc bnc" id="L2911" title="All 2 branches missed.">      for (int i = 0; i &lt; operands.size(); i++) {</span>
<span class="nc" id="L2912">        registerOperandSubQueries(parentScope, call, i);</span>
      }
<span class="nc" id="L2914">      break;</span>

    case WITH:
<span class="nc" id="L2917">      registerWith(parentScope, usingScope, (SqlWith) node, enclosingNode,</span>
          alias, forceNullable, checkUpdate);
<span class="nc" id="L2919">      break;</span>

    case VALUES:
<span class="nc" id="L2922">      call = (SqlCall) node;</span>
<span class="nc" id="L2923">      scopes.put(call, parentScope);</span>
<span class="nc" id="L2924">      final TableConstructorNamespace tableConstructorNamespace =</span>
          new TableConstructorNamespace(
              this,
              call,
              parentScope,
              enclosingNode);
<span class="nc" id="L2930">      registerNamespace(</span>
          usingScope,
          alias,
          tableConstructorNamespace,
          forceNullable);
<span class="nc" id="L2935">      operands = call.getOperandList();</span>
<span class="nc bnc" id="L2936" title="All 2 branches missed.">      for (int i = 0; i &lt; operands.size(); ++i) {</span>
<span class="nc bnc" id="L2937" title="All 2 branches missed.">        assert operands.get(i).getKind() == SqlKind.ROW;</span>

        // FIXME jvs 9-Feb-2005:  Correlation should
        // be illegal in these sub-queries.  Same goes for
        // any non-lateral SELECT in the FROM list.
<span class="nc" id="L2942">        registerOperandSubQueries(parentScope, call, i);</span>
      }
<span class="nc" id="L2944">      break;</span>

    case INSERT:
<span class="nc" id="L2947">      SqlInsert insertCall = (SqlInsert) node;</span>
<span class="nc" id="L2948">      InsertNamespace insertNs =</span>
          new InsertNamespace(
              this,
              insertCall,
              enclosingNode,
              parentScope);
<span class="nc" id="L2954">      registerNamespace(usingScope, null, insertNs, forceNullable);</span>
<span class="nc" id="L2955">      registerQuery(</span>
          parentScope,
          usingScope,
<span class="nc" id="L2958">          insertCall.getSource(),</span>
          enclosingNode,
          null,
          false);
<span class="nc" id="L2962">      break;</span>

    case DELETE:
<span class="nc" id="L2965">      SqlDelete deleteCall = (SqlDelete) node;</span>
<span class="nc" id="L2966">      DeleteNamespace deleteNs =</span>
          new DeleteNamespace(
              this,
              deleteCall,
              enclosingNode,
              parentScope);
<span class="nc" id="L2972">      registerNamespace(usingScope, null, deleteNs, forceNullable);</span>
<span class="nc" id="L2973">      registerQuery(</span>
          parentScope,
          usingScope,
<span class="nc" id="L2976">          SqlNonNullableAccessors.getSourceSelect(deleteCall),</span>
          enclosingNode,
          null,
          false);
<span class="nc" id="L2980">      break;</span>

    case UPDATE:
<span class="nc bnc" id="L2983" title="All 2 branches missed.">      if (checkUpdate) {</span>
<span class="nc" id="L2984">        validateFeature(RESOURCE.sQLFeature_E101_03(),</span>
<span class="nc" id="L2985">            node.getParserPosition());</span>
      }
<span class="nc" id="L2987">      SqlUpdate updateCall = (SqlUpdate) node;</span>
<span class="nc" id="L2988">      UpdateNamespace updateNs =</span>
          new UpdateNamespace(
              this,
              updateCall,
              enclosingNode,
              parentScope);
<span class="nc" id="L2994">      registerNamespace(usingScope, null, updateNs, forceNullable);</span>
<span class="nc" id="L2995">      registerQuery(</span>
          parentScope,
          usingScope,
<span class="nc" id="L2998">          SqlNonNullableAccessors.getSourceSelect(updateCall),</span>
          enclosingNode,
          null,
          false);
<span class="nc" id="L3002">      break;</span>

    case MERGE:
<span class="nc" id="L3005">      validateFeature(RESOURCE.sQLFeature_F312(), node.getParserPosition());</span>
<span class="nc" id="L3006">      SqlMerge mergeCall = (SqlMerge) node;</span>
<span class="nc" id="L3007">      MergeNamespace mergeNs =</span>
          new MergeNamespace(
              this,
              mergeCall,
              enclosingNode,
              parentScope);
<span class="nc" id="L3013">      registerNamespace(usingScope, null, mergeNs, forceNullable);</span>
<span class="nc" id="L3014">      registerQuery(</span>
          parentScope,
          usingScope,
<span class="nc" id="L3017">          SqlNonNullableAccessors.getSourceSelect(mergeCall),</span>
          enclosingNode,
          null,
          false);

      // update call can reference either the source table reference
      // or the target table, so set its parent scope to the merge's
      // source select; when validating the update, skip the feature
      // validation check
<span class="nc" id="L3026">      SqlUpdate mergeUpdateCall = mergeCall.getUpdateCall();</span>
<span class="nc bnc" id="L3027" title="All 2 branches missed.">      if (mergeUpdateCall != null) {</span>
<span class="nc" id="L3028">        registerQuery(</span>
<span class="nc" id="L3029">            getScope(SqlNonNullableAccessors.getSourceSelect(mergeCall), Clause.WHERE),</span>
            null,
            mergeUpdateCall,
            enclosingNode,
            null,
            false,
            false);
      }
<span class="nc" id="L3037">      SqlInsert mergeInsertCall = mergeCall.getInsertCall();</span>
<span class="nc bnc" id="L3038" title="All 2 branches missed.">      if (mergeInsertCall != null) {</span>
<span class="nc" id="L3039">        registerQuery(</span>
            parentScope,
            null,
            mergeInsertCall,
            enclosingNode,
            null,
            false);
      }
      break;

    case UNNEST:
<span class="nc" id="L3050">      call = (SqlCall) node;</span>
<span class="nc" id="L3051">      final UnnestNamespace unnestNs =</span>
          new UnnestNamespace(this, call, parentScope, enclosingNode);
<span class="nc" id="L3053">      registerNamespace(</span>
          usingScope,
          alias,
          unnestNs,
          forceNullable);
<span class="nc" id="L3058">      registerOperandSubQueries(parentScope, call, 0);</span>
<span class="nc" id="L3059">      scopes.put(node, parentScope);</span>
<span class="nc" id="L3060">      break;</span>
    case OTHER_FUNCTION:
<span class="nc" id="L3062">      call = (SqlCall) node;</span>
<span class="nc" id="L3063">      ProcedureNamespace procNs =</span>
          new ProcedureNamespace(
              this,
              parentScope,
              call,
              enclosingNode);
<span class="nc" id="L3069">      registerNamespace(</span>
          usingScope,
          alias,
          procNs,
          forceNullable);
<span class="nc" id="L3074">      registerSubQueries(parentScope, call);</span>
<span class="nc" id="L3075">      break;</span>

    case MULTISET_QUERY_CONSTRUCTOR:
    case MULTISET_VALUE_CONSTRUCTOR:
<span class="nc" id="L3079">      validateFeature(RESOURCE.sQLFeature_S271(), node.getParserPosition());</span>
<span class="nc" id="L3080">      call = (SqlCall) node;</span>
<span class="nc" id="L3081">      CollectScope cs = new CollectScope(parentScope, usingScope, call);</span>
<span class="nc" id="L3082">      final CollectNamespace tableConstructorNs =</span>
          new CollectNamespace(call, cs, enclosingNode);
<span class="nc" id="L3084">      final String alias2 = SqlValidatorUtil.alias(node, nextGeneratedId++);</span>
<span class="nc" id="L3085">      registerNamespace(</span>
          usingScope,
          alias2,
          tableConstructorNs,
          forceNullable);
<span class="nc" id="L3090">      operands = call.getOperandList();</span>
<span class="nc bnc" id="L3091" title="All 2 branches missed.">      for (int i = 0; i &lt; operands.size(); i++) {</span>
<span class="nc" id="L3092">        registerOperandSubQueries(parentScope, call, i);</span>
      }
<span class="nc" id="L3094">      break;</span>

    default:
<span class="nc" id="L3097">      throw Util.unexpected(node.getKind());</span>
    }
<span class="nc" id="L3099">  }</span>

  private void registerSetop(
      SqlValidatorScope parentScope,
      @Nullable SqlValidatorScope usingScope,
      SqlNode node,
      SqlNode enclosingNode,
      @Nullable String alias,
      boolean forceNullable) {
<span class="nc" id="L3108">    SqlCall call = (SqlCall) node;</span>
<span class="nc" id="L3109">    final SetopNamespace setopNamespace =</span>
<span class="nc" id="L3110">        createSetopNamespace(call, enclosingNode);</span>
<span class="nc" id="L3111">    registerNamespace(usingScope, alias, setopNamespace, forceNullable);</span>

    // A setop is in the same scope as its parent.
<span class="nc" id="L3114">    scopes.put(call, parentScope);</span>
<span class="nc" id="L3115">    @NonNull SqlValidatorScope recursiveScope = parentScope;</span>
<span class="nc bnc" id="L3116" title="All 2 branches missed.">    if (enclosingNode.getKind() == SqlKind.WITH_ITEM) {</span>
<span class="nc bnc" id="L3117" title="All 2 branches missed.">      if (node.getKind() != SqlKind.UNION) {</span>
<span class="nc" id="L3118">        throw newValidationError(node, RESOURCE.recursiveWithMustHaveUnionSetOp());</span>
<span class="nc bnc" id="L3119" title="All 2 branches missed.">      } else if (call.getOperandList().size() &gt; 2) {</span>
<span class="nc" id="L3120">        throw newValidationError(node, RESOURCE.recursiveWithMustHaveTwoChildUnionSetOp());</span>
      }
<span class="nc" id="L3122">      final WithScope scope = (WithScope) scopes.get(enclosingNode);</span>
      // recursive scope is only set for the recursive queries.
<span class="nc bnc" id="L3124" title="All 4 branches missed.">      recursiveScope = scope != null &amp;&amp; scope.recursiveScope != null</span>
<span class="nc" id="L3125">          ? requireNonNull(scope.recursiveScope) : parentScope;</span>
    }
<span class="nc bnc" id="L3127" title="All 2 branches missed.">    for (int i = 0; i &lt; call.getOperandList().size(); i++) {</span>
<span class="nc" id="L3128">      SqlNode operand = call.getOperandList().get(i);</span>
<span class="nc bnc" id="L3129" title="All 2 branches missed.">      @NonNull SqlValidatorScope scope = i == 0 ? parentScope : recursiveScope;</span>
<span class="nc" id="L3130">      registerQuery(</span>
          scope,
          null,
          operand,
          operand,
          null,
          false);
    }
<span class="nc" id="L3138">  }</span>

  private void registerWith(
      SqlValidatorScope parentScope,
      @Nullable SqlValidatorScope usingScope,
      SqlWith with,
      SqlNode enclosingNode,
      @Nullable String alias,
      boolean forceNullable,
      boolean checkUpdate) {
<span class="nc" id="L3148">    final WithNamespace withNamespace =</span>
        new WithNamespace(this, with, enclosingNode);
<span class="nc" id="L3150">    registerNamespace(usingScope, alias, withNamespace, forceNullable);</span>
<span class="nc" id="L3151">    scopes.put(with, parentScope);</span>

<span class="nc" id="L3153">    SqlValidatorScope scope = parentScope;</span>
<span class="nc bnc" id="L3154" title="All 2 branches missed.">    for (SqlNode withItem_ : with.withList) {</span>
<span class="nc" id="L3155">      final SqlWithItem withItem = (SqlWithItem) withItem_;</span>

<span class="nc" id="L3157">      final boolean isRecursiveWith = withItem.recursive.booleanValue();</span>
<span class="nc" id="L3158">      final SqlValidatorScope withScope =</span>
          new WithScope(scope, withItem,
<span class="nc bnc" id="L3160" title="All 2 branches missed.">              isRecursiveWith ? new WithRecursiveScope(scope, withItem) : null);</span>
<span class="nc" id="L3161">      scopes.put(withItem, withScope);</span>

<span class="nc" id="L3163">      registerQuery(scope, null, withItem.query,</span>
<span class="nc bnc" id="L3164" title="All 2 branches missed.">          withItem.recursive.booleanValue() ? withItem : with, withItem.name.getSimple(),</span>
          forceNullable);
<span class="nc" id="L3166">      registerNamespace(null, alias,</span>
          new WithItemNamespace(this, withItem, enclosingNode),
          false);
<span class="nc" id="L3169">      scope = withScope;</span>
<span class="nc" id="L3170">    }</span>
<span class="nc" id="L3171">    registerQuery(scope, null, with.body, enclosingNode, alias, forceNullable,</span>
        checkUpdate);
<span class="nc" id="L3173">  }</span>

  @Override public boolean isAggregate(SqlSelect select) {
<span class="nc bnc" id="L3176" title="All 2 branches missed.">    if (getAggregate(select) != null) {</span>
<span class="nc" id="L3177">      return true;</span>
    }
    // Also when nested window aggregates are present
<span class="nc bnc" id="L3180" title="All 2 branches missed.">    for (SqlCall call : overFinder.findAll(SqlNonNullableAccessors.getSelectList(select))) {</span>
<span class="nc bnc" id="L3181" title="All 2 branches missed.">      assert call.getKind() == SqlKind.OVER;</span>
<span class="nc bnc" id="L3182" title="All 2 branches missed.">      if (isNestedAggregateWindow(call.operand(0))) {</span>
<span class="nc" id="L3183">        return true;</span>
      }
<span class="nc bnc" id="L3185" title="All 2 branches missed.">      if (isOverAggregateWindow(call.operand(1))) {</span>
<span class="nc" id="L3186">        return true;</span>
      }
<span class="nc" id="L3188">    }</span>
<span class="nc" id="L3189">    return false;</span>
  }

  protected boolean isNestedAggregateWindow(SqlNode node) {
<span class="nc" id="L3193">    AggFinder nestedAggFinder =</span>
        new AggFinder(opTab, false, false, false, aggFinder,
<span class="nc" id="L3195">            catalogReader.nameMatcher());</span>
<span class="nc bnc" id="L3196" title="All 2 branches missed.">    return nestedAggFinder.findAgg(node) != null;</span>
  }

  protected boolean isOverAggregateWindow(SqlNode node) {
<span class="nc bnc" id="L3200" title="All 2 branches missed.">    return aggFinder.findAgg(node) != null;</span>
  }

  /** Returns the parse tree node (GROUP BY, HAVING, or an aggregate function
   * call) that causes {@code select} to be an aggregate query, or null if it
   * is not an aggregate query.
   *
   * &lt;p&gt;The node is useful context for error messages,
   * but you cannot assume that the node is the only aggregate function. */
  protected @Nullable SqlNode getAggregate(SqlSelect select) {
<span class="nc" id="L3210">    SqlNode node = select.getGroup();</span>
<span class="nc bnc" id="L3211" title="All 2 branches missed.">    if (node != null) {</span>
<span class="nc" id="L3212">      return node;</span>
    }
<span class="nc" id="L3214">    node = select.getHaving();</span>
<span class="nc bnc" id="L3215" title="All 2 branches missed.">    if (node != null) {</span>
<span class="nc" id="L3216">      return node;</span>
    }
<span class="nc" id="L3218">    return getAgg(select);</span>
  }

  /** If there is at least one call to an aggregate function, returns the
   * first. */
  private @Nullable SqlNode getAgg(SqlSelect select) {
<span class="nc" id="L3224">    final SelectScope selectScope = getRawSelectScope(select);</span>
<span class="nc bnc" id="L3225" title="All 2 branches missed.">    if (selectScope != null) {</span>
<span class="nc" id="L3226">      final List&lt;SqlNode&gt; selectList = selectScope.getExpandedSelectList();</span>
<span class="nc bnc" id="L3227" title="All 2 branches missed.">      if (selectList != null) {</span>
<span class="nc" id="L3228">        return aggFinder.findAgg(selectList);</span>
      }
    }
<span class="nc" id="L3231">    return aggFinder.findAgg(SqlNonNullableAccessors.getSelectList(select));</span>
  }

  @Deprecated
  @Override public boolean isAggregate(SqlNode selectNode) {
<span class="nc bnc" id="L3236" title="All 2 branches missed.">    return aggFinder.findAgg(selectNode) != null;</span>
  }

  private void validateNodeFeature(SqlNode node) {
<span class="nc bnc" id="L3240" title="All 2 branches missed.">    switch (node.getKind()) {</span>
    case MULTISET_VALUE_CONSTRUCTOR:
<span class="nc" id="L3242">      validateFeature(RESOURCE.sQLFeature_S271(), node.getParserPosition());</span>
<span class="nc" id="L3243">      break;</span>
    default:
      break;
    }
<span class="nc" id="L3247">  }</span>

  private void registerSubQueries(
      SqlValidatorScope parentScope,
      @Nullable SqlNode node) {
<span class="nc bnc" id="L3252" title="All 2 branches missed.">    if (node == null) {</span>
<span class="nc" id="L3253">      return;</span>
    }
<span class="nc bnc" id="L3255" title="All 2 branches missed.">    if (node.getKind().belongsTo(SqlKind.QUERY)</span>
<span class="nc bnc" id="L3256" title="All 2 branches missed.">        || node.getKind() == SqlKind.LAMBDA</span>
<span class="nc bnc" id="L3257" title="All 2 branches missed.">        || node.getKind() == SqlKind.MULTISET_QUERY_CONSTRUCTOR</span>
<span class="nc bnc" id="L3258" title="All 2 branches missed.">        || node.getKind() == SqlKind.MULTISET_VALUE_CONSTRUCTOR) {</span>
<span class="nc" id="L3259">      registerQuery(parentScope, null, node, node, null, false);</span>
<span class="nc bnc" id="L3260" title="All 2 branches missed.">    } else if (node instanceof SqlCall) {</span>
<span class="nc" id="L3261">      validateNodeFeature(node);</span>
<span class="nc" id="L3262">      SqlCall call = (SqlCall) node;</span>
<span class="nc bnc" id="L3263" title="All 2 branches missed.">      for (int i = 0; i &lt; call.operandCount(); i++) {</span>
<span class="nc" id="L3264">        registerOperandSubQueries(parentScope, call, i);</span>
      }
<span class="nc bnc" id="L3266" title="All 2 branches missed.">    } else if (node instanceof SqlNodeList) {</span>
<span class="nc" id="L3267">      SqlNodeList list = (SqlNodeList) node;</span>
<span class="nc bnc" id="L3268" title="All 2 branches missed.">      for (int i = 0, count = list.size(); i &lt; count; i++) {</span>
<span class="nc" id="L3269">        SqlNode listNode = list.get(i);</span>
<span class="nc bnc" id="L3270" title="All 2 branches missed.">        if (listNode.getKind().belongsTo(SqlKind.QUERY)) {</span>
<span class="nc" id="L3271">          listNode =</span>
<span class="nc" id="L3272">              SqlStdOperatorTable.SCALAR_QUERY.createCall(</span>
<span class="nc" id="L3273">                  listNode.getParserPosition(),</span>
                  listNode);
<span class="nc" id="L3275">          list.set(i, listNode);</span>
        }
<span class="nc" id="L3277">        registerSubQueries(parentScope, listNode);</span>
      }
    } else {
      // atomic node -- can be ignored
    }
<span class="nc" id="L3282">  }</span>

  /**
   * Registers any sub-queries inside a given call operand, and converts the
   * operand to a scalar sub-query if the operator requires it.
   *
   * @param parentScope    Parent scope
   * @param call           Call
   * @param operandOrdinal Ordinal of operand within call
   * @see SqlOperator#argumentMustBeScalar(int)
   */
  private void registerOperandSubQueries(
      SqlValidatorScope parentScope,
      SqlCall call,
      int operandOrdinal) {
<span class="nc" id="L3297">    SqlNode operand = call.operand(operandOrdinal);</span>
<span class="nc bnc" id="L3298" title="All 2 branches missed.">    if (operand == null) {</span>
<span class="nc" id="L3299">      return;</span>
    }
<span class="nc bnc" id="L3301" title="All 2 branches missed.">    if (operand.getKind().belongsTo(SqlKind.QUERY)</span>
<span class="nc bnc" id="L3302" title="All 2 branches missed.">        &amp;&amp; call.getOperator().argumentMustBeScalar(operandOrdinal)) {</span>
<span class="nc" id="L3303">      operand =</span>
<span class="nc" id="L3304">          SqlStdOperatorTable.SCALAR_QUERY.createCall(</span>
<span class="nc" id="L3305">              operand.getParserPosition(),</span>
              operand);
<span class="nc" id="L3307">      call.setOperand(operandOrdinal, operand);</span>
    }
<span class="nc" id="L3309">    registerSubQueries(parentScope, operand);</span>
<span class="nc" id="L3310">  }</span>

  @Override public void validateIdentifier(SqlIdentifier id, SqlValidatorScope scope) {
<span class="nc" id="L3313">    final SqlQualified fqId = scope.fullyQualify(id);</span>
<span class="nc bnc" id="L3314" title="All 2 branches missed.">    if (this.config.columnReferenceExpansion()) {</span>
      // NOTE jvs 9-Apr-2007: this doesn't cover ORDER BY, which has its
      // own ideas about qualification.
<span class="nc" id="L3317">      id.assignNamesFrom(fqId.identifier);</span>
    } else {
<span class="nc" id="L3319">      Util.discard(fqId);</span>
    }
<span class="nc" id="L3321">  }</span>

  @SuppressWarnings(&quot;deprecation&quot;) // [CALCITE-6598]
  @Override public void validateLiteral(SqlLiteral literal) {
<span class="nc bnc" id="L3325" title="All 6 branches missed.">    switch (literal.getTypeName()) {</span>
    case DECIMAL:
      // Accept any decimal value that does not exceed the max
      // precision and scale of the type system.
<span class="nc" id="L3329">      final RelDataTypeSystem typeSystem = getTypeFactory().getTypeSystem();</span>
<span class="nc" id="L3330">      final BigDecimal bd = literal.getValueAs(BigDecimal.class);</span>
<span class="nc" id="L3331">      final BigDecimal noTrailingZeros = bd.stripTrailingZeros();</span>
      // If we don't strip trailing zeros we may reject values such as 1.000....0.

<span class="nc" id="L3334">      final int maxPrecision = typeSystem.getMaxNumericPrecision();</span>
<span class="nc bnc" id="L3335" title="All 2 branches missed.">      if (noTrailingZeros.precision() &gt; maxPrecision) {</span>
<span class="nc" id="L3336">        throw newValidationError(literal,</span>
<span class="nc" id="L3337">            RESOURCE.numberLiteralOutOfRange(bd.toString()));</span>
      }

<span class="nc" id="L3340">      final int maxScale = typeSystem.getMaxNumericScale();</span>
<span class="nc bnc" id="L3341" title="All 2 branches missed.">      if (noTrailingZeros.scale() &gt; maxScale) {</span>
<span class="nc" id="L3342">        throw newValidationError(literal,</span>
<span class="nc" id="L3343">            RESOURCE.numberLiteralOutOfRange(bd.toString()));</span>
      }
      break;

    case DOUBLE:
    case FLOAT:
    case REAL:
<span class="nc" id="L3350">      validateLiteralAsDouble(literal);</span>
<span class="nc" id="L3351">      break;</span>

    case BINARY:
<span class="nc" id="L3354">      final BitString bitString = literal.getValueAs(BitString.class);</span>
<span class="nc bnc" id="L3355" title="All 2 branches missed.">      if ((bitString.getBitCount() % 8) != 0) {</span>
<span class="nc" id="L3356">        throw newValidationError(literal, RESOURCE.binaryLiteralOdd());</span>
      }
      break;

    case DATE:
    case TIME:
    case TIMESTAMP:
<span class="nc" id="L3363">      Calendar calendar = literal.getValueAs(Calendar.class);</span>
<span class="nc" id="L3364">      final int year = calendar.get(Calendar.YEAR);</span>
<span class="nc" id="L3365">      final int era = calendar.get(Calendar.ERA);</span>
<span class="nc bnc" id="L3366" title="All 6 branches missed.">      if (year &lt; 1 || era == GregorianCalendar.BC || year &gt; 9999) {</span>
<span class="nc" id="L3367">        throw newValidationError(literal,</span>
<span class="nc" id="L3368">            RESOURCE.dateLiteralOutOfRange(literal.toString()));</span>
      }
      break;

    case INTERVAL_YEAR:
    case INTERVAL_YEAR_MONTH:
    case INTERVAL_MONTH:
    case INTERVAL_DAY:
    case INTERVAL_DAY_HOUR:
    case INTERVAL_DAY_MINUTE:
    case INTERVAL_DAY_SECOND:
    case INTERVAL_HOUR:
    case INTERVAL_HOUR_MINUTE:
    case INTERVAL_HOUR_SECOND:
    case INTERVAL_MINUTE:
    case INTERVAL_MINUTE_SECOND:
    case INTERVAL_SECOND:
<span class="nc bnc" id="L3385" title="All 2 branches missed.">      if (literal instanceof SqlIntervalLiteral) {</span>
<span class="nc" id="L3386">        SqlIntervalLiteral.IntervalValue interval =</span>
<span class="nc" id="L3387">            literal.getValueAs(SqlIntervalLiteral.IntervalValue.class);</span>
<span class="nc" id="L3388">        SqlIntervalQualifier intervalQualifier =</span>
<span class="nc" id="L3389">            interval.getIntervalQualifier();</span>

        // ensure qualifier is good before attempting to validate literal
<span class="nc" id="L3392">        validateIntervalQualifier(intervalQualifier);</span>
<span class="nc" id="L3393">        String intervalStr = interval.getIntervalLiteral();</span>
        // throws CalciteContextException if string is invalid
<span class="nc" id="L3395">        int[] values =</span>
<span class="nc" id="L3396">            intervalQualifier.evaluateIntervalLiteral(intervalStr,</span>
<span class="nc" id="L3397">                literal.getParserPosition(), typeFactory.getTypeSystem());</span>
<span class="nc" id="L3398">        Util.discard(values);</span>
<span class="nc" id="L3399">      }</span>
      break;
    default:
      // default is to do nothing
    }
<span class="nc" id="L3404">  }</span>

  private void validateLiteralAsDouble(SqlLiteral literal) {
<span class="nc" id="L3407">    BigDecimal bd = literal.getValueAs(BigDecimal.class);</span>
<span class="nc" id="L3408">    double d = bd.doubleValue();</span>
<span class="nc bnc" id="L3409" title="All 4 branches missed.">    if (Double.isInfinite(d) || Double.isNaN(d)) {</span>
      // overflow
<span class="nc" id="L3411">      throw newValidationError(literal,</span>
<span class="nc" id="L3412">          RESOURCE.numberLiteralOutOfRange(Util.toScientificNotation(bd)));</span>
    }

    // REVIEW jvs 4-Aug-2004:  what about underflow?
<span class="nc" id="L3416">  }</span>

  @Override public void validateIntervalQualifier(SqlIntervalQualifier qualifier) {
<span class="nc" id="L3419">    requireNonNull(qualifier, &quot;qualifier&quot;);</span>
<span class="nc" id="L3420">    boolean startPrecisionOutOfRange = false;</span>
<span class="nc" id="L3421">    boolean fractionalSecondPrecisionOutOfRange = false;</span>
<span class="nc" id="L3422">    final RelDataTypeSystem typeSystem = typeFactory.getTypeSystem();</span>

<span class="nc" id="L3424">    final int startPrecision = qualifier.getStartPrecision(typeSystem);</span>
<span class="nc" id="L3425">    final int fracPrecision =</span>
<span class="nc" id="L3426">        qualifier.getFractionalSecondPrecision(typeSystem);</span>
<span class="nc" id="L3427">    final int maxPrecision = typeSystem.getMaxPrecision(qualifier.typeName());</span>
<span class="nc" id="L3428">    final int minPrecision = typeSystem.getMinPrecision(qualifier.typeName());</span>
<span class="nc" id="L3429">    final int minScale = typeSystem.getMinScale(qualifier.typeName());</span>
<span class="nc" id="L3430">    final int maxScale = typeSystem.getMaxScale(qualifier.typeName());</span>
<span class="nc bnc" id="L3431" title="All 4 branches missed.">    if (startPrecision &lt; minPrecision || startPrecision &gt; maxPrecision) {</span>
<span class="nc" id="L3432">      startPrecisionOutOfRange = true;</span>
    } else {
<span class="nc bnc" id="L3434" title="All 4 branches missed.">      if (fracPrecision &lt; minScale || fracPrecision &gt; maxScale) {</span>
<span class="nc" id="L3435">        fractionalSecondPrecisionOutOfRange = true;</span>
      }
    }

<span class="nc bnc" id="L3439" title="All 2 branches missed.">    if (startPrecisionOutOfRange) {</span>
<span class="nc" id="L3440">      throw newValidationError(qualifier,</span>
<span class="nc" id="L3441">          RESOURCE.intervalStartPrecisionOutOfRange(startPrecision,</span>
              &quot;INTERVAL &quot; + qualifier));
<span class="nc bnc" id="L3443" title="All 2 branches missed.">    } else if (fractionalSecondPrecisionOutOfRange) {</span>
<span class="nc" id="L3444">      throw newValidationError(qualifier,</span>
<span class="nc" id="L3445">          RESOURCE.intervalFractionalSecondPrecisionOutOfRange(</span>
              fracPrecision,
              &quot;INTERVAL &quot; + qualifier));
    }
<span class="nc" id="L3449">  }</span>

  @Override public TimeFrame validateTimeFrame(SqlIntervalQualifier qualifier) {
<span class="nc bnc" id="L3452" title="All 2 branches missed.">    if (qualifier.timeFrameName == null) {</span>
<span class="nc" id="L3453">      final TimeFrame timeFrame = timeFrameSet.get(qualifier.getUnit());</span>
<span class="nc" id="L3454">      return requireNonNull(timeFrame,</span>
<span class="nc" id="L3455">          () -&gt; &quot;time frame for &quot; + qualifier.getUnit());</span>
    }
<span class="nc" id="L3457">    final @Nullable TimeFrame timeFrame =</span>
<span class="nc" id="L3458">        timeFrameSet.getOpt(qualifier.timeFrameName);</span>
<span class="nc bnc" id="L3459" title="All 2 branches missed.">    if (timeFrame != null) {</span>
<span class="nc" id="L3460">      return timeFrame;</span>
    }
<span class="nc" id="L3462">    throw newValidationError(qualifier,</span>
<span class="nc" id="L3463">        RESOURCE.invalidTimeFrame(qualifier.timeFrameName));</span>
  }

  /**
   * Validates the FROM clause of a query, or (recursively) a child node of
   * the FROM clause: AS, OVER, JOIN, VALUES, or sub-query.
   *
   * @param node          Node in FROM clause, typically a table or derived
   *                      table
   * @param targetRowType Desired row type of this expression, or
   *                      {@link #unknownType} if not fussy. Must not be null.
   * @param scope         Scope
   */
  protected void validateFrom(
      SqlNode node,
      RelDataType targetRowType,
      SqlValidatorScope scope) {
<span class="nc" id="L3480">    requireNonNull(scope, &quot;scope&quot;);</span>
<span class="nc" id="L3481">    requireNonNull(targetRowType, &quot;targetRowType&quot;);</span>
<span class="nc bnc" id="L3482" title="All 7 branches missed.">    switch (node.getKind()) {</span>
    case AS:
    case TABLE_REF:
<span class="nc" id="L3485">      validateFrom(</span>
<span class="nc" id="L3486">          ((SqlCall) node).operand(0),</span>
          targetRowType,
          scope);
<span class="nc" id="L3489">      break;</span>
    case VALUES:
<span class="nc" id="L3491">      validateValues((SqlCall) node, targetRowType, scope);</span>
<span class="nc" id="L3492">      break;</span>
    case JOIN:
<span class="nc" id="L3494">      validateJoin((SqlJoin) node, scope);</span>
<span class="nc" id="L3495">      break;</span>
    case OVER:
<span class="nc" id="L3497">      validateOver((SqlCall) node, scope);</span>
<span class="nc" id="L3498">      break;</span>
    case UNNEST:
<span class="nc" id="L3500">      validateUnnest((SqlCall) node, scope, targetRowType);</span>
<span class="nc" id="L3501">      break;</span>
    case COLLECTION_TABLE:
<span class="nc" id="L3503">      validateTableFunction((SqlCall) node, scope, targetRowType);</span>
<span class="nc" id="L3504">      break;</span>
    default:
<span class="nc" id="L3506">      validateQuery(node, scope, targetRowType);</span>
      break;
    }

    // Validate the namespace representation of the node, just in case the
    // validation did not occur implicitly.
<span class="nc" id="L3512">    getNamespaceOrThrow(node, scope).validate(targetRowType);</span>
<span class="nc" id="L3513">  }</span>

  protected void validateTableFunction(SqlCall node, SqlValidatorScope scope,
      RelDataType targetRowType) {
    // Dig out real call; TABLE() wrapper is just syntactic.
<span class="nc" id="L3518">    SqlCall call = node.operand(0);</span>
<span class="nc bnc" id="L3519" title="All 2 branches missed.">    if (call.getOperator() instanceof SqlTableFunction) {</span>
<span class="nc" id="L3520">      SqlTableFunction tableFunction = (SqlTableFunction) call.getOperator();</span>
<span class="nc" id="L3521">      boolean visitedRowSemanticsTable = false;</span>
<span class="nc bnc" id="L3522" title="All 2 branches missed.">      for (int idx = 0; idx &lt; call.operandCount(); idx++) {</span>
<span class="nc" id="L3523">        TableCharacteristic tableCharacteristic = tableFunction.tableCharacteristic(idx);</span>
<span class="nc bnc" id="L3524" title="All 2 branches missed.">        if (tableCharacteristic != null) {</span>
          // Skip validate if current input table has set semantics
<span class="nc bnc" id="L3526" title="All 2 branches missed.">          if (tableCharacteristic.semantics == TableCharacteristic.Semantics.SET) {</span>
<span class="nc" id="L3527">            continue;</span>
          }
          // A table function at most has one input table with row semantics
<span class="nc bnc" id="L3530" title="All 2 branches missed.">          if (visitedRowSemanticsTable) {</span>
<span class="nc" id="L3531">            throw newValidationError(</span>
                call,
<span class="nc" id="L3533">                RESOURCE.multipleRowSemanticsTables(call.getOperator().getName()));</span>
          }
<span class="nc" id="L3535">          visitedRowSemanticsTable = true;</span>
        }
        // If table function defines the parameter is not table parameter, or is an input table
        // parameter with row semantics, then it should not be with PARTITION BY OR ORDER BY.
<span class="nc" id="L3539">        SqlNode currentNode = call.operand(idx);</span>
<span class="nc bnc" id="L3540" title="All 2 branches missed.">        if (currentNode instanceof SqlCall) {</span>
<span class="nc" id="L3541">          SqlOperator op = ((SqlCall) currentNode).getOperator();</span>
<span class="nc bnc" id="L3542" title="All 2 branches missed.">          if (op == SqlStdOperatorTable.ARGUMENT_ASSIGNMENT) {</span>
            // Dig out the underlying operand
<span class="nc" id="L3544">            SqlNode realNode = ((SqlBasicCall) currentNode).operand(0);</span>
<span class="nc bnc" id="L3545" title="All 2 branches missed.">            if (realNode instanceof SqlCall) {</span>
<span class="nc" id="L3546">              currentNode = realNode;</span>
<span class="nc" id="L3547">              op = ((SqlCall) realNode).getOperator();</span>
            }
          }
<span class="nc bnc" id="L3550" title="All 2 branches missed.">          if (op == SqlStdOperatorTable.SET_SEMANTICS_TABLE) {</span>
<span class="nc" id="L3551">            throwInvalidRowSemanticsTable(call, idx, (SqlCall) currentNode);</span>
          }
        }
      }
    }
<span class="nc" id="L3556">    validateQuery(node, scope, targetRowType);</span>
<span class="nc" id="L3557">  }</span>

  private void throwInvalidRowSemanticsTable(SqlCall call, int idx, SqlCall table) {
<span class="nc" id="L3560">    SqlNodeList partitionList = table.operand(1);</span>
<span class="nc bnc" id="L3561" title="All 2 branches missed.">    if (!partitionList.isEmpty()) {</span>
<span class="nc" id="L3562">      throw newValidationError(call,</span>
<span class="nc" id="L3563">          RESOURCE.invalidPartitionKeys(</span>
<span class="nc" id="L3564">              idx, call.getOperator().getName()));</span>
    }
<span class="nc" id="L3566">    SqlNodeList orderList = table.operand(2);</span>
<span class="nc bnc" id="L3567" title="All 2 branches missed.">    if (!orderList.isEmpty()) {</span>
<span class="nc" id="L3568">      throw newValidationError(call,</span>
<span class="nc" id="L3569">          RESOURCE.invalidOrderBy(</span>
<span class="nc" id="L3570">              idx, call.getOperator().getName()));</span>
    }
<span class="nc" id="L3572">  }</span>

  protected void validateOver(SqlCall call, SqlValidatorScope scope) {
<span class="nc" id="L3575">    throw new AssertionError(&quot;OVER unexpected in this context&quot;);</span>
  }

  protected void validateUnnest(SqlCall call, SqlValidatorScope scope,
      RelDataType targetRowType) {
<span class="nc bnc" id="L3580" title="All 2 branches missed.">    for (int i = 0; i &lt; call.operandCount(); i++) {</span>
<span class="nc" id="L3581">      SqlNode expandedItem = expand(call.operand(i), scope);</span>
<span class="nc" id="L3582">      call.setOperand(i, expandedItem);</span>
    }
<span class="nc" id="L3584">    validateQuery(call, scope, targetRowType);</span>
<span class="nc" id="L3585">  }</span>

  private void checkRollUpInUsing(SqlIdentifier identifier,
      SqlNode leftOrRight, SqlValidatorScope scope) {
<span class="nc" id="L3589">    SqlValidatorNamespace namespace = getNamespace(leftOrRight, scope);</span>
<span class="nc bnc" id="L3590" title="All 2 branches missed.">    if (namespace != null) {</span>
<span class="nc" id="L3591">      SqlValidatorTable sqlValidatorTable = namespace.getTable();</span>
<span class="nc bnc" id="L3592" title="All 2 branches missed.">      if (sqlValidatorTable != null) {</span>
<span class="nc" id="L3593">        Table table = sqlValidatorTable.table();</span>
<span class="nc" id="L3594">        String column = Util.last(identifier.names);</span>

<span class="nc bnc" id="L3596" title="All 2 branches missed.">        if (table.isRolledUp(column)) {</span>
<span class="nc" id="L3597">          throw newValidationError(identifier,</span>
<span class="nc" id="L3598">              RESOURCE.rolledUpNotAllowed(column, &quot;USING&quot;));</span>
        }
      }
    }
<span class="nc" id="L3602">  }</span>

  protected void validateJoin(SqlJoin join, SqlValidatorScope scope) {
<span class="nc" id="L3605">    final SqlNode left = join.getLeft();</span>
<span class="nc" id="L3606">    final SqlNode right = join.getRight();</span>
<span class="nc" id="L3607">    final boolean natural = join.isNatural();</span>
<span class="nc" id="L3608">    final JoinType joinType = join.getJoinType();</span>
<span class="nc" id="L3609">    final JoinConditionType conditionType = join.getConditionType();</span>
<span class="nc" id="L3610">    final SqlValidatorScope joinScope = getScopeOrThrow(join); // getJoinScope?</span>
<span class="nc" id="L3611">    validateFrom(left, unknownType, joinScope);</span>
<span class="nc" id="L3612">    validateFrom(right, unknownType, joinScope);</span>

    // Validate condition.
<span class="nc bnc" id="L3615" title="All 4 branches missed.">    switch (conditionType) {</span>
    case NONE:
<span class="nc bnc" id="L3617" title="All 2 branches missed.">      checkArgument(join.getCondition() == null);</span>
<span class="nc" id="L3618">      break;</span>
    case ON:
<span class="nc" id="L3620">      final SqlNode condition = expand(getCondition(join), joinScope);</span>
<span class="nc" id="L3621">      join.setOperand(5, condition);</span>
<span class="nc" id="L3622">      validateWhereOrOn(joinScope, condition, &quot;ON&quot;);</span>
<span class="nc" id="L3623">      checkRollUp(null, join, condition, joinScope, &quot;ON&quot;);</span>
<span class="nc" id="L3624">      break;</span>
    case USING:
<span class="nc" id="L3626">      @SuppressWarnings({&quot;rawtypes&quot;, &quot;unchecked&quot;}) List&lt;SqlIdentifier&gt; list =</span>
<span class="nc" id="L3627">          (List) getCondition(join);</span>

      // Parser ensures that using clause is not empty.
<span class="nc bnc" id="L3630" title="All 2 branches missed.">      checkArgument(!list.isEmpty(), &quot;Empty USING clause&quot;);</span>
<span class="nc bnc" id="L3631" title="All 2 branches missed.">      for (SqlIdentifier id : list) {</span>
<span class="nc" id="L3632">        validateCommonJoinColumn(id, left, right, scope, natural);</span>
<span class="nc" id="L3633">      }</span>
<span class="nc" id="L3634">      break;</span>
    default:
<span class="nc" id="L3636">      throw Util.unexpected(conditionType);</span>
    }

    // Validate NATURAL.
<span class="nc bnc" id="L3640" title="All 2 branches missed.">    if (natural) {</span>
<span class="nc bnc" id="L3641" title="All 2 branches missed.">      if (join.getCondition() != null) {</span>
<span class="nc" id="L3642">        throw newValidationError(getCondition(join),</span>
<span class="nc" id="L3643">            RESOURCE.naturalDisallowsOnOrUsing());</span>
      }

      // Join on fields that occur on each side.
      // Check compatibility of the chosen columns.
<span class="nc bnc" id="L3648" title="All 2 branches missed.">      for (String name : deriveNaturalJoinColumnList(join)) {</span>
<span class="nc" id="L3649">        final SqlIdentifier id =</span>
<span class="nc" id="L3650">            new SqlIdentifier(name, join.isNaturalNode().getParserPosition());</span>
<span class="nc" id="L3651">        validateCommonJoinColumn(id, left, right, scope, natural);</span>
<span class="nc" id="L3652">      }</span>
    }

    // Which join types require/allow a ON/USING condition, or allow
    // a NATURAL keyword?
<span class="nc bnc" id="L3657" title="All 5 branches missed.">    switch (joinType) {</span>
    case LEFT_ANTI_JOIN:
    case LEFT_SEMI_JOIN:
<span class="nc bnc" id="L3660" title="All 2 branches missed.">      if (!this.config.conformance().isLiberal()) {</span>
<span class="nc" id="L3661">        throw newValidationError(join.getJoinTypeNode(),</span>
<span class="nc" id="L3662">            RESOURCE.dialectDoesNotSupportFeature(joinType.name()));</span>
      }
      // fall through
    case INNER:
    case LEFT:
    case RIGHT:
    case FULL:
<span class="nc bnc" id="L3669" title="All 4 branches missed.">      if ((join.getCondition() == null) &amp;&amp; !natural) {</span>
<span class="nc" id="L3670">        throw newValidationError(join, RESOURCE.joinRequiresCondition());</span>
      }
      break;
    case COMMA:
    case CROSS:
<span class="nc bnc" id="L3675" title="All 2 branches missed.">      if (join.getCondition() != null) {</span>
<span class="nc" id="L3676">        throw newValidationError(join.getConditionTypeNode(),</span>
<span class="nc" id="L3677">            RESOURCE.crossJoinDisallowsCondition());</span>
      }
<span class="nc bnc" id="L3679" title="All 2 branches missed.">      if (natural) {</span>
<span class="nc" id="L3680">        throw newValidationError(join.getConditionTypeNode(),</span>
<span class="nc" id="L3681">            RESOURCE.crossJoinDisallowsCondition());</span>
      }
      break;
    case LEFT_ASOF:
    case ASOF: {
      // In addition to the standard join checks, the ASOF join requires the
      // ON conditions to be a conjunction of simple equalities from both relations.
<span class="nc" id="L3688">      SqlAsofJoin asof = (SqlAsofJoin) join;</span>
<span class="nc" id="L3689">      SqlNode matchCondition = getMatchCondition(asof);</span>
<span class="nc" id="L3690">      matchCondition = expand(matchCondition, joinScope);</span>
<span class="nc" id="L3691">      join.setOperand(6, matchCondition);</span>
<span class="nc" id="L3692">      validateWhereOrOn(joinScope, matchCondition, &quot;MATCH_CONDITION&quot;);</span>
<span class="nc" id="L3693">      SqlNode condition = join.getCondition();</span>
<span class="nc bnc" id="L3694" title="All 2 branches missed.">      if (condition == null) {</span>
<span class="nc" id="L3695">        throw newValidationError(join, RESOURCE.joinRequiresCondition());</span>
      }
<span class="nc" id="L3697">      ConjunctionOfEqualities conj = new ConjunctionOfEqualities();</span>
<span class="nc" id="L3698">      condition.accept(conj);</span>
<span class="nc bnc" id="L3699" title="All 2 branches missed.">      if (conj.illegal) {</span>
<span class="nc" id="L3700">        throw newValidationError(condition, RESOURCE.asofConditionMustBeComparison());</span>
      }

<span class="nc" id="L3703">      CompareFromBothSides validateCompare =</span>
          new CompareFromBothSides(joinScope,
<span class="nc" id="L3705">              catalogReader, RESOURCE.asofConditionMustBeComparison());</span>
<span class="nc" id="L3706">      condition.accept(validateCompare);</span>

      // It also requires the MATCH condition to be a comparison.
<span class="nc bnc" id="L3709" title="All 2 branches missed.">      if (!(matchCondition instanceof SqlCall)) {</span>
<span class="nc" id="L3710">        throw newValidationError(matchCondition, RESOURCE.asofMatchMustBeComparison());</span>
      }
<span class="nc" id="L3712">      SqlCall matchCall = (SqlCall) matchCondition;</span>
<span class="nc" id="L3713">      SqlOperator operator = matchCall.getOperator();</span>
<span class="nc bnc" id="L3714" title="All 2 branches missed.">      if (!SqlKind.ORDER_COMPARISON.contains(operator.kind)) {</span>
<span class="nc" id="L3715">        throw newValidationError(matchCondition, RESOURCE.asofMatchMustBeComparison());</span>
      }

      // Change the exception in validateCompare when we validate the match condition
<span class="nc" id="L3719">      validateCompare =</span>
          new CompareFromBothSides(joinScope,
<span class="nc" id="L3721">              catalogReader, RESOURCE.asofMatchMustBeComparison());</span>
<span class="nc" id="L3722">      matchCondition.accept(validateCompare);</span>
<span class="nc" id="L3723">      break;</span>
    }
    default:
<span class="nc" id="L3726">      throw Util.unexpected(joinType);</span>
    }
<span class="nc" id="L3728">  }</span>

  /**
   * Shuttle which determines whether all SqlCalls that are
   * comparisons are comparing columns from both namespaces.
   * The shuttle will throw an exception if that happens.
   * If it returns all SqlCalls have the expected shape.
   */
<span class="nc" id="L3736">  private class CompareFromBothSides extends SqlShuttle {</span>
    final SqlValidatorScope scope;
    final SqlValidatorCatalogReader catalogReader;
    final Resources.ExInst&lt;SqlValidatorException&gt; exception;

    private CompareFromBothSides(
        SqlValidatorScope scope,
        SqlValidatorCatalogReader catalogReader,
<span class="nc" id="L3744">        Resources.ExInst&lt;SqlValidatorException&gt; exception) {</span>
<span class="nc" id="L3745">      this.scope = scope;</span>
<span class="nc" id="L3746">      this.catalogReader = catalogReader;</span>
<span class="nc" id="L3747">      this.exception = exception;</span>
<span class="nc" id="L3748">    }</span>

    @Override public @Nullable SqlNode visit(final SqlCall call) {
<span class="nc" id="L3751">      SqlKind kind = call.getKind();</span>
<span class="nc bnc" id="L3752" title="All 2 branches missed.">      if (SqlKind.COMPARISON.contains(kind)) {</span>
<span class="nc bnc" id="L3753" title="All 2 branches missed.">        assert call.getOperandList().size() == 2;</span>

<span class="nc" id="L3755">        boolean leftFound = false;</span>
<span class="nc" id="L3756">        boolean rightFound = false;</span>
        // The two sides of the comparison must be from different tables
<span class="nc bnc" id="L3758" title="All 2 branches missed.">        for (SqlNode operand : call.getOperandList()) {</span>
<span class="nc bnc" id="L3759" title="All 2 branches missed.">          if (!(operand instanceof SqlIdentifier)) {</span>
<span class="nc" id="L3760">            throw newValidationError(call, this.exception);</span>
          }
          // We know that all identifiers have been expanded by the caller,
          // so they have the shape namespace.field
<span class="nc" id="L3764">          SqlIdentifier id = (SqlIdentifier) operand;</span>
<span class="nc" id="L3765">          final SqlNameMatcher nameMatcher = catalogReader.nameMatcher();</span>
<span class="nc" id="L3766">          final SqlValidatorScope.ResolvedImpl resolved = new SqlValidatorScope.ResolvedImpl();</span>
          // Lookup just the first component of the name
<span class="nc" id="L3768">          scope.resolve(id.names.subList(0, id.names.size() - 1), nameMatcher, false, resolved);</span>
<span class="nc" id="L3769">          SqlValidatorScope.Resolve resolve = resolved.only();</span>
<span class="nc" id="L3770">          int index = resolve.path.steps().get(0).i;</span>
<span class="nc bnc" id="L3771" title="All 2 branches missed.">          if (index == 0) {</span>
<span class="nc" id="L3772">            leftFound = true;</span>
          }
<span class="nc bnc" id="L3774" title="All 2 branches missed.">          if (index == 1) {</span>
<span class="nc" id="L3775">            rightFound = true;</span>
          }

<span class="nc bnc" id="L3778" title="All 4 branches missed.">          if (!leftFound &amp;&amp; !rightFound) {</span>
<span class="nc" id="L3779">            throw newValidationError(call, this.exception);</span>
          }
<span class="nc" id="L3781">        }</span>
<span class="nc bnc" id="L3782" title="All 4 branches missed.">        if (!leftFound || !rightFound) {</span>
          // The comparison does not look at both tables
<span class="nc" id="L3784">          throw newValidationError(call, this.exception);</span>
        }
      }
<span class="nc" id="L3787">      return super.visit(call);</span>
    }
  }

  /**
   * Shuttle which determines whether an expression is a simple conjunction
   * of equalities. */
<span class="nc" id="L3794">  private static class ConjunctionOfEqualities extends SqlShuttle {</span>
<span class="nc" id="L3795">    boolean illegal = false;</span>

    // Check an AND node.  Children can be AND nodes or EQUAL nodes.
    void checkAnd(SqlCall call) {
      // This doesn't seem to use the visitor pattern,
      // because we recurse explicitly on the tree structure.
      // The visitor is useful to make sure no other kinds of operations
      // appear in the expression tree.
<span class="nc" id="L3803">      List&lt;SqlNode&gt; operands = call.getOperandList();</span>
<span class="nc bnc" id="L3804" title="All 2 branches missed.">      for (SqlNode operand : operands) {</span>
<span class="nc bnc" id="L3805" title="All 2 branches missed.">        if (operand.getKind() == SqlKind.AND) {</span>
<span class="nc" id="L3806">          this.checkAnd((SqlCall) operand);</span>
<span class="nc" id="L3807">          return;</span>
        }
<span class="nc bnc" id="L3809" title="All 2 branches missed.">        if (operand.getKind() != SqlKind.EQUALS) {</span>
<span class="nc" id="L3810">          illegal = true;</span>
        }
<span class="nc" id="L3812">      }</span>
<span class="nc" id="L3813">    }</span>

    @Override public @Nullable SqlNode visit(final org.apache.calcite.sql.SqlCall call) {
<span class="nc" id="L3816">      SqlKind kind = call.getKind();</span>
<span class="nc bnc" id="L3817" title="All 4 branches missed.">      if (kind != SqlKind.AND &amp;&amp; kind != SqlKind.EQUALS) {</span>
<span class="nc" id="L3818">        illegal = true;</span>
      }
<span class="nc bnc" id="L3820" title="All 2 branches missed.">      if (kind == SqlKind.AND) {</span>
<span class="nc" id="L3821">        this.checkAnd(call);</span>
      }
<span class="nc" id="L3823">      return super.visit(call);</span>
    }
  }

  /**
   * Throws an error if there is an aggregate or windowed aggregate in the
   * given clause.
   *
   * @param aggFinder Finder for the particular kind(s) of aggregate function
   * @param node      Parse tree
   * @param clause    Name of clause: &quot;WHERE&quot;, &quot;GROUP BY&quot;, &quot;ON&quot;
   */
  private void validateNoAggs(AggFinder aggFinder, SqlNode node,
      String clause) {
<span class="nc" id="L3837">    final SqlCall agg = aggFinder.findAgg(node);</span>
<span class="nc bnc" id="L3838" title="All 2 branches missed.">    if (agg == null) {</span>
<span class="nc" id="L3839">      return;</span>
    }
<span class="nc" id="L3841">    final SqlOperator op = agg.getOperator();</span>
<span class="nc bnc" id="L3842" title="All 2 branches missed.">    if (op == SqlStdOperatorTable.OVER) {</span>
<span class="nc" id="L3843">      throw newValidationError(agg,</span>
<span class="nc" id="L3844">          RESOURCE.windowedAggregateIllegalInClause(clause));</span>
<span class="nc bnc" id="L3845" title="All 4 branches missed.">    } else if (op.isGroup() || op.isGroupAuxiliary()) {</span>
<span class="nc" id="L3846">      throw newValidationError(agg,</span>
<span class="nc" id="L3847">          RESOURCE.groupFunctionMustAppearInGroupByClause(op.getName()));</span>
    } else {
<span class="nc" id="L3849">      throw newValidationError(agg,</span>
<span class="nc" id="L3850">          RESOURCE.aggregateIllegalInClause(clause));</span>
    }
  }

  /** Validates a column in a USING clause, or an inferred join key in a NATURAL join. */
  private void validateCommonJoinColumn(SqlIdentifier id, SqlNode left,
      SqlNode right, SqlValidatorScope scope, boolean natural) {
<span class="nc bnc" id="L3857" title="All 2 branches missed.">    if (id.names.size() != 1) {</span>
<span class="nc" id="L3858">      throw newValidationError(id, RESOURCE.columnNotFound(id.toString()));</span>
    }

<span class="nc bnc" id="L3861" title="All 2 branches missed.">    final RelDataType leftColType = natural</span>
<span class="nc" id="L3862">        ? checkAndDeriveDataType(id, left)</span>
<span class="nc" id="L3863">        : validateCommonInputJoinColumn(id, left, scope, natural);</span>
<span class="nc" id="L3864">    final RelDataType rightColType = validateCommonInputJoinColumn(id, right, scope, natural);</span>
<span class="nc bnc" id="L3865" title="All 2 branches missed.">    if (!SqlTypeUtil.isComparable(leftColType, rightColType)) {</span>
<span class="nc" id="L3866">      throw newValidationError(id,</span>
<span class="nc" id="L3867">          RESOURCE.naturalOrUsingColumnNotCompatible(id.getSimple(),</span>
<span class="nc" id="L3868">              leftColType.toString(), rightColType.toString()));</span>
    }
<span class="nc" id="L3870">  }</span>

  private RelDataType checkAndDeriveDataType(SqlIdentifier id, SqlNode node) {
<span class="nc bnc" id="L3873" title="All 2 branches missed.">    checkArgument(id.names.size() == 1);</span>
<span class="nc" id="L3874">    String name = id.names.get(0);</span>
<span class="nc" id="L3875">    SqlNameMatcher nameMatcher = getCatalogReader().nameMatcher();</span>
<span class="nc" id="L3876">    RelDataType rowType = getNamespaceOrThrow(node).getRowType();</span>
<span class="nc" id="L3877">    final RelDataTypeField field =</span>
<span class="nc" id="L3878">        requireNonNull(nameMatcher.field(rowType, name),</span>
<span class="nc" id="L3879">            () -&gt; &quot;unable to find left field &quot; + name + &quot; in &quot; + rowType);</span>
<span class="nc" id="L3880">    return field.getType();</span>
  }

  /** Validates a column in a USING clause, or an inferred join key in a
   * NATURAL join, in the left or right input to the join. */
  private RelDataType validateCommonInputJoinColumn(SqlIdentifier id,
      SqlNode leftOrRight, SqlValidatorScope scope, boolean natural) {
<span class="nc bnc" id="L3887" title="All 2 branches missed.">    checkArgument(id.names.size() == 1);</span>
<span class="nc" id="L3888">    final String name = id.names.get(0);</span>
<span class="nc" id="L3889">    final SqlValidatorNamespace namespace = getNamespaceOrThrow(leftOrRight);</span>
<span class="nc" id="L3890">    final RelDataType rowType = namespace.getRowType();</span>
<span class="nc" id="L3891">    final SqlNameMatcher nameMatcher = catalogReader.nameMatcher();</span>
<span class="nc" id="L3892">    final RelDataTypeField field = nameMatcher.field(rowType, name);</span>
<span class="nc bnc" id="L3893" title="All 2 branches missed.">    if (field == null) {</span>
<span class="nc" id="L3894">      throw newValidationError(id, RESOURCE.columnNotFound(name));</span>
    }
    Collection&lt;RelDataType&gt; rowTypes;
<span class="nc bnc" id="L3897" title="All 4 branches missed.">    if (!natural &amp;&amp; rowType instanceof RelCrossType) {</span>
<span class="nc" id="L3898">      final RelCrossType crossType = (RelCrossType) rowType;</span>
<span class="nc" id="L3899">      rowTypes = new ArrayList&lt;&gt;(crossType.getTypes());</span>
<span class="nc" id="L3900">    } else {</span>
<span class="nc" id="L3901">      rowTypes = Collections.singleton(rowType);</span>
    }
<span class="nc bnc" id="L3903" title="All 2 branches missed.">    for (RelDataType rowType0 : rowTypes) {</span>
<span class="nc bnc" id="L3904" title="All 2 branches missed.">      if (nameMatcher.frequency(rowType0.getFieldNames(), name) &gt; 1) {</span>
<span class="nc" id="L3905">        throw newValidationError(id, RESOURCE.columnInUsingNotUnique(name));</span>
      }
<span class="nc" id="L3907">    }</span>
<span class="nc" id="L3908">    checkRollUpInUsing(id, leftOrRight, scope);</span>
<span class="nc" id="L3909">    return field.getType();</span>
  }

  /**
   * Validates a SELECT statement.
   *
   * @param select        Select statement
   * @param targetRowType Desired row type, must not be null, may be the data
   *                      type 'unknown'.
   */
  protected void validateSelect(
      SqlSelect select,
      RelDataType targetRowType) {
<span class="nc" id="L3922">    requireNonNull(targetRowType, &quot;targetRowType&quot;);</span>

    // Namespace is either a select namespace or a wrapper around one.
<span class="nc" id="L3925">    final SelectNamespace ns =</span>
<span class="nc" id="L3926">        getNamespaceOrThrow(select).unwrap(SelectNamespace.class);</span>

    // Its rowtype is null, meaning it hasn't been validated yet.
    // This is important, because we need to take the targetRowType into
    // account.
<span class="nc bnc" id="L3931" title="All 2 branches missed.">    assert ns.rowType == null;</span>

<span class="nc" id="L3933">    SqlNode distinctNode = select.getModifierNode(SqlSelectKeyword.DISTINCT);</span>
<span class="nc bnc" id="L3934" title="All 2 branches missed.">    if (distinctNode != null) {</span>
<span class="nc" id="L3935">      validateFeature(RESOURCE.sQLFeature_E051_01(),</span>
          distinctNode
<span class="nc" id="L3937">              .getParserPosition());</span>
    }

<span class="nc" id="L3940">    final SqlNodeList selectItems = SqlNonNullableAccessors.getSelectList(select);</span>
<span class="nc" id="L3941">    RelDataType fromType = unknownType;</span>
<span class="nc bnc" id="L3942" title="All 2 branches missed.">    if (selectItems.size() == 1) {</span>
<span class="nc" id="L3943">      final SqlNode selectItem = selectItems.get(0);</span>
<span class="nc bnc" id="L3944" title="All 2 branches missed.">      if (selectItem instanceof SqlIdentifier) {</span>
<span class="nc" id="L3945">        SqlIdentifier id = (SqlIdentifier) selectItem;</span>
<span class="nc bnc" id="L3946" title="All 4 branches missed.">        if (id.isStar() &amp;&amp; (id.names.size() == 1)) {</span>
          // Special case: for INSERT ... VALUES(?,?), the SQL
          // standard says we're supposed to propagate the target
          // types down.  So iff the select list is an unqualified
          // star (as it will be after an INSERT ... VALUES has been
          // expanded), then propagate.
<span class="nc" id="L3952">          fromType = targetRowType;</span>
        }
      }
    }

    // Make sure that items in FROM clause have distinct aliases.
<span class="nc" id="L3958">    final SelectScope fromScope = (SelectScope) getFromScope(select);</span>
<span class="nc" id="L3959">    List&lt;@Nullable String&gt; names = fromScope.getChildNames();</span>
<span class="nc bnc" id="L3960" title="All 2 branches missed.">    if (!catalogReader.nameMatcher().isCaseSensitive()) {</span>
      //noinspection RedundantTypeArguments
<span class="nc" id="L3962">      names = names.stream()</span>
<span class="nc bnc" id="L3963" title="All 2 branches missed.">          .&lt;@Nullable String&gt;map(s -&gt; s == null ? null : s.toUpperCase(Locale.ROOT))</span>
<span class="nc" id="L3964">          .collect(Collectors.toList());</span>
    }
<span class="nc" id="L3966">    final int duplicateAliasOrdinal = Util.firstDuplicate(names);</span>
<span class="nc bnc" id="L3967" title="All 2 branches missed.">    if (duplicateAliasOrdinal &gt;= 0) {</span>
<span class="nc" id="L3968">      final ScopeChild child =</span>
<span class="nc" id="L3969">          fromScope.children.get(duplicateAliasOrdinal);</span>
<span class="nc" id="L3970">      throw newValidationError(</span>
<span class="nc" id="L3971">          requireNonNull(</span>
<span class="nc" id="L3972">              child.namespace.getEnclosingNode(),</span>
<span class="nc" id="L3973">              () -&gt; &quot;enclosingNode of namespace of &quot; + child.name),</span>
<span class="nc" id="L3974">          RESOURCE.fromAliasDuplicate(child.name));</span>
    }

<span class="nc" id="L3977">    final SqlNode from = select.getFrom();</span>
<span class="nc bnc" id="L3978" title="All 2 branches missed.">    if (from == null) {</span>
<span class="nc bnc" id="L3979" title="All 2 branches missed.">      if (this.config.conformance().isFromRequired()) {</span>
<span class="nc" id="L3980">        throw newValidationError(select, RESOURCE.selectMissingFrom());</span>
      }
    } else {
<span class="nc" id="L3983">      validateFrom(from, fromType, fromScope);</span>
    }

<span class="nc" id="L3986">    validateWhereClause(select);</span>
<span class="nc" id="L3987">    validateGroupClause(select);</span>
<span class="nc" id="L3988">    validateHavingClause(select);</span>
<span class="nc" id="L3989">    validateWindowClause(select);</span>
<span class="nc" id="L3990">    validateQualifyClause(select);</span>
<span class="nc" id="L3991">    handleOffsetFetch(select.getOffset(), select.getFetch());</span>

    // Validate the SELECT clause late, because a select item might
    // depend on the GROUP BY list, or the window function might reference
    // window name in the WINDOW clause etc.
<span class="nc" id="L3996">    final RelDataType rowType =</span>
<span class="nc" id="L3997">        validateSelectList(selectItems, select, targetRowType);</span>
<span class="nc" id="L3998">    ns.setType(rowType);</span>

    // Deduce which columns must be filtered.
<span class="nc" id="L4001">    ns.mustFilterFields = ImmutableBitSet.of();</span>
<span class="nc bnc" id="L4002" title="All 2 branches missed.">    if (from != null) {</span>
<span class="nc" id="L4003">      final Set&lt;SqlQualified&gt; qualifieds = new LinkedHashSet&lt;&gt;();</span>
<span class="nc bnc" id="L4004" title="All 2 branches missed.">      for (ScopeChild child : fromScope.children) {</span>
<span class="nc" id="L4005">        final List&lt;String&gt; fieldNames =</span>
<span class="nc" id="L4006">            child.namespace.getRowType().getFieldNames();</span>
<span class="nc" id="L4007">        child.namespace.getMustFilterFields()</span>
<span class="nc" id="L4008">            .forEachInt(i -&gt;</span>
<span class="nc" id="L4009">                qualifieds.add(</span>
<span class="nc" id="L4010">                    SqlQualified.create(fromScope, 1, child.namespace,</span>
                        new SqlIdentifier(
<span class="nc" id="L4012">                            ImmutableList.of(child.name, fieldNames.get(i)),</span>
                            SqlParserPos.ZERO))));
<span class="nc" id="L4014">      }</span>
<span class="nc bnc" id="L4015" title="All 2 branches missed.">      if (!qualifieds.isEmpty()) {</span>
<span class="nc bnc" id="L4016" title="All 2 branches missed.">        if (select.getWhere() != null) {</span>
<span class="nc" id="L4017">          forEachQualified(select.getWhere(), getWhereScope(select),</span>
<span class="nc" id="L4018">              qualifieds::remove);</span>
        }
<span class="nc bnc" id="L4020" title="All 2 branches missed.">        if (select.getHaving() != null) {</span>
<span class="nc" id="L4021">          forEachQualified(select.getHaving(), getHavingScope(select),</span>
<span class="nc" id="L4022">              qualifieds::remove);</span>
        }

        // Each of the must-filter fields identified must be returned as a
        // SELECT item, which is then flagged as must-filter.
<span class="nc" id="L4027">        final BitSet mustFilterFields = new BitSet();</span>
<span class="nc" id="L4028">        final List&lt;SqlNode&gt; expandedSelectItems =</span>
<span class="nc" id="L4029">            requireNonNull(fromScope.getExpandedSelectList(),</span>
                &quot;expandedSelectList&quot;);
<span class="nc" id="L4031">        forEach(expandedSelectItems, (selectItem, i) -&gt; {</span>
<span class="nc" id="L4032">          selectItem = stripAs(selectItem);</span>
<span class="nc bnc" id="L4033" title="All 2 branches missed.">          if (selectItem instanceof SqlIdentifier) {</span>
<span class="nc" id="L4034">            SqlQualified qualified =</span>
<span class="nc" id="L4035">                fromScope.fullyQualify((SqlIdentifier) selectItem);</span>
<span class="nc bnc" id="L4036" title="All 2 branches missed.">            if (qualifieds.remove(qualified)) {</span>
              // SELECT item #i referenced a must-filter column that was not
              // filtered in the WHERE or HAVING. It becomes a must-filter
              // column for our consumer.
<span class="nc" id="L4040">              mustFilterFields.set(i);</span>
            }
          }
<span class="nc" id="L4043">        });</span>

        // If there are must-filter fields that are not in the SELECT clause,
        // this is an error.
<span class="nc bnc" id="L4047" title="All 2 branches missed.">        if (!qualifieds.isEmpty()) {</span>
<span class="nc" id="L4048">          throw newValidationError(select,</span>
<span class="nc" id="L4049">              RESOURCE.mustFilterFieldsMissing(</span>
<span class="nc" id="L4050">                  qualifieds.stream()</span>
<span class="nc" id="L4051">                      .map(q -&gt; q.suffix().get(0))</span>
<span class="nc" id="L4052">                      .collect(Collectors.toCollection(TreeSet::new))</span>
<span class="nc" id="L4053">                      .toString()));</span>
        }
<span class="nc" id="L4055">        ns.mustFilterFields = ImmutableBitSet.fromBitSet(mustFilterFields);</span>
      }
    }

    // Validate ORDER BY after we have set ns.rowType because in some
    // dialects you can refer to columns of the select list, e.g.
    // &quot;SELECT empno AS x FROM emp ORDER BY x&quot;
<span class="nc" id="L4062">    validateOrderList(select);</span>

<span class="nc bnc" id="L4064" title="All 2 branches missed.">    if (shouldCheckForRollUp(from)) {</span>
<span class="nc" id="L4065">      checkRollUpInSelectList(select);</span>
<span class="nc" id="L4066">      checkRollUp(null, select, select.getWhere(), getWhereScope(select));</span>
<span class="nc" id="L4067">      checkRollUp(null, select, select.getHaving(), getHavingScope(select));</span>
<span class="nc" id="L4068">      checkRollUpInWindowDecl(select);</span>
<span class="nc" id="L4069">      checkRollUpInGroupBy(select);</span>
<span class="nc" id="L4070">      checkRollUpInOrderBy(select);</span>
    }
<span class="nc" id="L4072">  }</span>

  /** For each identifier in an expression, resolves it to a qualified name
   * and calls the provided action. */
  private static void forEachQualified(SqlNode node, SqlValidatorScope scope,
      Consumer&lt;SqlQualified&gt; consumer) {
<span class="nc" id="L4078">    node.accept(new SqlBasicVisitor&lt;Void&gt;() {</span>
      @Override public Void visit(SqlIdentifier id) {
<span class="nc" id="L4080">        final SqlQualified qualified = scope.fullyQualify(id);</span>
<span class="nc" id="L4081">        consumer.accept(qualified);</span>
<span class="nc" id="L4082">        return null;</span>
      }
    });
<span class="nc" id="L4085">  }</span>

  private void checkRollUpInSelectList(SqlSelect select) {
<span class="nc" id="L4088">    SqlValidatorScope scope = getSelectScope(select);</span>
<span class="nc bnc" id="L4089" title="All 2 branches missed.">    for (SqlNode item : SqlNonNullableAccessors.getSelectList(select)) {</span>
<span class="nc bnc" id="L4090" title="All 2 branches missed.">      if (SqlValidatorUtil.isMeasure(item)) {</span>
<span class="nc" id="L4091">        continue;</span>
      }
<span class="nc" id="L4093">      checkRollUp(null, select, item, scope);</span>
<span class="nc" id="L4094">    }</span>
<span class="nc" id="L4095">  }</span>

  private void checkRollUpInGroupBy(SqlSelect select) {
<span class="nc" id="L4098">    SqlNodeList group = select.getGroup();</span>
<span class="nc bnc" id="L4099" title="All 2 branches missed.">    if (group != null) {</span>
<span class="nc bnc" id="L4100" title="All 2 branches missed.">      for (SqlNode node : group) {</span>
<span class="nc" id="L4101">        checkRollUp(null, select, node, getGroupScope(select), &quot;GROUP BY&quot;);</span>
<span class="nc" id="L4102">      }</span>
    }
<span class="nc" id="L4104">  }</span>

  private void checkRollUpInOrderBy(SqlSelect select) {
<span class="nc" id="L4107">    SqlNodeList orderList = select.getOrderList();</span>
<span class="nc bnc" id="L4108" title="All 2 branches missed.">    if (orderList != null) {</span>
<span class="nc bnc" id="L4109" title="All 2 branches missed.">      for (SqlNode node : orderList) {</span>
<span class="nc" id="L4110">        checkRollUp(null, select, node, getOrderScope(select), &quot;ORDER BY&quot;);</span>
<span class="nc" id="L4111">      }</span>
    }
<span class="nc" id="L4113">  }</span>

  private void checkRollUpInWindow(@Nullable SqlWindow window, SqlValidatorScope scope) {
<span class="nc bnc" id="L4116" title="All 2 branches missed.">    if (window != null) {</span>
<span class="nc bnc" id="L4117" title="All 2 branches missed.">      for (SqlNode node : window.getPartitionList()) {</span>
<span class="nc" id="L4118">        checkRollUp(null, window, node, scope, &quot;PARTITION BY&quot;);</span>
<span class="nc" id="L4119">      }</span>

<span class="nc bnc" id="L4121" title="All 2 branches missed.">      for (SqlNode node : window.getOrderList()) {</span>
<span class="nc" id="L4122">        checkRollUp(null, window, node, scope, &quot;ORDER BY&quot;);</span>
<span class="nc" id="L4123">      }</span>
    }
<span class="nc" id="L4125">  }</span>

  private void checkRollUpInWindowDecl(SqlSelect select) {
<span class="nc bnc" id="L4128" title="All 2 branches missed.">    for (SqlNode decl : select.getWindowList()) {</span>
<span class="nc" id="L4129">      checkRollUpInWindow((SqlWindow) decl, getSelectScope(select));</span>
<span class="nc" id="L4130">    }</span>
<span class="nc" id="L4131">  }</span>

  /**
   * If the {@code node} is a DOT call, returns its first operand. Recurse, if
   * the first operand is another DOT call.
   *
   * &lt;p&gt;In other words, it converts {@code a DOT b DOT c} to {@code a}.
   *
   * @param node The node to strip DOT
   * @return the DOT's first operand
   */
  private static SqlNode stripDot(SqlNode node) {
<span class="nc" id="L4143">    SqlNode res = node;</span>
<span class="nc bnc" id="L4144" title="All 2 branches missed.">    while (res.getKind() == SqlKind.DOT) {</span>
<span class="nc" id="L4145">      res = requireNonNull(((SqlCall) res).operand(0), &quot;operand&quot;);</span>
    }
<span class="nc" id="L4147">    return res;</span>
  }

  private void checkRollUp(@Nullable SqlNode grandParent, @Nullable SqlNode parent,
      @Nullable SqlNode current, SqlValidatorScope scope, @Nullable String contextClause) {
<span class="nc" id="L4152">    current = stripAs(current);</span>
<span class="nc bnc" id="L4153" title="All 4 branches missed.">    if (current instanceof SqlCall &amp;&amp; !(current instanceof SqlSelect)) {</span>
      // Validate OVER separately
<span class="nc" id="L4155">      checkRollUpInWindow(getWindowInOver(current), scope);</span>
<span class="nc" id="L4156">      current = stripOver(current);</span>

<span class="nc" id="L4158">      SqlNode stripDot = stripDot(current);</span>
<span class="nc bnc" id="L4159" title="All 2 branches missed.">      if (stripDot != current) {</span>
        // we stripped the field access. Recurse to this method, the DOT's operand
        // can be another SqlCall, or an SqlIdentifier.
<span class="nc" id="L4162">        checkRollUp(grandParent, parent, stripDot, scope, contextClause);</span>
<span class="nc bnc" id="L4163" title="All 2 branches missed.">      } else if (stripDot.getKind() == SqlKind.CONVERT</span>
<span class="nc bnc" id="L4164" title="All 2 branches missed.">          || stripDot.getKind() == SqlKind.TRANSLATE) {</span>
        // only need to check operand[0] for CONVERT or TRANSLATE
<span class="nc" id="L4166">        SqlNode child = ((SqlCall) stripDot).getOperandList().get(0);</span>
<span class="nc" id="L4167">        checkRollUp(parent, current, child, scope, contextClause);</span>
<span class="nc bnc" id="L4168" title="All 2 branches missed.">      } else if (stripDot.getKind() == SqlKind.LAMBDA) {</span>
        // do not need to check lambda
      } else {
<span class="nc" id="L4171">        List&lt;? extends @Nullable SqlNode&gt; children =</span>
<span class="nc" id="L4172">            ((SqlCall) stripDot).getOperandList();</span>
<span class="nc bnc" id="L4173" title="All 2 branches missed.">        for (SqlNode child : children) {</span>
<span class="nc" id="L4174">          checkRollUp(parent, current, child, scope, contextClause);</span>
<span class="nc" id="L4175">        }</span>
      }
<span class="nc bnc" id="L4177" title="All 2 branches missed.">    } else if (current instanceof SqlIdentifier) {</span>
<span class="nc" id="L4178">      SqlIdentifier id = (SqlIdentifier) current;</span>
<span class="nc bnc" id="L4179" title="All 4 branches missed.">      if (!id.isStar() &amp;&amp; isRolledUpColumn(id, scope)) {</span>
<span class="nc bnc" id="L4180" title="All 2 branches missed.">        if (!isAggregation(requireNonNull(parent, &quot;parent&quot;).getKind())</span>
<span class="nc bnc" id="L4181" title="All 2 branches missed.">            || !isRolledUpColumnAllowedInAgg(id, scope, (SqlCall) parent, grandParent)) {</span>
<span class="nc bnc" id="L4182" title="All 2 branches missed.">          String context = contextClause != null ? contextClause : parent.getKind().toString();</span>
<span class="nc" id="L4183">          throw newValidationError(id,</span>
<span class="nc" id="L4184">              RESOURCE.rolledUpNotAllowed(SqlValidatorUtil.alias(id, 0),</span>
                  context));
        }
      }
    }
<span class="nc" id="L4189">  }</span>

  private void checkRollUp(@Nullable SqlNode grandParent, SqlNode parent,
      @Nullable SqlNode current, SqlValidatorScope scope) {
<span class="nc" id="L4193">    checkRollUp(grandParent, parent, current, scope, null);</span>
<span class="nc" id="L4194">  }</span>

  private static @Nullable SqlWindow getWindowInOver(SqlNode over) {
<span class="nc bnc" id="L4197" title="All 2 branches missed.">    if (over.getKind() == SqlKind.OVER) {</span>
<span class="nc" id="L4198">      SqlNode window = ((SqlCall) over).getOperandList().get(1);</span>
<span class="nc bnc" id="L4199" title="All 2 branches missed.">      if (window instanceof SqlWindow) {</span>
<span class="nc" id="L4200">        return (SqlWindow) window;</span>
      }
      // SqlIdentifier, gets validated elsewhere
<span class="nc" id="L4203">      return null;</span>
    }
<span class="nc" id="L4205">    return null;</span>
  }

  private static SqlNode stripOver(SqlNode node) {
<span class="nc bnc" id="L4209" title="All 2 branches missed.">    switch (node.getKind()) {</span>
    case OVER:
<span class="nc" id="L4211">      return ((SqlCall) node).getOperandList().get(0);</span>
    default:
<span class="nc" id="L4213">      return node;</span>
    }
  }

  private @Nullable Pair&lt;String, String&gt; findTableColumnPair(SqlIdentifier identifier,
      SqlValidatorScope scope) {
<span class="nc" id="L4219">    final SqlCall call = makeNullaryCall(identifier);</span>
<span class="nc bnc" id="L4220" title="All 2 branches missed.">    if (call != null) {</span>
<span class="nc" id="L4221">      return null;</span>
    }
<span class="nc" id="L4223">    SqlQualified qualified = scope.fullyQualify(identifier);</span>
<span class="nc" id="L4224">    List&lt;String&gt; names = qualified.identifier.names;</span>

<span class="nc bnc" id="L4226" title="All 2 branches missed.">    if (names.size() &lt; 2) {</span>
<span class="nc" id="L4227">      return null;</span>
    }

<span class="nc" id="L4230">    return new Pair&lt;&gt;(names.get(names.size() - 2), Util.last(names));</span>
  }

  // Returns true iff the given column is valid inside the given aggCall.
  private boolean isRolledUpColumnAllowedInAgg(SqlIdentifier identifier, SqlValidatorScope scope,
      SqlCall aggCall, @Nullable SqlNode parent) {
<span class="nc" id="L4236">    Pair&lt;String, String&gt; pair = findTableColumnPair(identifier, scope);</span>

<span class="nc bnc" id="L4238" title="All 2 branches missed.">    if (pair == null) {</span>
<span class="nc" id="L4239">      return true;</span>
    }

<span class="nc" id="L4242">    String columnName = pair.right;</span>

<span class="nc" id="L4244">    Table table = resolveTable(identifier, scope);</span>
<span class="nc bnc" id="L4245" title="All 2 branches missed.">    if (table != null) {</span>
<span class="nc" id="L4246">      return table.rolledUpColumnValidInsideAgg(columnName, aggCall, parent,</span>
<span class="nc" id="L4247">          catalogReader.getConfig());</span>
    }
<span class="nc" id="L4249">    return true;</span>
  }

  private static @Nullable Table resolveTable(SqlIdentifier identifier,
      SqlValidatorScope scope) {
<span class="nc" id="L4254">    SqlQualified fullyQualified = scope.fullyQualify(identifier);</span>
<span class="nc bnc" id="L4255" title="All 2 branches missed.">    if (fullyQualified.namespace == null) {</span>
<span class="nc" id="L4256">      throw new IllegalArgumentException(&quot;namespace must not be null in &quot;</span>
          + fullyQualified);
    }
<span class="nc" id="L4259">    SqlValidatorTable sqlValidatorTable =</span>
<span class="nc" id="L4260">        fullyQualified.namespace.getTable();</span>
<span class="nc bnc" id="L4261" title="All 2 branches missed.">    if (sqlValidatorTable != null) {</span>
<span class="nc" id="L4262">      return sqlValidatorTable.table();</span>
    }
<span class="nc" id="L4264">    return null;</span>
  }


  // Returns true iff the given column is actually rolled up.
  private boolean isRolledUpColumn(SqlIdentifier identifier, SqlValidatorScope scope) {
<span class="nc" id="L4270">    Pair&lt;String, String&gt; pair = findTableColumnPair(identifier, scope);</span>

<span class="nc bnc" id="L4272" title="All 2 branches missed.">    if (pair == null) {</span>
<span class="nc" id="L4273">      return false;</span>
    }

<span class="nc" id="L4276">    String columnName = pair.right;</span>

<span class="nc" id="L4278">    Table table = resolveTable(identifier, scope);</span>
<span class="nc bnc" id="L4279" title="All 2 branches missed.">    if (table != null) {</span>
<span class="nc" id="L4280">      return table.isRolledUp(columnName);</span>
    }
<span class="nc" id="L4282">    return false;</span>
  }

  private static boolean shouldCheckForRollUp(@Nullable SqlNode from) {
<span class="nc bnc" id="L4286" title="All 2 branches missed.">    if (from != null) {</span>
<span class="nc" id="L4287">      SqlKind kind = stripAs(from).getKind();</span>
<span class="nc bnc" id="L4288" title="All 4 branches missed.">      return kind != SqlKind.VALUES &amp;&amp; kind != SqlKind.SELECT;</span>
    }
<span class="nc" id="L4290">    return false;</span>
  }

  /** Validates that a query can deliver the modality it promises. Only called
   * on the top-most SELECT or set operator in the tree. */
  private void validateModality(SqlNode query) {
<span class="nc" id="L4296">    final SqlModality modality = deduceModality(query);</span>
<span class="nc bnc" id="L4297" title="All 2 branches missed.">    if (query instanceof SqlSelect) {</span>
<span class="nc" id="L4298">      final SqlSelect select = (SqlSelect) query;</span>
<span class="nc" id="L4299">      validateModality(select, modality, true);</span>
<span class="nc bnc" id="L4300" title="All 2 branches missed.">    } else if (query.getKind() == SqlKind.VALUES) {</span>
<span class="nc bnc" id="L4301" title="All 2 branches missed.">      switch (modality) {</span>
      case STREAM:
<span class="nc" id="L4303">        throw newValidationError(query, Static.RESOURCE.cannotStreamValues());</span>
      default:
<span class="nc" id="L4305">        break;</span>
      }
    } else {
<span class="nc bnc" id="L4308" title="All 2 branches missed.">      assert query.isA(SqlKind.SET_QUERY);</span>
<span class="nc" id="L4309">      final SqlCall call = (SqlCall) query;</span>
<span class="nc bnc" id="L4310" title="All 2 branches missed.">      for (SqlNode operand : call.getOperandList()) {</span>
<span class="nc bnc" id="L4311" title="All 2 branches missed.">        if (deduceModality(operand) != modality) {</span>
<span class="nc" id="L4312">          throw newValidationError(operand,</span>
<span class="nc" id="L4313">              Static.RESOURCE.streamSetOpInconsistentInputs());</span>
        }
<span class="nc" id="L4315">        validateModality(operand);</span>
<span class="nc" id="L4316">      }</span>
    }
<span class="nc" id="L4318">  }</span>

  /** Return the intended modality of a SELECT or set-op. */
  private static SqlModality deduceModality(SqlNode query) {
<span class="nc bnc" id="L4322" title="All 2 branches missed.">    if (query instanceof SqlSelect) {</span>
<span class="nc" id="L4323">      SqlSelect select = (SqlSelect) query;</span>
<span class="nc bnc" id="L4324" title="All 2 branches missed.">      return select.getModifierNode(SqlSelectKeyword.STREAM) != null</span>
<span class="nc" id="L4325">          ? SqlModality.STREAM</span>
<span class="nc" id="L4326">          : SqlModality.RELATION;</span>
<span class="nc bnc" id="L4327" title="All 2 branches missed.">    } else if (query.getKind() == SqlKind.VALUES) {</span>
<span class="nc" id="L4328">      return SqlModality.RELATION;</span>
    } else {
<span class="nc bnc" id="L4330" title="All 2 branches missed.">      assert query.isA(SqlKind.SET_QUERY);</span>
<span class="nc" id="L4331">      final SqlCall call = (SqlCall) query;</span>
<span class="nc" id="L4332">      return deduceModality(call.getOperandList().get(0));</span>
    }
  }

  @Override public boolean validateModality(SqlSelect select, SqlModality modality,
      boolean fail) {
<span class="nc" id="L4338">    final SelectScope scope = getRawSelectScopeNonNull(select);</span>

<span class="nc bnc" id="L4340" title="All 2 branches missed.">    switch (modality) {</span>
    case STREAM:
<span class="nc bnc" id="L4342" title="All 2 branches missed.">      if (scope.children.size() == 1) {</span>
<span class="nc bnc" id="L4343" title="All 2 branches missed.">        for (ScopeChild child : scope.children) {</span>
<span class="nc bnc" id="L4344" title="All 2 branches missed.">          if (!child.namespace.supportsModality(modality)) {</span>
<span class="nc bnc" id="L4345" title="All 2 branches missed.">            if (fail) {</span>
<span class="nc" id="L4346">              SqlNode node = SqlNonNullableAccessors.getNode(child);</span>
<span class="nc" id="L4347">              throw newValidationError(node,</span>
<span class="nc" id="L4348">                  Static.RESOURCE.cannotConvertToStream(child.name));</span>
            } else {
<span class="nc" id="L4350">              return false;</span>
            }
          }
<span class="nc" id="L4353">        }</span>
      } else {
<span class="nc" id="L4355">        int supportsModalityCount = 0;</span>
<span class="nc bnc" id="L4356" title="All 2 branches missed.">        for (ScopeChild child : scope.children) {</span>
<span class="nc bnc" id="L4357" title="All 2 branches missed.">          if (child.namespace.supportsModality(modality)) {</span>
<span class="nc" id="L4358">            ++supportsModalityCount;</span>
          }
<span class="nc" id="L4360">        }</span>

<span class="nc bnc" id="L4362" title="All 2 branches missed.">        if (supportsModalityCount == 0) {</span>
<span class="nc bnc" id="L4363" title="All 2 branches missed.">          if (fail) {</span>
<span class="nc" id="L4364">            String inputs = String.join(&quot;, &quot;, scope.getChildNames());</span>
<span class="nc" id="L4365">            throw newValidationError(select,</span>
<span class="nc" id="L4366">                Static.RESOURCE.cannotStreamResultsForNonStreamingInputs(inputs));</span>
          } else {
<span class="nc" id="L4368">            return false;</span>
          }
        }
      }
<span class="nc" id="L4372">      break;</span>
    default:
<span class="nc bnc" id="L4374" title="All 2 branches missed.">      for (ScopeChild child : scope.children) {</span>
<span class="nc bnc" id="L4375" title="All 2 branches missed.">        if (!child.namespace.supportsModality(modality)) {</span>
<span class="nc bnc" id="L4376" title="All 2 branches missed.">          if (fail) {</span>
<span class="nc" id="L4377">            SqlNode node = SqlNonNullableAccessors.getNode(child);</span>
<span class="nc" id="L4378">            throw newValidationError(node,</span>
<span class="nc" id="L4379">                Static.RESOURCE.cannotConvertToRelation(child.name));</span>
          } else {
<span class="nc" id="L4381">            return false;</span>
          }
        }
<span class="nc" id="L4384">      }</span>
    }

    // Make sure that aggregation is possible.
<span class="nc" id="L4388">    final SqlNode aggregateNode = getAggregate(select);</span>
<span class="nc bnc" id="L4389" title="All 2 branches missed.">    if (aggregateNode != null) {</span>
<span class="nc bnc" id="L4390" title="All 2 branches missed.">      switch (modality) {</span>
      case STREAM:
<span class="nc" id="L4392">        SqlNodeList groupList = select.getGroup();</span>
<span class="nc bnc" id="L4393" title="All 2 branches missed.">        if (groupList == null</span>
<span class="nc bnc" id="L4394" title="All 2 branches missed.">            || !SqlValidatorUtil.containsMonotonic(scope, groupList)) {</span>
<span class="nc bnc" id="L4395" title="All 2 branches missed.">          if (fail) {</span>
<span class="nc" id="L4396">            throw newValidationError(aggregateNode,</span>
<span class="nc" id="L4397">                Static.RESOURCE.streamMustGroupByMonotonic());</span>
          } else {
<span class="nc" id="L4399">            return false;</span>
          }
        }
        break;
      default:
        break;
      }
    }

    // Make sure that ORDER BY is possible.
<span class="nc" id="L4409">    final SqlNodeList orderList  = select.getOrderList();</span>
<span class="nc bnc" id="L4410" title="All 4 branches missed.">    if (orderList != null &amp;&amp; !orderList.isEmpty()) {</span>
<span class="nc bnc" id="L4411" title="All 2 branches missed.">      switch (modality) {</span>
      case STREAM:
<span class="nc bnc" id="L4413" title="All 2 branches missed.">        if (!hasSortedPrefix(scope, orderList)) {</span>
<span class="nc bnc" id="L4414" title="All 2 branches missed.">          if (fail) {</span>
<span class="nc" id="L4415">            throw newValidationError(orderList.get(0),</span>
<span class="nc" id="L4416">                Static.RESOURCE.streamMustOrderByMonotonic());</span>
          } else {
<span class="nc" id="L4418">            return false;</span>
          }
        }
        break;
      default:
        break;
      }
    }
<span class="nc" id="L4426">    return true;</span>
  }

  /** Returns whether the prefix is sorted. */
  private static boolean hasSortedPrefix(SelectScope scope, SqlNodeList orderList) {
<span class="nc" id="L4431">    return isSortCompatible(scope, orderList.get(0), false);</span>
  }

  private static boolean isSortCompatible(SelectScope scope, SqlNode node,
      boolean descending) {
<span class="nc bnc" id="L4436" title="All 2 branches missed.">    switch (node.getKind()) {</span>
    case DESCENDING:
<span class="nc" id="L4438">      return isSortCompatible(scope, ((SqlCall) node).getOperandList().get(0),</span>
          true);
    default:
      break;
    }
<span class="nc" id="L4443">    final SqlMonotonicity monotonicity = scope.getMonotonicity(node);</span>
<span class="nc bnc" id="L4444" title="All 3 branches missed.">    switch (monotonicity) {</span>
    case INCREASING:
    case STRICTLY_INCREASING:
<span class="nc bnc" id="L4447" title="All 2 branches missed.">      return !descending;</span>
    case DECREASING:
    case STRICTLY_DECREASING:
<span class="nc" id="L4450">      return descending;</span>
    default:
<span class="nc" id="L4452">      return false;</span>
    }
  }

  @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
  protected void validateWindowClause(SqlSelect select) {
<span class="nc" id="L4458">    final SqlNodeList windowList = select.getWindowList();</span>
<span class="nc bnc" id="L4459" title="All 2 branches missed.">    if (windowList.isEmpty()) {</span>
<span class="nc" id="L4460">      return;</span>
    }

<span class="nc" id="L4463">    final SelectScope windowScope = (SelectScope) getFromScope(select);</span>

    // 1. ensure window names are simple
    // 2. ensure they are unique within this scope
<span class="nc bnc" id="L4467" title="All 2 branches missed.">    for (SqlWindow window : (List&lt;SqlWindow&gt;) (List) windowList) {</span>
<span class="nc" id="L4468">      SqlIdentifier declName =</span>
<span class="nc" id="L4469">          requireNonNull(window.getDeclName(),</span>
<span class="nc" id="L4470">              () -&gt; &quot;window.getDeclName() for &quot; + window);</span>
<span class="nc bnc" id="L4471" title="All 2 branches missed.">      if (!declName.isSimple()) {</span>
<span class="nc" id="L4472">        throw newValidationError(declName, RESOURCE.windowNameMustBeSimple());</span>
      }

<span class="nc bnc" id="L4475" title="All 2 branches missed.">      if (windowScope.existingWindowName(declName.toString())) {</span>
<span class="nc" id="L4476">        throw newValidationError(declName, RESOURCE.duplicateWindowName());</span>
      } else {
<span class="nc" id="L4478">        windowScope.addWindowName(declName.toString());</span>
      }
<span class="nc" id="L4480">    }</span>

    // 7.10 rule 2
    // Check for pairs of windows which are equivalent.
<span class="nc bnc" id="L4484" title="All 2 branches missed.">    for (int i = 0; i &lt; windowList.size(); i++) {</span>
<span class="nc" id="L4485">      SqlNode window1 = windowList.get(i);</span>
<span class="nc bnc" id="L4486" title="All 2 branches missed.">      for (int j = i + 1; j &lt; windowList.size(); j++) {</span>
<span class="nc" id="L4487">        SqlNode window2 = windowList.get(j);</span>
<span class="nc bnc" id="L4488" title="All 2 branches missed.">        if (window1.equalsDeep(window2, Litmus.IGNORE)) {</span>
<span class="nc" id="L4489">          throw newValidationError(window2, RESOURCE.dupWindowSpec());</span>
        }
      }
    }

<span class="nc bnc" id="L4494" title="All 2 branches missed.">    for (SqlWindow window : (List&lt;SqlWindow&gt;) (List) windowList) {</span>
<span class="nc" id="L4495">      final SqlNodeList expandedOrderList =</span>
<span class="nc" id="L4496">          (SqlNodeList) expand(window.getOrderList(), windowScope);</span>
<span class="nc" id="L4497">      window.setOrderList(expandedOrderList);</span>
<span class="nc" id="L4498">      expandedOrderList.validate(this, windowScope);</span>

<span class="nc" id="L4500">      final SqlNodeList expandedPartitionList =</span>
<span class="nc" id="L4501">          (SqlNodeList) expand(window.getPartitionList(), windowScope);</span>
<span class="nc" id="L4502">      window.setPartitionList(expandedPartitionList);</span>
<span class="nc" id="L4503">      expandedPartitionList.validate(this, windowScope);</span>
<span class="nc" id="L4504">    }</span>

    // Hand off to validate window spec components
<span class="nc" id="L4507">    windowList.validate(this, windowScope);</span>
<span class="nc" id="L4508">  }</span>

  protected void validateQualifyClause(SqlSelect select) {
<span class="nc" id="L4511">    SqlNode qualifyNode = select.getQualify();</span>
<span class="nc bnc" id="L4512" title="All 2 branches missed.">    if (qualifyNode == null) {</span>
<span class="nc" id="L4513">      return;</span>
    }

<span class="nc" id="L4516">    SqlValidatorScope qualifyScope = getSelectScope(select);</span>

<span class="nc" id="L4518">    qualifyNode = extendedExpand(qualifyNode, qualifyScope, select, Clause.QUALIFY);</span>
<span class="nc" id="L4519">    select.setQualify(qualifyNode);</span>

<span class="nc" id="L4521">    inferUnknownTypes(</span>
        booleanType,
        qualifyScope,
        qualifyNode);

<span class="nc" id="L4526">    qualifyNode.validate(this, qualifyScope);</span>

<span class="nc" id="L4528">    final RelDataType type = deriveType(qualifyScope, qualifyNode);</span>
<span class="nc bnc" id="L4529" title="All 2 branches missed.">    if (!SqlTypeUtil.inBooleanFamily(type)) {</span>
<span class="nc" id="L4530">      throw newValidationError(qualifyNode, RESOURCE.condMustBeBoolean(&quot;QUALIFY&quot;));</span>
    }

<span class="nc bnc" id="L4533" title="All 2 branches missed.">    boolean qualifyContainsWindowFunction = overFinder.findAgg(qualifyNode) != null;</span>
<span class="nc bnc" id="L4534" title="All 2 branches missed.">    if (!qualifyContainsWindowFunction) {</span>
<span class="nc" id="L4535">      throw newValidationError(qualifyNode,</span>
<span class="nc" id="L4536">          RESOURCE.qualifyExpressionMustContainWindowFunction(qualifyNode.toString()));</span>
    }
<span class="nc" id="L4538">  }</span>

  @Override public void validateWith(SqlWith with, SqlValidatorScope scope) {
<span class="nc" id="L4541">    final SqlValidatorNamespace namespace = getNamespaceOrThrow(with);</span>
<span class="nc" id="L4542">    validateNamespace(namespace, unknownType);</span>
<span class="nc" id="L4543">  }</span>

  @Override public void validateWithItem(SqlWithItem withItem) {
<span class="nc" id="L4546">    SqlNodeList columnList = withItem.columnList;</span>
<span class="nc bnc" id="L4547" title="All 2 branches missed.">    if (columnList != null) {</span>
<span class="nc" id="L4548">      final RelDataType rowType = getValidatedNodeType(withItem.query);</span>
<span class="nc" id="L4549">      final int fieldCount = rowType.getFieldCount();</span>
<span class="nc bnc" id="L4550" title="All 2 branches missed.">      if (columnList.size() != fieldCount) {</span>
<span class="nc" id="L4551">        throw newValidationError(columnList,</span>
<span class="nc" id="L4552">            RESOURCE.columnCountMismatch());</span>
      }
<span class="nc" id="L4554">      SqlValidatorUtil.checkIdentifierListForDuplicates(</span>
          columnList, validationErrorFunction);
<span class="nc" id="L4556">    } else {</span>
      // Luckily, field names have not been make unique yet.
<span class="nc" id="L4558">      final List&lt;String&gt; fieldNames =</span>
<span class="nc" id="L4559">          getValidatedNodeType(withItem.query).getFieldNames();</span>
<span class="nc" id="L4560">      final int i = Util.firstDuplicate(fieldNames);</span>
<span class="nc bnc" id="L4561" title="All 2 branches missed.">      if (i &gt;= 0) {</span>
<span class="nc" id="L4562">        throw newValidationError(withItem.query,</span>
<span class="nc" id="L4563">            RESOURCE.duplicateColumnAndNoColumnList(fieldNames.get(i)));</span>
      }
    }
<span class="nc" id="L4566">  }</span>

  @Override public void validateSequenceValue(SqlValidatorScope scope, SqlIdentifier id) {
    // Resolve identifier as a table.
<span class="nc" id="L4570">    final SqlValidatorScope.ResolvedImpl resolved =</span>
        new SqlValidatorScope.ResolvedImpl();
<span class="nc" id="L4572">    scope.resolveTable(id.names, catalogReader.nameMatcher(),</span>
        SqlValidatorScope.Path.EMPTY, resolved);
<span class="nc bnc" id="L4574" title="All 2 branches missed.">    if (resolved.count() != 1) {</span>
<span class="nc" id="L4575">      throw newValidationError(id, RESOURCE.tableNameNotFound(id.toString()));</span>
    }
    // We've found a table. But is it a sequence?
<span class="nc" id="L4578">    final SqlValidatorNamespace ns = resolved.only().namespace;</span>
<span class="nc bnc" id="L4579" title="All 2 branches missed.">    if (ns instanceof TableNamespace) {</span>
<span class="nc" id="L4580">      final Table table = getTable(ns).table();</span>
<span class="nc bnc" id="L4581" title="All 2 branches missed.">      switch (table.getJdbcTableType()) {</span>
      case SEQUENCE:
      case TEMPORARY_SEQUENCE:
<span class="nc" id="L4584">        return;</span>
      default:
        break;
      }
    }
<span class="nc" id="L4589">    throw newValidationError(id, RESOURCE.notASequence(id.toString()));</span>
  }

  @Override public TypeCoercion getTypeCoercion() {
<span class="nc bnc" id="L4593" title="All 2 branches missed.">    assert config.typeCoercionEnabled();</span>
<span class="nc" id="L4594">    return this.typeCoercion;</span>
  }

  @Override public Config config() {
<span class="nc" id="L4598">    return requireNonNull(this.config, &quot;config&quot;);</span>
  }

  @Override public SqlValidator transform(UnaryOperator&lt;Config&gt; transform) {
<span class="nc" id="L4602">    this.config = requireNonNull(transform.apply(this.config), &quot;config&quot;);</span>
<span class="nc" id="L4603">    return this;</span>
  }

  /**
   * Validates the ORDER BY clause of a SELECT statement.
   *
   * @param select Select statement
   */
  protected void validateOrderList(SqlSelect select) {
    // ORDER BY is validated in a scope where aliases in the SELECT clause
    // are visible. For example, &quot;SELECT empno AS x FROM emp ORDER BY x&quot;
    // is valid.
<span class="nc" id="L4615">    SqlNodeList orderList = select.getOrderList();</span>
<span class="nc bnc" id="L4616" title="All 2 branches missed.">    if (orderList == null) {</span>
<span class="nc" id="L4617">      return;</span>
    }
<span class="nc bnc" id="L4619" title="All 2 branches missed.">    if (!shouldAllowIntermediateOrderBy()) {</span>
<span class="nc bnc" id="L4620" title="All 2 branches missed.">      if (!cursorSet.contains(select)) {</span>
<span class="nc" id="L4621">        throw newValidationError(select, RESOURCE.invalidOrderByPos());</span>
      }
    }
<span class="nc" id="L4624">    final SqlValidatorScope orderScope = getOrderScope(select);</span>
<span class="nc" id="L4625">    requireNonNull(orderScope, &quot;orderScope&quot;);</span>

<span class="nc" id="L4627">    List&lt;SqlNode&gt; expandList = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L4628" title="All 2 branches missed.">    for (SqlNode orderItem : orderList) {</span>
<span class="nc" id="L4629">      SqlNode expandedOrderItem = expand(orderItem, orderScope);</span>
<span class="nc" id="L4630">      expandList.add(expandedOrderItem);</span>
<span class="nc" id="L4631">    }</span>

<span class="nc" id="L4633">    SqlNodeList expandedOrderList =</span>
<span class="nc" id="L4634">        new SqlNodeList(expandList, orderList.getParserPosition());</span>
<span class="nc" id="L4635">    select.setOrderBy(expandedOrderList);</span>

<span class="nc bnc" id="L4637" title="All 2 branches missed.">    for (SqlNode orderItem : expandedOrderList) {</span>
<span class="nc" id="L4638">      validateOrderItem(select, orderItem);</span>
<span class="nc" id="L4639">    }</span>
<span class="nc" id="L4640">  }</span>

  /**
   * Validates an item in the GROUP BY clause of a SELECT statement.
   *
   * @param select Select statement
   * @param groupByItem GROUP BY clause item
   */
  private void validateGroupByItem(SqlSelect select, SqlNode groupByItem) {
<span class="nc" id="L4649">    final SqlValidatorScope groupByScope = getGroupScope(select);</span>
<span class="nc" id="L4650">    validateGroupByExpr(groupByItem, groupByScope);</span>
<span class="nc" id="L4651">    groupByScope.validateExpr(groupByItem);</span>
<span class="nc" id="L4652">  }</span>

  private void validateGroupByExpr(SqlNode groupByItem,
      SqlValidatorScope groupByScope) {
<span class="nc bnc" id="L4656" title="All 3 branches missed.">    switch (groupByItem.getKind()) {</span>
    case GROUP_BY_DISTINCT:
<span class="nc" id="L4658">      SqlCall call = (SqlCall) groupByItem;</span>
<span class="nc bnc" id="L4659" title="All 2 branches missed.">      for (SqlNode operand : call.getOperandList()) {</span>
<span class="nc" id="L4660">        validateGroupByExpr(operand, groupByScope);</span>
<span class="nc" id="L4661">      }</span>
<span class="nc" id="L4662">      break;</span>
    case GROUPING_SETS:
    case ROLLUP:
    case CUBE:
<span class="nc" id="L4666">      call = (SqlCall) groupByItem;</span>
<span class="nc bnc" id="L4667" title="All 2 branches missed.">      for (SqlNode operand : call.getOperandList()) {</span>
<span class="nc" id="L4668">        validateExpr(operand, groupByScope);</span>
<span class="nc" id="L4669">      }</span>
<span class="nc" id="L4670">      break;</span>
    default:
<span class="nc" id="L4672">      validateExpr(groupByItem, groupByScope);</span>
    }
<span class="nc" id="L4674">  }</span>

  /**
   * Validates an item in the ORDER BY clause of a SELECT statement.
   *
   * @param select Select statement
   * @param orderItem ORDER BY clause item
   */
  private void validateOrderItem(SqlSelect select, SqlNode orderItem) {
<span class="nc bnc" id="L4683" title="All 2 branches missed.">    switch (orderItem.getKind()) {</span>
    case DESCENDING:
<span class="nc" id="L4685">      validateFeature(RESOURCE.sQLConformance_OrderByDesc(),</span>
<span class="nc" id="L4686">          orderItem.getParserPosition());</span>
<span class="nc" id="L4687">      validateOrderItem(select,</span>
<span class="nc" id="L4688">          ((SqlCall) orderItem).operand(0));</span>
<span class="nc" id="L4689">      return;</span>
    default:
      break;
    }

<span class="nc" id="L4694">    final SqlValidatorScope orderScope = getOrderScope(select);</span>
<span class="nc" id="L4695">    validateExpr(orderItem, orderScope);</span>
<span class="nc" id="L4696">  }</span>

  @Override public SqlNode expandOrderExpr(SqlSelect select, SqlNode orderExpr) {
<span class="nc" id="L4699">    final SqlNode orderExpr2 =</span>
<span class="nc" id="L4700">        new OrderExpressionExpander(select, orderExpr).go();</span>
<span class="nc bnc" id="L4701" title="All 2 branches missed.">    if (orderExpr2 == orderExpr) {</span>
<span class="nc" id="L4702">      return orderExpr2;</span>
    }

<span class="nc" id="L4705">    final SqlValidatorScope scope = getOrderScope(select);</span>
<span class="nc" id="L4706">    inferUnknownTypes(unknownType, scope, orderExpr2);</span>
<span class="nc" id="L4707">    final RelDataType type = deriveType(scope, orderExpr2);</span>
<span class="nc" id="L4708">    setValidatedNodeType(orderExpr2, type);</span>
<span class="nc bnc" id="L4709" title="All 2 branches missed.">    if (!type.isMeasure()) {</span>
<span class="nc" id="L4710">      return orderExpr2;</span>
    }

<span class="nc" id="L4713">    final SqlNode orderExpr3 = measureToValue(orderExpr2);</span>
<span class="nc" id="L4714">    final RelDataType type3 = deriveType(scope, orderExpr3);</span>
<span class="nc" id="L4715">    setValidatedNodeType(orderExpr3, type3);</span>
<span class="nc" id="L4716">    return orderExpr3;</span>
  }

  private static SqlNode measureToValue(SqlNode e) {
<span class="nc bnc" id="L4720" title="All 2 branches missed.">    if (e.getKind() == SqlKind.V2M) {</span>
<span class="nc" id="L4721">      return ((SqlCall) e).operand(0);</span>
    }
<span class="nc" id="L4723">    return SqlInternalOperators.M2V.createCall(e.getParserPosition(), e);</span>
  }

  /**
   * Validates the GROUP BY clause of a SELECT statement. This method is
   * called even if no GROUP BY clause is present.
   */
  protected void validateGroupClause(SqlSelect select) {
<span class="nc" id="L4731">    SqlNodeList groupList = select.getGroup();</span>
<span class="nc bnc" id="L4732" title="All 2 branches missed.">    if (groupList == null) {</span>
<span class="nc" id="L4733">      return;</span>
    }
<span class="nc" id="L4735">    final String clause = &quot;GROUP BY&quot;;</span>
<span class="nc" id="L4736">    validateNoAggs(aggOrOverFinder, groupList, clause);</span>
<span class="nc" id="L4737">    final SqlValidatorScope groupScope = getGroupScope(select);</span>

    // expand the expression in group list.
<span class="nc" id="L4740">    List&lt;SqlNode&gt; expandedList = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L4741" title="All 2 branches missed.">    for (SqlNode groupItem : groupList) {</span>
<span class="nc" id="L4742">      SqlNode expandedItem =</span>
<span class="nc" id="L4743">          extendedExpand(groupItem, groupScope, select, Clause.GROUP_BY);</span>
<span class="nc" id="L4744">      expandedList.add(expandedItem);</span>
<span class="nc" id="L4745">    }</span>
<span class="nc" id="L4746">    groupList = new SqlNodeList(expandedList, groupList.getParserPosition());</span>
<span class="nc" id="L4747">    select.setGroupBy(groupList);</span>
<span class="nc" id="L4748">    inferUnknownTypes(unknownType, groupScope, groupList);</span>
<span class="nc bnc" id="L4749" title="All 2 branches missed.">    for (SqlNode groupItem : expandedList) {</span>
<span class="nc" id="L4750">      validateGroupByItem(select, groupItem);</span>
<span class="nc" id="L4751">    }</span>

    // Nodes in the GROUP BY clause are expressions except if they are calls
    // to the GROUPING SETS, ROLLUP or CUBE operators; this operators are not
    // expressions, because they do not have a type.
<span class="nc bnc" id="L4756" title="All 2 branches missed.">    for (SqlNode node : groupList) {</span>
<span class="nc bnc" id="L4757" title="All 2 branches missed.">      switch (node.getKind()) {</span>
      case GROUP_BY_DISTINCT:
      case GROUPING_SETS:
      case ROLLUP:
      case CUBE:
<span class="nc" id="L4762">        node.validate(this, groupScope);</span>
<span class="nc" id="L4763">        break;</span>
      default:
<span class="nc" id="L4765">        node.validateExpr(this, groupScope);</span>
      }
<span class="nc" id="L4767">    }</span>

    // Derive the type of each GROUP BY item. We don't need the type, but
    // it resolves functions, and that is necessary for deducing
    // monotonicity.
<span class="nc" id="L4772">    final SqlValidatorScope selectScope = getSelectScope(select);</span>
<span class="nc" id="L4773">    AggregatingSelectScope aggregatingScope = null;</span>
<span class="nc bnc" id="L4774" title="All 2 branches missed.">    if (selectScope instanceof AggregatingSelectScope) {</span>
<span class="nc" id="L4775">      aggregatingScope = (AggregatingSelectScope) selectScope;</span>
    }
<span class="nc bnc" id="L4777" title="All 2 branches missed.">    for (SqlNode groupItem : groupList) {</span>
<span class="nc bnc" id="L4778" title="All 2 branches missed.">      if (groupItem instanceof SqlNodeList</span>
<span class="nc bnc" id="L4779" title="All 2 branches missed.">          &amp;&amp; ((SqlNodeList) groupItem).isEmpty()) {</span>
<span class="nc" id="L4780">        continue;</span>
      }
<span class="nc" id="L4782">      validateGroupItem(groupScope, aggregatingScope, groupItem);</span>
<span class="nc" id="L4783">    }</span>

<span class="nc" id="L4785">    SqlNode agg = aggFinder.findAgg(groupList);</span>
<span class="nc bnc" id="L4786" title="All 2 branches missed.">    if (agg != null) {</span>
<span class="nc" id="L4787">      throw newValidationError(agg, RESOURCE.aggregateIllegalInClause(clause));</span>
    }
<span class="nc" id="L4789">  }</span>

  private void validateGroupItem(SqlValidatorScope groupScope,
      @Nullable AggregatingSelectScope aggregatingScope,
      SqlNode groupItem) {
<span class="nc bnc" id="L4794" title="All 3 branches missed.">    switch (groupItem.getKind()) {</span>
    case GROUP_BY_DISTINCT:
<span class="nc bnc" id="L4796" title="All 2 branches missed.">      for (SqlNode sqlNode : ((SqlCall) groupItem).getOperandList()) {</span>
<span class="nc" id="L4797">        validateGroupItem(groupScope, aggregatingScope, sqlNode);</span>
<span class="nc" id="L4798">      }</span>
<span class="nc" id="L4799">      break;</span>
    case GROUPING_SETS:
    case ROLLUP:
    case CUBE:
<span class="nc" id="L4803">      validateGroupingSets(groupScope, aggregatingScope, (SqlCall) groupItem);</span>
<span class="nc" id="L4804">      break;</span>
    default:
<span class="nc bnc" id="L4806" title="All 2 branches missed.">      if (groupItem instanceof SqlNodeList) {</span>
<span class="nc" id="L4807">        break;</span>
      }
<span class="nc" id="L4809">      final RelDataType type = deriveType(groupScope, groupItem);</span>
<span class="nc" id="L4810">      setValidatedNodeType(groupItem, type);</span>
    }
<span class="nc" id="L4812">  }</span>

  private void validateGroupingSets(SqlValidatorScope groupScope,
      @Nullable AggregatingSelectScope aggregatingScope, SqlCall groupItem) {
<span class="nc bnc" id="L4816" title="All 2 branches missed.">    for (SqlNode node : groupItem.getOperandList()) {</span>
<span class="nc" id="L4817">      validateGroupItem(groupScope, aggregatingScope, node);</span>
<span class="nc" id="L4818">    }</span>
<span class="nc" id="L4819">  }</span>

  protected void validateWhereClause(SqlSelect select) {
    // validate WHERE clause
<span class="nc" id="L4823">    final SqlNode where = select.getWhere();</span>
<span class="nc bnc" id="L4824" title="All 2 branches missed.">    if (where == null) {</span>
<span class="nc" id="L4825">      return;</span>
    }
<span class="nc" id="L4827">    final SqlValidatorScope whereScope = getWhereScope(select);</span>
<span class="nc" id="L4828">    final SqlNode expandedWhere = expand(where, whereScope);</span>
<span class="nc" id="L4829">    select.setWhere(expandedWhere);</span>
<span class="nc" id="L4830">    validateWhereOrOn(whereScope, expandedWhere, &quot;WHERE&quot;);</span>
<span class="nc" id="L4831">  }</span>

  protected void validateWhereOrOn(
      SqlValidatorScope scope,
      SqlNode condition,
      String clause) {
<span class="nc" id="L4837">    validateNoAggs(aggOrOverOrGroupFinder, condition, clause);</span>
<span class="nc" id="L4838">    inferUnknownTypes(</span>
        booleanType,
        scope,
        condition);
<span class="nc" id="L4842">    condition.validate(this, scope);</span>

<span class="nc" id="L4844">    final RelDataType type = deriveType(scope, condition);</span>
<span class="nc bnc" id="L4845" title="All 2 branches missed.">    if (!isReturnBooleanType(type)) {</span>
<span class="nc" id="L4846">      throw newValidationError(condition, RESOURCE.condMustBeBoolean(clause));</span>
    }
<span class="nc" id="L4848">  }</span>

  private static boolean isReturnBooleanType(RelDataType relDataType) {
<span class="nc bnc" id="L4851" title="All 2 branches missed.">    if (relDataType instanceof RelRecordType) {</span>
<span class="nc" id="L4852">      RelRecordType recordType = (RelRecordType) relDataType;</span>
<span class="nc bnc" id="L4853" title="All 2 branches missed.">      checkState(recordType.getFieldList().size() == 1,</span>
          &quot;sub-query as condition must return only one column&quot;);
<span class="nc" id="L4855">      RelDataTypeField recordField = recordType.getFieldList().get(0);</span>
<span class="nc" id="L4856">      return SqlTypeUtil.inBooleanFamily(recordField.getType());</span>
    }
<span class="nc" id="L4858">    return SqlTypeUtil.inBooleanFamily(relDataType);</span>
  }

  protected void validateHavingClause(SqlSelect select) {
    // HAVING is validated in the scope after groups have been created.
    // For example, in &quot;SELECT empno FROM emp WHERE empno = 10 GROUP BY
    // deptno HAVING empno = 10&quot;, the reference to 'empno' in the HAVING
    // clause is illegal.
<span class="nc" id="L4866">    SqlNode having = select.getHaving();</span>
<span class="nc bnc" id="L4867" title="All 2 branches missed.">    if (having == null) {</span>
<span class="nc" id="L4868">      return;</span>
    }
<span class="nc" id="L4870">    SqlNode originalHaving = having;</span>
<span class="nc" id="L4871">    final AggregatingScope havingScope =</span>
<span class="nc" id="L4872">        (AggregatingScope) getSelectScope(select);</span>
<span class="nc bnc" id="L4873" title="All 2 branches missed.">    if (config.conformance().isHavingAlias()) {</span>
<span class="nc" id="L4874">      SqlNode newExpr = extendedExpand(having, havingScope, select, Clause.HAVING);</span>
<span class="nc bnc" id="L4875" title="All 2 branches missed.">      if (having != newExpr) {</span>
<span class="nc" id="L4876">        having = newExpr;</span>
<span class="nc" id="L4877">        select.setHaving(newExpr);</span>
      }
    }
<span class="nc bnc" id="L4880" title="All 2 branches missed.">    if (SqlUtil.containsCall(having, call -&gt; call.getOperator() instanceof SqlOverOperator)) {</span>
<span class="nc" id="L4881">      throw newValidationError(originalHaving, RESOURCE.windowInHavingNotAllowed());</span>
    }
<span class="nc" id="L4883">    havingScope.checkAggregateExpr(having, true);</span>
<span class="nc" id="L4884">    inferUnknownTypes(booleanType, havingScope, having);</span>
<span class="nc" id="L4885">    having.validate(this, havingScope);</span>
<span class="nc" id="L4886">    final RelDataType type = deriveType(havingScope, having);</span>
<span class="nc bnc" id="L4887" title="All 2 branches missed.">    if (!SqlTypeUtil.inBooleanFamily(type)) {</span>
<span class="nc" id="L4888">      throw newValidationError(having, RESOURCE.havingMustBeBoolean());</span>
    }
<span class="nc" id="L4890">  }</span>

  protected RelDataType validateSelectList(final SqlNodeList selectItems,
      SqlSelect select, RelDataType targetRowType) {
    // First pass, ensure that aliases are unique. &quot;*&quot; and &quot;TABLE.*&quot; items
    // are ignored.

    // Validate SELECT list. Expand terms of the form &quot;*&quot; or &quot;TABLE.*&quot;.
<span class="nc" id="L4898">    final SqlValidatorScope selectScope = getSelectScope(select);</span>
<span class="nc" id="L4899">    final List&lt;SqlNode&gt; expandedSelectItems = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L4900">    final Set&lt;String&gt; aliases = new HashSet&lt;&gt;();</span>
<span class="nc" id="L4901">    final PairList&lt;String, RelDataType&gt; fieldList = PairList.of();</span>

<span class="nc bnc" id="L4903" title="All 2 branches missed.">    for (SqlNode selectItem : selectItems) {</span>
<span class="nc bnc" id="L4904" title="All 2 branches missed.">      if (selectItem instanceof SqlSelect) {</span>
<span class="nc" id="L4905">        handleScalarSubQuery(select, (SqlSelect) selectItem,</span>
            expandedSelectItems, aliases, fieldList);
      } else {
        // Use the field list size to record the field index
        // because the select item may be a STAR(*), which could have been expanded.
<span class="nc" id="L4910">        final int fieldIdx = fieldList.size();</span>
        final RelDataType fieldType =
<span class="nc bnc" id="L4912" title="All 2 branches missed.">            targetRowType.isStruct()</span>
<span class="nc bnc" id="L4913" title="All 2 branches missed.">                &amp;&amp; targetRowType.getFieldCount() &gt; fieldIdx</span>
<span class="nc" id="L4914">                ? targetRowType.getFieldList().get(fieldIdx).getType()</span>
<span class="nc" id="L4915">                : unknownType;</span>
<span class="nc" id="L4916">        expandSelectItem(selectItem, select, fieldType, expandedSelectItems,</span>
            aliases, fieldList, false);
      }
<span class="nc" id="L4919">    }</span>

    // Create the new select list with expanded items.  Pass through
    // the original parser position so that any overall failures can
    // still reference the original input text.
<span class="nc" id="L4924">    SqlNodeList newSelectList =</span>
<span class="nc" id="L4925">        new SqlNodeList(expandedSelectItems, selectItems.getParserPosition());</span>
<span class="nc bnc" id="L4926" title="All 2 branches missed.">    if (config.identifierExpansion()) {</span>
<span class="nc" id="L4927">      select.setSelectList(newSelectList);</span>
    }
<span class="nc" id="L4929">    getRawSelectScopeNonNull(select).setExpandedSelectList(expandedSelectItems);</span>

    // TODO: when SELECT appears as a value sub-query, should be using
    // something other than unknownType for targetRowType
<span class="nc" id="L4933">    inferUnknownTypes(targetRowType, selectScope, newSelectList);</span>

<span class="nc bnc" id="L4935" title="All 4 branches missed.">    final boolean aggregate = isAggregate(select) || select.isDistinct();</span>
<span class="nc bnc" id="L4936" title="All 2 branches missed.">    for (SqlNode selectItem : expandedSelectItems) {</span>
<span class="nc bnc" id="L4937" title="All 4 branches missed.">      if (SqlValidatorUtil.isMeasure(selectItem) &amp;&amp; aggregate) {</span>
<span class="nc" id="L4938">        throw newValidationError(selectItem,</span>
<span class="nc" id="L4939">            RESOURCE.measureInAggregateQuery());</span>
      }
<span class="nc" id="L4941">      validateNoAggs(groupFinder, selectItem, &quot;SELECT&quot;);</span>
<span class="nc" id="L4942">      validateExpr(selectItem, selectScope);</span>
<span class="nc" id="L4943">    }</span>

<span class="nc" id="L4945">    return typeFactory.createStructType(fieldList);</span>
  }

  /**
   * Validates an expression.
   *
   * @param expr  Expression
   * @param scope Scope in which expression occurs
   */
  private void validateExpr(SqlNode expr, SqlValidatorScope scope) {
<span class="nc bnc" id="L4955" title="All 2 branches missed.">    if (expr instanceof SqlCall) {</span>
<span class="nc" id="L4956">      final SqlOperator op = ((SqlCall) expr).getOperator();</span>
<span class="nc bnc" id="L4957" title="All 4 branches missed.">      if (op.isAggregator() &amp;&amp; op.requiresOver()) {</span>
<span class="nc" id="L4958">        throw newValidationError(expr,</span>
<span class="nc" id="L4959">            RESOURCE.absentOverClause());</span>
      }
<span class="nc bnc" id="L4961" title="All 2 branches missed.">      if (op instanceof SqlTableFunction) {</span>
<span class="nc" id="L4962">        throw RESOURCE.cannotCallTableFunctionHere(op.getName()).ex();</span>
      }
    }

    // Unless 'naked measures' are enabled, a non-aggregate query cannot
    // reference measure columns. (An aggregate query can use them as
    // argument to the AGGREGATE function.)
<span class="nc bnc" id="L4969" title="All 4 branches missed.">    if (!config.nakedMeasuresInNonAggregateQuery()</span>
        &amp;&amp; !(scope instanceof AggregatingScope)
<span class="nc bnc" id="L4971" title="All 2 branches missed.">        &amp;&amp; scope.isMeasureRef(expr)) {</span>
<span class="nc" id="L4972">      throw newValidationError(expr,</span>
<span class="nc" id="L4973">          RESOURCE.measureMustBeInAggregateQuery());</span>
    }

<span class="nc bnc" id="L4976" title="All 4 branches missed.">    if (SqlValidatorUtil.isMeasure(expr) &amp;&amp; scope instanceof SelectScope) {</span>
<span class="nc" id="L4977">      scope = getMeasureScope(((SelectScope) scope).getNode());</span>
    }

    // Call on the expression to validate itself.
<span class="nc" id="L4981">    expr.validateExpr(this, scope);</span>

    // Perform any validation specific to the scope. For example, an
    // aggregating scope requires that expressions are valid aggregations.
<span class="nc" id="L4985">    scope.validateExpr(expr);</span>
<span class="nc" id="L4986">  }</span>

  /**
   * Processes SubQuery found in Select list. Checks that is actually Scalar
   * sub-query and makes proper entries in each of the 3 lists used to create
   * the final rowType entry.
   *
   * @param parentSelect        base SqlSelect item
   * @param selectItem          child SqlSelect from select list
   * @param expandedSelectItems Select items after processing
   * @param aliasList           built from user or system values
   * @param fieldList           Built up entries for each select list entry
   */
  private void handleScalarSubQuery(SqlSelect parentSelect,
      SqlSelect selectItem, List&lt;SqlNode&gt; expandedSelectItems,
      Set&lt;String&gt; aliasList, PairList&lt;String, RelDataType&gt; fieldList) {
    // A scalar sub-query only has one output column.
<span class="nc bnc" id="L5003" title="All 2 branches missed.">    if (1 != SqlNonNullableAccessors.getSelectList(selectItem).size()) {</span>
<span class="nc" id="L5004">      throw newValidationError(selectItem,</span>
<span class="nc" id="L5005">          RESOURCE.onlyScalarSubQueryAllowed());</span>
    }

    // No expansion in this routine just append to list.
<span class="nc" id="L5009">    expandedSelectItems.add(selectItem);</span>

    // Get or generate alias and add to list.
<span class="nc" id="L5012">    final String alias =</span>
<span class="nc" id="L5013">        SqlValidatorUtil.alias(selectItem, aliasList.size());</span>
<span class="nc" id="L5014">    aliasList.add(alias);</span>

<span class="nc" id="L5016">    final SelectScope scope = (SelectScope) getWhereScope(parentSelect);</span>
<span class="nc" id="L5017">    final RelDataType type = deriveType(scope, selectItem);</span>
<span class="nc" id="L5018">    setValidatedNodeType(selectItem, type);</span>

    // We do not want to pass on the RelRecordType returned
    // by the sub-query.  Just the type of the single expression
    // in the sub-query select list.
<span class="nc bnc" id="L5023" title="All 2 branches missed.">    assert type instanceof RelRecordType;</span>
<span class="nc" id="L5024">    RelRecordType rec = (RelRecordType) type;</span>

<span class="nc" id="L5026">    RelDataType nodeType = rec.getFieldList().get(0).getType();</span>
<span class="nc" id="L5027">    nodeType = typeFactory.createTypeWithNullability(nodeType, true);</span>
<span class="nc" id="L5028">    fieldList.add(alias, nodeType);</span>
<span class="nc" id="L5029">  }</span>

  /**
   * Derives a row-type for INSERT and UPDATE operations.
   *
   * @param table            Target table for INSERT/UPDATE
   * @param targetColumnList List of target columns, or null if not specified
   * @param append           Whether to append fields to those in &lt;code&gt;
   *                         baseRowType&lt;/code&gt;
   * @param targetTableAlias Target table alias, or null if not specified
   * @return Rowtype
   */
  protected RelDataType createTargetRowType(
      SqlValidatorTable table,
      @Nullable SqlNodeList targetColumnList,
      boolean append,
      @Nullable SqlIdentifier targetTableAlias) {
<span class="nc" id="L5046">    RelDataType baseRowType = table.getRowType();</span>
<span class="nc bnc" id="L5047" title="All 2 branches missed.">    if (targetColumnList == null) {</span>
<span class="nc" id="L5048">      return baseRowType;</span>
    }
<span class="nc" id="L5050">    List&lt;RelDataTypeField&gt; targetFields = baseRowType.getFieldList();</span>
<span class="nc" id="L5051">    final PairList&lt;String, RelDataType&gt; fields = PairList.of();</span>
<span class="nc bnc" id="L5052" title="All 2 branches missed.">    if (append) {</span>
<span class="nc bnc" id="L5053" title="All 2 branches missed.">      for (RelDataTypeField targetField : targetFields) {</span>
<span class="nc" id="L5054">        fields.add(SqlUtil.deriveAliasFromOrdinal(fields.size()),</span>
<span class="nc" id="L5055">            targetField.getType());</span>
<span class="nc" id="L5056">      }</span>
    }
<span class="nc" id="L5058">    final Set&lt;Integer&gt; assignedFields = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L5059" title="All 2 branches missed.">    final RelOptTable relOptTable = table instanceof RelOptTable</span>
<span class="nc" id="L5060">        ? ((RelOptTable) table) : null;</span>
<span class="nc bnc" id="L5061" title="All 2 branches missed.">    for (SqlNode node : targetColumnList) {</span>
<span class="nc" id="L5062">      SqlIdentifier id = (SqlIdentifier) node;</span>
<span class="nc bnc" id="L5063" title="All 4 branches missed.">      if (!id.isSimple() &amp;&amp; targetTableAlias != null) {</span>
        // checks that target column identifiers are prefixed with the target
        // table alias
<span class="nc" id="L5066">        SqlIdentifier prefixId = id.skipLast(1);</span>
<span class="nc bnc" id="L5067" title="All 2 branches missed.">        if (!prefixId.toString().equals(targetTableAlias.toString())) {</span>
<span class="nc" id="L5068">          throw newValidationError(prefixId,</span>
<span class="nc" id="L5069">              RESOURCE.unknownIdentifier(prefixId.toString()));</span>
        }
      }
<span class="nc" id="L5072">      RelDataTypeField targetField =</span>
<span class="nc" id="L5073">          SqlValidatorUtil.getTargetField(</span>
              baseRowType, typeFactory, id, catalogReader, relOptTable);
<span class="nc bnc" id="L5075" title="All 2 branches missed.">      if (targetField == null) {</span>
<span class="nc" id="L5076">        throw newValidationError(id,</span>
<span class="nc" id="L5077">            RESOURCE.unknownTargetColumn(id.toString()));</span>
      }
<span class="nc bnc" id="L5079" title="All 2 branches missed.">      if (!assignedFields.add(targetField.getIndex())) {</span>
<span class="nc" id="L5080">        throw newValidationError(id,</span>
<span class="nc" id="L5081">            RESOURCE.duplicateTargetColumn(targetField.getName()));</span>
      }
<span class="nc" id="L5083">      fields.add(targetField);</span>
<span class="nc" id="L5084">    }</span>
<span class="nc" id="L5085">    return typeFactory.createStructType(fields);</span>
  }

  @Override public void validateInsert(SqlInsert insert) {
<span class="nc" id="L5089">    final SqlValidatorNamespace targetNamespace = getNamespaceOrThrow(insert);</span>
<span class="nc" id="L5090">    validateNamespace(targetNamespace, unknownType);</span>
<span class="nc" id="L5091">    final RelOptTable relOptTable =</span>
<span class="nc" id="L5092">        SqlValidatorUtil.getRelOptTable(targetNamespace,</span>
<span class="nc" id="L5093">            catalogReader.unwrap(Prepare.CatalogReader.class), null, null);</span>
<span class="nc bnc" id="L5094" title="All 2 branches missed.">    final SqlValidatorTable table = relOptTable == null</span>
<span class="nc" id="L5095">        ? getTable(targetNamespace)</span>
<span class="nc" id="L5096">        : relOptTable.unwrapOrThrow(SqlValidatorTable.class);</span>

    // INSERT has an optional column name list.  If present then
    // reduce the rowtype to the columns specified.  If not present
    // then the entire target rowtype is used.
<span class="nc" id="L5101">    final RelDataType targetRowType =</span>
<span class="nc" id="L5102">        createTargetRowType(</span>
            table,
<span class="nc" id="L5104">            insert.getTargetColumnList(),</span>
            false,
            null);

<span class="nc" id="L5108">    final SqlNode source = insert.getSource();</span>
<span class="nc bnc" id="L5109" title="All 2 branches missed.">    if (source instanceof SqlSelect) {</span>
<span class="nc" id="L5110">      final SqlSelect sqlSelect = (SqlSelect) source;</span>
<span class="nc" id="L5111">      validateSelect(sqlSelect, targetRowType);</span>
<span class="nc" id="L5112">    } else {</span>
<span class="nc" id="L5113">      final SqlValidatorScope scope = scopes.get(source);</span>
<span class="nc" id="L5114">      requireNonNull(scope, &quot;scope&quot;);</span>
<span class="nc" id="L5115">      validateQuery(source, scope, targetRowType);</span>
    }

    // REVIEW jvs 4-Dec-2008: In FRG-365, this namespace row type is
    // discarding the type inferred by inferUnknownTypes (which was invoked
    // from validateSelect above).  It would be better if that information
    // were used here so that we never saw any untyped nulls during
    // checkTypeAssignment.
<span class="nc" id="L5123">    final RelDataType sourceRowType = getNamespaceOrThrow(source).getRowType();</span>
<span class="nc" id="L5124">    final RelDataType logicalTargetRowType =</span>
<span class="nc" id="L5125">        getLogicalTargetRowType(targetRowType, insert);</span>
<span class="nc" id="L5126">    setValidatedNodeType(insert, logicalTargetRowType);</span>
<span class="nc" id="L5127">    final RelDataType logicalSourceRowType =</span>
<span class="nc" id="L5128">        getLogicalSourceRowType(sourceRowType, insert);</span>

<span class="nc" id="L5130">    final List&lt;ColumnStrategy&gt; strategies =</span>
<span class="nc" id="L5131">        table.unwrapOrThrow(RelOptTable.class).getColumnStrategies();</span>

<span class="nc" id="L5133">    final RelDataType realTargetRowType =</span>
<span class="nc" id="L5134">        typeFactory.createStructType(</span>
<span class="nc" id="L5135">            logicalTargetRowType.getFieldList()</span>
<span class="nc" id="L5136">                .stream()</span>
<span class="nc" id="L5137">                .filter(f -&gt; strategies.get(f.getIndex()).canInsertInto())</span>
<span class="nc" id="L5138">                .collect(Collectors.toList()));</span>

    final RelDataType targetRowTypeToValidate =
<span class="nc bnc" id="L5141" title="All 2 branches missed.">        logicalSourceRowType.getFieldCount() == logicalTargetRowType.getFieldCount()</span>
<span class="nc" id="L5142">        ? logicalTargetRowType</span>
<span class="nc" id="L5143">        : realTargetRowType;</span>

<span class="nc" id="L5145">    checkFieldCount(insert.getTargetTable(), table, strategies,</span>
        targetRowTypeToValidate, realTargetRowType,
        source, logicalSourceRowType, logicalTargetRowType);

<span class="nc" id="L5149">    checkTypeAssignment(scopes.get(source),</span>
        table,
        logicalSourceRowType,
        targetRowTypeToValidate,
        insert);

<span class="nc" id="L5155">    checkConstraint(table, source, logicalTargetRowType);</span>

<span class="nc" id="L5157">    validateAccess(insert.getTargetTable(), table, SqlAccessEnum.INSERT);</span>

    // Refresh the insert row type to keep sync with source.
<span class="nc" id="L5160">    setValidatedNodeType(insert, targetRowTypeToValidate);</span>
<span class="nc" id="L5161">  }</span>

  /**
   * Validates insert values against the constraint of a modifiable view.
   *
   * @param validatorTable Table that may wrap a ModifiableViewTable
   * @param source        The values being inserted
   * @param targetRowType The target type for the view
   */
  private void checkConstraint(
      SqlValidatorTable validatorTable,
      SqlNode source,
      RelDataType targetRowType) {
<span class="nc" id="L5174">    final ModifiableViewTable modifiableViewTable =</span>
<span class="nc" id="L5175">        validatorTable.unwrap(ModifiableViewTable.class);</span>
<span class="nc bnc" id="L5176" title="All 4 branches missed.">    if (modifiableViewTable != null &amp;&amp; source instanceof SqlCall) {</span>
<span class="nc" id="L5177">      final Table table = modifiableViewTable.getTable();</span>
<span class="nc" id="L5178">      final RelDataType tableRowType = table.getRowType(typeFactory);</span>
<span class="nc" id="L5179">      final List&lt;RelDataTypeField&gt; tableFields = tableRowType.getFieldList();</span>

      // Get the mapping from column indexes of the underlying table
      // to the target columns and view constraints.
<span class="nc" id="L5183">      final Map&lt;Integer, RelDataTypeField&gt; tableIndexToTargetField =</span>
<span class="nc" id="L5184">          SqlValidatorUtil.getIndexToFieldMap(tableFields, targetRowType);</span>
<span class="nc" id="L5185">      final Map&lt;Integer, RexNode&gt; projectMap =</span>
<span class="nc" id="L5186">          RelOptUtil.getColumnConstraints(modifiableViewTable, targetRowType, typeFactory);</span>

      // Determine columns (indexed to the underlying table) that need
      // to be validated against the view constraint.
      @SuppressWarnings(&quot;RedundantCast&quot;)
<span class="nc" id="L5191">      final ImmutableBitSet targetColumns =</span>
<span class="nc" id="L5192">          ImmutableBitSet.of((Iterable&lt;Integer&gt;) tableIndexToTargetField.keySet());</span>
      @SuppressWarnings(&quot;RedundantCast&quot;)
<span class="nc" id="L5194">      final ImmutableBitSet constrainedColumns =</span>
<span class="nc" id="L5195">          ImmutableBitSet.of((Iterable&lt;Integer&gt;) projectMap.keySet());</span>
      @SuppressWarnings(&quot;assignment.type.incompatible&quot;)
<span class="nc" id="L5197">      List&lt;@KeyFor({&quot;tableIndexToTargetField&quot;, &quot;projectMap&quot;}) Integer&gt; constrainedTargetColumns =</span>
<span class="nc" id="L5198">          targetColumns.intersect(constrainedColumns).asList();</span>

      // Validate insert values against the view constraint.
<span class="nc" id="L5201">      final List&lt;SqlNode&gt; values = ((SqlCall) source).getOperandList();</span>
<span class="nc bnc" id="L5202" title="All 2 branches missed.">      for (final int colIndex : constrainedTargetColumns) {</span>
<span class="nc" id="L5203">        final String colName = tableFields.get(colIndex).getName();</span>
<span class="nc" id="L5204">        final RelDataTypeField targetField =</span>
<span class="nc" id="L5205">            requireNonNull(tableIndexToTargetField.get(colIndex));</span>
<span class="nc bnc" id="L5206" title="All 2 branches missed.">        for (SqlNode row : values) {</span>
<span class="nc" id="L5207">          final SqlCall call = (SqlCall) row;</span>
<span class="nc" id="L5208">          final SqlNode sourceValue = call.operand(targetField.getIndex());</span>
<span class="nc" id="L5209">          final ValidationError validationError =</span>
              new ValidationError(sourceValue,
<span class="nc" id="L5211">                  RESOURCE.viewConstraintNotSatisfied(colName,</span>
<span class="nc" id="L5212">                      Util.last(validatorTable.getQualifiedName())));</span>
<span class="nc" id="L5213">          RelOptUtil.validateValueAgainstConstraint(sourceValue,</span>
<span class="nc" id="L5214">              projectMap.get(colIndex), validationError);</span>
<span class="nc" id="L5215">        }</span>
<span class="nc" id="L5216">      }</span>
    }
<span class="nc" id="L5218">  }</span>

  /**
   * Validates updates against the constraint of a modifiable view.
   *
   * @param validatorTable A {@link SqlValidatorTable} that may wrap a
   *                       ModifiableViewTable
   * @param update         The UPDATE parse tree node
   * @param targetRowType  The target type
   */
  private void checkConstraint(
      SqlValidatorTable validatorTable,
      SqlUpdate update,
      RelDataType targetRowType) {
<span class="nc" id="L5232">    final ModifiableViewTable modifiableViewTable =</span>
<span class="nc" id="L5233">        validatorTable.unwrap(ModifiableViewTable.class);</span>
<span class="nc bnc" id="L5234" title="All 2 branches missed.">    if (modifiableViewTable != null) {</span>
<span class="nc" id="L5235">      final Table table = modifiableViewTable.getTable();</span>
<span class="nc" id="L5236">      final RelDataType tableRowType = table.getRowType(typeFactory);</span>

<span class="nc" id="L5238">      final Map&lt;Integer, RexNode&gt; projectMap =</span>
<span class="nc" id="L5239">          RelOptUtil.getColumnConstraints(modifiableViewTable, targetRowType,</span>
              typeFactory);
<span class="nc" id="L5241">      final Map&lt;String, Integer&gt; nameToIndex =</span>
<span class="nc" id="L5242">          SqlValidatorUtil.mapNameToIndex(tableRowType.getFieldList());</span>

      // Validate update values against the view constraint.
<span class="nc" id="L5245">      final List&lt;String&gt; targetNames =</span>
<span class="nc" id="L5246">          SqlIdentifier.simpleNames(update.getTargetColumnList());</span>
<span class="nc" id="L5247">      final List&lt;SqlNode&gt; sources = update.getSourceExpressionList();</span>
<span class="nc" id="L5248">      Pair.forEach(targetNames, sources, (columnName, expr) -&gt; {</span>
<span class="nc" id="L5249">        final Integer columnIndex = nameToIndex.get(columnName);</span>
<span class="nc bnc" id="L5250" title="All 2 branches missed.">        if (projectMap.containsKey(columnIndex)) {</span>
<span class="nc" id="L5251">          final RexNode columnConstraint = projectMap.get(columnIndex);</span>
<span class="nc" id="L5252">          final ValidationError validationError =</span>
              new ValidationError(expr,
<span class="nc" id="L5254">                  RESOURCE.viewConstraintNotSatisfied(columnName,</span>
<span class="nc" id="L5255">                      Util.last(validatorTable.getQualifiedName())));</span>
<span class="nc" id="L5256">          RelOptUtil.validateValueAgainstConstraint(expr,</span>
              columnConstraint, validationError);
        }
<span class="nc" id="L5259">      });</span>
    }
<span class="nc" id="L5261">  }</span>

  /**
   * Check the field count of sql insert source and target node row type.
   *
   * @param node                    target table sql identifier
   * @param table                   target table
   * @param strategies              column strategies of target table
   * @param targetRowTypeToValidate row type to validate mainly for column strategies
   * @param realTargetRowType       target table row type exclusive virtual columns
   * @param source                  source node
   * @param logicalSourceRowType    source node row type
   * @param logicalTargetRowType    logical target row type, contains only target columns if
   *                                they are specified or if the sql dialect allows subset insert,
   *                                make a subset of fields(start from the left first field) whose
   *                                length is equals with the source row type fields number
   */
  private void checkFieldCount(SqlNode node, SqlValidatorTable table,
      List&lt;ColumnStrategy&gt; strategies, RelDataType targetRowTypeToValidate,
      RelDataType realTargetRowType, SqlNode source,
      RelDataType logicalSourceRowType, RelDataType logicalTargetRowType) {
<span class="nc" id="L5282">    final int sourceFieldCount = logicalSourceRowType.getFieldCount();</span>
<span class="nc" id="L5283">    final int targetFieldCount = logicalTargetRowType.getFieldCount();</span>
<span class="nc" id="L5284">    final int targetRealFieldCount = realTargetRowType.getFieldCount();</span>
<span class="nc bnc" id="L5285" title="All 4 branches missed.">    if (sourceFieldCount != targetFieldCount</span>
        &amp;&amp; sourceFieldCount != targetRealFieldCount) {
      // Allows the source row fields count to be equal with either
      // the logical or the real(excludes columns that can not insert into)
      // target row fields count.
<span class="nc" id="L5290">      throw newValidationError(node,</span>
<span class="nc" id="L5291">          RESOURCE.unmatchInsertColumn(targetFieldCount, sourceFieldCount));</span>
    }
    // Ensure that non-nullable fields are targeted.
<span class="nc bnc" id="L5294" title="All 2 branches missed.">    for (final RelDataTypeField field : table.getRowType().getFieldList()) {</span>
<span class="nc" id="L5295">      final RelDataTypeField targetField =</span>
<span class="nc" id="L5296">          targetRowTypeToValidate.getField(field.getName(), true, false);</span>
<span class="nc bnc" id="L5297" title="All 4 branches missed.">      switch (strategies.get(field.getIndex())) {</span>
      case NOT_NULLABLE:
<span class="nc bnc" id="L5299" title="All 2 branches missed.">        assert !field.getType().isNullable();</span>
<span class="nc bnc" id="L5300" title="All 2 branches missed.">        if (targetField == null) {</span>
<span class="nc" id="L5301">          throw newValidationError(node,</span>
<span class="nc" id="L5302">              RESOURCE.columnNotNullable(field.getName()));</span>
        }
        break;
      case NULLABLE:
<span class="nc bnc" id="L5306" title="All 2 branches missed.">        assert field.getType().isNullable();</span>
        break;
      case VIRTUAL:
      case STORED:
<span class="nc bnc" id="L5310" title="All 2 branches missed.">        if (targetField != null</span>
<span class="nc bnc" id="L5311" title="All 2 branches missed.">            &amp;&amp; !isValuesWithDefault(source, targetField.getIndex())) {</span>
<span class="nc" id="L5312">          throw newValidationError(node,</span>
<span class="nc" id="L5313">              RESOURCE.insertIntoAlwaysGenerated(field.getName()));</span>
        }
        break;
      default:
        break;
      }
<span class="nc" id="L5319">    }</span>
<span class="nc" id="L5320">  }</span>

  /** Returns whether a query uses {@code DEFAULT} to populate a given
   * column. */
  private static boolean isValuesWithDefault(SqlNode source, int column) {
<span class="nc bnc" id="L5325" title="All 2 branches missed.">    switch (source.getKind()) {</span>
    case VALUES:
<span class="nc bnc" id="L5327" title="All 2 branches missed.">      for (SqlNode operand : ((SqlCall) source).getOperandList()) {</span>
<span class="nc bnc" id="L5328" title="All 2 branches missed.">        if (!isRowWithDefault(operand, column)) {</span>
<span class="nc" id="L5329">          return false;</span>
        }
<span class="nc" id="L5331">      }</span>
<span class="nc" id="L5332">      return true;</span>
    default:
      break;
    }
<span class="nc" id="L5336">    return false;</span>
  }

  private static boolean isRowWithDefault(SqlNode operand, int column) {
<span class="nc bnc" id="L5340" title="All 2 branches missed.">    switch (operand.getKind()) {</span>
    case ROW:
<span class="nc" id="L5342">      final SqlCall row = (SqlCall) operand;</span>
<span class="nc bnc" id="L5343" title="All 2 branches missed.">      return row.getOperandList().size() &gt;= column</span>
<span class="nc bnc" id="L5344" title="All 2 branches missed.">          &amp;&amp; row.getOperandList().get(column).getKind() == SqlKind.DEFAULT;</span>
    default:
      break;
    }
<span class="nc" id="L5348">    return false;</span>
  }

  protected RelDataType getLogicalTargetRowType(
      RelDataType targetRowType,
      SqlInsert insert) {
<span class="nc bnc" id="L5354" title="All 2 branches missed.">    if (insert.getTargetColumnList() == null</span>
<span class="nc bnc" id="L5355" title="All 2 branches missed.">        &amp;&amp; this.config.conformance().isInsertSubsetColumnsAllowed()) {</span>
      // Target an implicit subset of columns.
<span class="nc" id="L5357">      final SqlNode source = insert.getSource();</span>
<span class="nc" id="L5358">      final RelDataType sourceRowType = getNamespaceOrThrow(source).getRowType();</span>
<span class="nc" id="L5359">      final RelDataType logicalSourceRowType =</span>
<span class="nc" id="L5360">          getLogicalSourceRowType(sourceRowType, insert);</span>
<span class="nc" id="L5361">      final RelDataType implicitTargetRowType =</span>
<span class="nc" id="L5362">          typeFactory.createStructType(</span>
<span class="nc" id="L5363">              targetRowType.getFieldList()</span>
<span class="nc" id="L5364">                  .subList(0, logicalSourceRowType.getFieldCount()));</span>
<span class="nc" id="L5365">      final SqlValidatorNamespace targetNamespace = getNamespaceOrThrow(insert);</span>
<span class="nc" id="L5366">      validateNamespace(targetNamespace, implicitTargetRowType);</span>
<span class="nc" id="L5367">      return implicitTargetRowType;</span>
    } else {
      // Either the set of columns are explicitly targeted, or target the full
      // set of columns.
<span class="nc" id="L5371">      return targetRowType;</span>
    }
  }

  protected RelDataType getLogicalSourceRowType(
      RelDataType sourceRowType,
      SqlInsert insert) {
<span class="nc" id="L5378">    return sourceRowType;</span>
  }

  /**
   * Checks the type assignment of an INSERT or UPDATE query.
   *
   * &lt;p&gt;Skip the virtual columns(can not insert into) type assignment
   * check if the source fields count equals with
   * the real target table fields count, see how #checkFieldCount was used.
   *
   * @param sourceScope   Scope of query source which is used to infer node type
   * @param table         Target table
   * @param sourceRowType Source row type
   * @param targetRowType Target row type, it should either contain all the virtual columns
   *                      (can not insert into) or exclude all the virtual columns
   * @param query The query
   */
  protected void checkTypeAssignment(
      @Nullable SqlValidatorScope sourceScope,
      SqlValidatorTable table,
      RelDataType sourceRowType,
      RelDataType targetRowType,
      final SqlNode query) {
    // NOTE jvs 23-Feb-2006: subclasses may allow for extra targets
    // representing system-maintained columns, so stop after all sources
    // matched
<span class="nc" id="L5404">    boolean isUpdateModifiableViewTable = false;</span>
<span class="nc bnc" id="L5405" title="All 2 branches missed.">    if (query instanceof SqlUpdate) {</span>
<span class="nc" id="L5406">      final SqlNodeList targetColumnList =</span>
<span class="nc" id="L5407">          requireNonNull(((SqlUpdate) query).getTargetColumnList());</span>
<span class="nc" id="L5408">      final int targetColumnCount = targetColumnList.size();</span>
<span class="nc" id="L5409">      targetRowType =</span>
<span class="nc" id="L5410">          SqlTypeUtil.extractLastNFields(typeFactory, targetRowType,</span>
              targetColumnCount);
<span class="nc" id="L5412">      sourceRowType =</span>
<span class="nc" id="L5413">          SqlTypeUtil.extractLastNFields(typeFactory, sourceRowType,</span>
              targetColumnCount);
<span class="nc" id="L5415">      isUpdateModifiableViewTable =</span>
<span class="nc bnc" id="L5416" title="All 2 branches missed.">          table.unwrap(ModifiableViewTable.class) != null;</span>
    }
<span class="nc bnc" id="L5418" title="All 2 branches missed.">    if (SqlTypeUtil.equalAsStructSansNullability(typeFactory,</span>
        sourceRowType, targetRowType, null)) {
      // Returns early if source and target row type equals sans nullability.
<span class="nc" id="L5421">      return;</span>
    }
<span class="nc bnc" id="L5423" title="All 4 branches missed.">    if (config.typeCoercionEnabled() &amp;&amp; !isUpdateModifiableViewTable) {</span>
      // Try type coercion first if implicit type coercion is allowed.
<span class="nc" id="L5425">      boolean coerced =</span>
<span class="nc" id="L5426">          typeCoercion.querySourceCoercion(sourceScope, sourceRowType,</span>
              targetRowType, query);
<span class="nc bnc" id="L5428" title="All 2 branches missed.">      if (coerced) {</span>
<span class="nc" id="L5429">        return;</span>
      }
    }

    // Fall back to default behavior: compare the type families.
<span class="nc" id="L5434">    List&lt;RelDataTypeField&gt; sourceFields = sourceRowType.getFieldList();</span>
<span class="nc" id="L5435">    List&lt;RelDataTypeField&gt; targetFields = targetRowType.getFieldList();</span>
<span class="nc" id="L5436">    final int sourceCount = sourceFields.size();</span>
<span class="nc bnc" id="L5437" title="All 2 branches missed.">    for (int i = 0; i &lt; sourceCount; ++i) {</span>
<span class="nc" id="L5438">      RelDataType sourceType = sourceFields.get(i).getType();</span>
<span class="nc" id="L5439">      RelDataType targetType = targetFields.get(i).getType();</span>
<span class="nc bnc" id="L5440" title="All 2 branches missed.">      if (!SqlTypeUtil.canAssignFrom(targetType, sourceType)) {</span>
<span class="nc" id="L5441">        SqlNode node = getNthExpr(query, i, sourceCount);</span>
<span class="nc bnc" id="L5442" title="All 2 branches missed.">        if (node instanceof SqlDynamicParam) {</span>
<span class="nc" id="L5443">          continue;</span>
        }
        String targetTypeString;
        String sourceTypeString;
<span class="nc bnc" id="L5447" title="All 2 branches missed.">        if (SqlTypeUtil.areCharacterSetsMismatched(</span>
            sourceType,
            targetType)) {
<span class="nc" id="L5450">          sourceTypeString = sourceType.getFullTypeString();</span>
<span class="nc" id="L5451">          targetTypeString = targetType.getFullTypeString();</span>
        } else {
<span class="nc" id="L5453">          sourceTypeString = sourceType.toString();</span>
<span class="nc" id="L5454">          targetTypeString = targetType.toString();</span>
        }
<span class="nc" id="L5456">        throw newValidationError(node,</span>
<span class="nc" id="L5457">            RESOURCE.typeNotAssignable(</span>
<span class="nc" id="L5458">                targetFields.get(i).getName(), targetTypeString,</span>
<span class="nc" id="L5459">                sourceFields.get(i).getName(), sourceTypeString));</span>
      }
    }
<span class="nc" id="L5462">  }</span>

  /**
   * Locates the n'th expression in an INSERT or UPDATE query.
   *
   * @param query       Query
   * @param ordinal     Ordinal of expression
   * @param sourceCount Number of expressions
   * @return Ordinal'th expression, never null
   */
  private static SqlNode getNthExpr(SqlNode query, int ordinal, int sourceCount) {
<span class="nc bnc" id="L5473" title="All 2 branches missed.">    if (query instanceof SqlInsert) {</span>
<span class="nc" id="L5474">      SqlInsert insert = (SqlInsert) query;</span>
<span class="nc bnc" id="L5475" title="All 2 branches missed.">      if (insert.getTargetColumnList() != null) {</span>
<span class="nc" id="L5476">        return insert.getTargetColumnList().get(ordinal);</span>
      } else {
<span class="nc" id="L5478">        return getNthExpr(</span>
<span class="nc" id="L5479">            insert.getSource(),</span>
            ordinal,
            sourceCount);
      }
<span class="nc bnc" id="L5483" title="All 2 branches missed.">    } else if (query instanceof SqlUpdate) {</span>
<span class="nc" id="L5484">      SqlUpdate update = (SqlUpdate) query;</span>
<span class="nc bnc" id="L5485" title="All 2 branches missed.">      if (update.getSourceExpressionList() != null) {</span>
<span class="nc" id="L5486">        return update.getSourceExpressionList().get(ordinal);</span>
      } else {
<span class="nc" id="L5488">        return getNthExpr(SqlNonNullableAccessors.getSourceSelect(update),</span>
            ordinal, sourceCount);
      }
<span class="nc bnc" id="L5491" title="All 2 branches missed.">    } else if (query instanceof SqlSelect) {</span>
<span class="nc" id="L5492">      SqlSelect select = (SqlSelect) query;</span>
<span class="nc" id="L5493">      SqlNodeList selectList = SqlNonNullableAccessors.getSelectList(select);</span>
<span class="nc bnc" id="L5494" title="All 2 branches missed.">      if (selectList.size() == sourceCount) {</span>
<span class="nc" id="L5495">        return selectList.get(ordinal);</span>
      } else {
<span class="nc" id="L5497">        return query; // give up</span>
      }
    } else {
<span class="nc" id="L5500">      return query; // give up</span>
    }
  }

  @Override public void validateDelete(SqlDelete call) {
<span class="nc" id="L5505">    final SqlSelect sqlSelect = SqlNonNullableAccessors.getSourceSelect(call);</span>
<span class="nc" id="L5506">    validateSelect(sqlSelect, unknownType);</span>

<span class="nc" id="L5508">    final SqlValidatorNamespace targetNamespace = getNamespaceOrThrow(call);</span>
<span class="nc" id="L5509">    validateNamespace(targetNamespace, unknownType);</span>
<span class="nc" id="L5510">    final SqlValidatorTable table = targetNamespace.getTable();</span>

<span class="nc" id="L5512">    validateAccess(call.getTargetTable(), table, SqlAccessEnum.DELETE);</span>
<span class="nc" id="L5513">  }</span>

  @Override public void validateUpdate(SqlUpdate call) {
<span class="nc" id="L5516">    final SqlValidatorNamespace targetNamespace = getNamespaceOrThrow(call);</span>
<span class="nc" id="L5517">    validateNamespace(targetNamespace, unknownType);</span>
<span class="nc" id="L5518">    final RelOptTable relOptTable =</span>
<span class="nc" id="L5519">        SqlValidatorUtil.getRelOptTable(targetNamespace,</span>
<span class="nc" id="L5520">            castNonNull(catalogReader.unwrap(Prepare.CatalogReader.class)),</span>
            null, null);
<span class="nc bnc" id="L5522" title="All 2 branches missed.">    final SqlValidatorTable table = relOptTable == null</span>
<span class="nc" id="L5523">        ? getTable(targetNamespace)</span>
<span class="nc" id="L5524">        : relOptTable.unwrapOrThrow(SqlValidatorTable.class);</span>

<span class="nc" id="L5526">    final RelDataType targetRowType =</span>
<span class="nc" id="L5527">        createTargetRowType(table, call.getTargetColumnList(), true,</span>
<span class="nc" id="L5528">            call.getAlias());</span>

<span class="nc" id="L5530">    final SqlSelect select = SqlNonNullableAccessors.getSourceSelect(call);</span>
<span class="nc" id="L5531">    validateSelect(select, targetRowType);</span>

<span class="nc" id="L5533">    final RelDataType sourceRowType = getValidatedNodeType(select);</span>
<span class="nc" id="L5534">    checkTypeAssignment(scopes.get(select), table, sourceRowType, targetRowType,</span>
        call);

<span class="nc" id="L5537">    checkConstraint(table, call, targetRowType);</span>

<span class="nc" id="L5539">    validateAccess(call.getTargetTable(), table, SqlAccessEnum.UPDATE);</span>
<span class="nc" id="L5540">  }</span>

  @Override public void validateMerge(SqlMerge call) {
<span class="nc" id="L5543">    SqlSelect sqlSelect = SqlNonNullableAccessors.getSourceSelect(call);</span>
    // REVIEW zfong 5/25/06 - Does an actual type have to be passed into
    // validateSelect()?

    // REVIEW jvs 6-June-2006:  In general, passing unknownType like
    // this means we won't be able to correctly infer the types
    // for dynamic parameter markers (SET x = ?).  But
    // maybe validateUpdate and validateInsert below will do
    // the job?

    // REVIEW ksecretan 15-July-2011: They didn't get a chance to
    // since validateSelect() would bail.
    // Let's use the update/insert targetRowType when available.
<span class="nc" id="L5556">    IdentifierNamespace targetNamespace =</span>
<span class="nc" id="L5557">        (IdentifierNamespace) getNamespaceOrThrow(call.getTargetTable());</span>
<span class="nc" id="L5558">    validateNamespace(targetNamespace, unknownType);</span>

<span class="nc" id="L5560">    SqlValidatorTable table = targetNamespace.getTable();</span>
<span class="nc" id="L5561">    validateAccess(call.getTargetTable(), table, SqlAccessEnum.UPDATE);</span>

<span class="nc" id="L5563">    RelDataType targetRowType = unknownType;</span>

<span class="nc" id="L5565">    SqlUpdate updateCall = call.getUpdateCall();</span>
<span class="nc bnc" id="L5566" title="All 2 branches missed.">    if (updateCall != null) {</span>
<span class="nc" id="L5567">      requireNonNull(table, () -&gt; &quot;ns.getTable() for &quot; + targetNamespace);</span>
<span class="nc" id="L5568">      targetRowType =</span>
<span class="nc" id="L5569">          createTargetRowType(table, updateCall.getTargetColumnList(), true,</span>
<span class="nc" id="L5570">              call.getAlias());</span>
    }
<span class="nc" id="L5572">    SqlInsert insertCall = call.getInsertCall();</span>
<span class="nc bnc" id="L5573" title="All 2 branches missed.">    if (insertCall != null) {</span>
<span class="nc" id="L5574">      requireNonNull(table, () -&gt; &quot;ns.getTable() for &quot; + targetNamespace);</span>
<span class="nc" id="L5575">      targetRowType =</span>
<span class="nc" id="L5576">          createTargetRowType(table, insertCall.getTargetColumnList(), false,</span>
              null);
    }

<span class="nc" id="L5580">    validateSelect(sqlSelect, targetRowType);</span>

<span class="nc" id="L5582">    SqlUpdate updateCallAfterValidate = call.getUpdateCall();</span>
<span class="nc bnc" id="L5583" title="All 2 branches missed.">    if (updateCallAfterValidate != null) {</span>
<span class="nc" id="L5584">      validateUpdate(updateCallAfterValidate);</span>
    }
<span class="nc" id="L5586">    SqlInsert insertCallAfterValidate = call.getInsertCall();</span>
<span class="nc bnc" id="L5587" title="All 2 branches missed.">    if (insertCallAfterValidate != null) {</span>
<span class="nc" id="L5588">      validateInsert(insertCallAfterValidate);</span>
      // Throw if select list contains NULL literal and target is NOT NULL
<span class="nc bnc" id="L5590" title="All 2 branches missed.">      if (insertCallAfterValidate.getSource() instanceof SqlSelect) {</span>
<span class="nc" id="L5591">        final SqlSelect sourceSelect = (SqlSelect) insertCallAfterValidate.getSource();</span>
<span class="nc" id="L5592">        final SqlNodeList sourceSelectList = sourceSelect.getSelectList();</span>
<span class="nc bnc" id="L5593" title="All 2 branches missed.">        for (int i = 0; i &lt; sourceSelectList.size(); i++) {</span>
<span class="nc" id="L5594">          final RelDataTypeField targetField = targetRowType.getFieldList().get(i);</span>
<span class="nc" id="L5595">          final SqlNode selectItem = sourceSelect.getSelectList().get(i);</span>
<span class="nc bnc" id="L5596" title="All 4 branches missed.">          if (!targetField.getType().isNullable() &amp;&amp; SqlUtil.isNullLiteral(selectItem, true)) {</span>
<span class="nc" id="L5597">            throw newValidationError(selectItem,</span>
<span class="nc" id="L5598">                RESOURCE.columnNotNullable(targetField.getName()));</span>
          }
        }
      }

    }
<span class="nc" id="L5604">  }</span>

  /**
   * Validates access to a table.
   *
   * @param table          Table
   * @param requiredAccess Access requested on table
   */
  private void validateAccess(
      SqlNode node,
      @Nullable SqlValidatorTable table,
      SqlAccessEnum requiredAccess) {
<span class="nc bnc" id="L5616" title="All 2 branches missed.">    if (table != null) {</span>
<span class="nc" id="L5617">      SqlAccessType access = table.getAllowedAccess();</span>
<span class="nc bnc" id="L5618" title="All 2 branches missed.">      if (!access.allowsAccess(requiredAccess)) {</span>
<span class="nc" id="L5619">        throw newValidationError(node,</span>
<span class="nc" id="L5620">            RESOURCE.accessNotAllowed(requiredAccess.name(),</span>
<span class="nc" id="L5621">                table.getQualifiedName().toString()));</span>
      }
    }
<span class="nc" id="L5624">  }</span>

  /**
   * Validates snapshot to a table.
   *
   * @param node  The node to validate
   * @param scope Validator scope to derive type
   * @param ns    The namespace to lookup table
   */
  private void validateSnapshot(
      SqlNode node,
      @Nullable SqlValidatorScope scope,
      SqlValidatorNamespace ns) {
<span class="nc bnc" id="L5637" title="All 2 branches missed.">    if (node.getKind() == SqlKind.SNAPSHOT) {</span>
<span class="nc" id="L5638">      SqlSnapshot snapshot = (SqlSnapshot) node;</span>
<span class="nc" id="L5639">      SqlNode period = snapshot.getPeriod();</span>
<span class="nc" id="L5640">      RelDataType dataType = deriveType(requireNonNull(scope, &quot;scope&quot;), period);</span>
<span class="nc bnc" id="L5641" title="All 2 branches missed.">      if (!SqlTypeUtil.isTimestamp(dataType)) {</span>
<span class="nc" id="L5642">        throw newValidationError(period,</span>
<span class="nc" id="L5643">            Static.RESOURCE.illegalExpressionForTemporal(dataType.getSqlTypeName().getName()));</span>
      }
<span class="nc" id="L5645">      SqlValidatorTable table = getTable(ns);</span>
<span class="nc bnc" id="L5646" title="All 2 branches missed.">      if (!table.isTemporal()) {</span>
<span class="nc" id="L5647">        List&lt;String&gt; qualifiedName = table.getQualifiedName();</span>
<span class="nc" id="L5648">        String tableName = qualifiedName.get(qualifiedName.size() - 1);</span>
<span class="nc" id="L5649">        throw newValidationError(snapshot.getTableRef(),</span>
<span class="nc" id="L5650">            Static.RESOURCE.notTemporalTable(tableName));</span>
      }
    }
<span class="nc" id="L5653">  }</span>

  /**
   * Validates a VALUES clause.
   *
   * @param node          Values clause
   * @param targetRowType Row type which expression must conform to
   * @param scope         Scope within which clause occurs
   */
  protected void validateValues(
      SqlCall node,
      RelDataType targetRowType,
      final SqlValidatorScope scope) {
<span class="nc bnc" id="L5666" title="All 2 branches missed.">    assert node.getKind() == SqlKind.VALUES;</span>

<span class="nc" id="L5668">    final List&lt;SqlNode&gt; operands = node.getOperandList();</span>
<span class="nc bnc" id="L5669" title="All 2 branches missed.">    for (SqlNode operand : operands) {</span>
<span class="nc bnc" id="L5670" title="All 2 branches missed.">      if (!(operand.getKind() == SqlKind.ROW)) {</span>
<span class="nc" id="L5671">        throw Util.needToImplement(</span>
            &quot;Values function where operands are scalars&quot;);
      }

<span class="nc" id="L5675">      SqlCall rowConstructor = (SqlCall) operand;</span>
<span class="nc bnc" id="L5676" title="All 2 branches missed.">      if (this.config.conformance().isInsertSubsetColumnsAllowed()</span>
<span class="nc bnc" id="L5677" title="All 2 branches missed.">          &amp;&amp; targetRowType.isStruct()</span>
<span class="nc bnc" id="L5678" title="All 2 branches missed.">          &amp;&amp; rowConstructor.operandCount() &lt; targetRowType.getFieldCount()) {</span>
<span class="nc" id="L5679">        targetRowType =</span>
<span class="nc" id="L5680">            typeFactory.createStructType(</span>
<span class="nc" id="L5681">                targetRowType.getFieldList()</span>
<span class="nc" id="L5682">                    .subList(0, rowConstructor.operandCount()));</span>
<span class="nc bnc" id="L5683" title="All 2 branches missed.">      } else if (targetRowType.isStruct()</span>
<span class="nc bnc" id="L5684" title="All 2 branches missed.">          &amp;&amp; rowConstructor.operandCount() != targetRowType.getFieldCount()) {</span>
<span class="nc" id="L5685">        return;</span>
      }

<span class="nc" id="L5688">      inferUnknownTypes(</span>
          targetRowType,
          scope,
          rowConstructor);

<span class="nc bnc" id="L5693" title="All 2 branches missed.">      if (targetRowType.isStruct()) {</span>
        for (Pair&lt;SqlNode, RelDataTypeField&gt; pair
<span class="nc bnc" id="L5695" title="All 2 branches missed.">            : Pair.zip(rowConstructor.getOperandList(),</span>
<span class="nc" id="L5696">                targetRowType.getFieldList())) {</span>
<span class="nc bnc" id="L5697" title="All 2 branches missed.">          if (!pair.right.getType().isNullable()</span>
<span class="nc bnc" id="L5698" title="All 2 branches missed.">              &amp;&amp; SqlUtil.isNullLiteral(pair.left, false)) {</span>
<span class="nc" id="L5699">            throw newValidationError(node,</span>
<span class="nc" id="L5700">                RESOURCE.columnNotNullable(pair.right.getName()));</span>
          }
<span class="nc" id="L5702">        }</span>
      }
<span class="nc" id="L5704">    }</span>

<span class="nc bnc" id="L5706" title="All 2 branches missed.">    for (SqlNode operand : operands) {</span>
<span class="nc" id="L5707">      operand.validate(this, scope);</span>
<span class="nc" id="L5708">    }</span>

    // validate that all row types have the same number of columns
    //  and that expressions in each column are compatible.
    // A values expression is turned into something that looks like
    // ROW(type00, type01,...), ROW(type11,...),...
<span class="nc" id="L5714">    final int rowCount = operands.size();</span>
<span class="nc bnc" id="L5715" title="All 2 branches missed.">    if (rowCount &gt;= 2) {</span>
<span class="nc" id="L5716">      SqlCall firstRow = (SqlCall) operands.get(0);</span>
<span class="nc" id="L5717">      final int columnCount = firstRow.operandCount();</span>

      // 1. check that all rows have the same cols length
<span class="nc bnc" id="L5720" title="All 2 branches missed.">      for (SqlNode operand : operands) {</span>
<span class="nc" id="L5721">        SqlCall thisRow = (SqlCall) operand;</span>
<span class="nc bnc" id="L5722" title="All 2 branches missed.">        if (columnCount != thisRow.operandCount()) {</span>
<span class="nc" id="L5723">          throw newValidationError(node,</span>
<span class="nc" id="L5724">              RESOURCE.incompatibleValueType(</span>
<span class="nc" id="L5725">                  SqlStdOperatorTable.VALUES.getName()));</span>
        }
<span class="nc" id="L5727">      }</span>

      // 2. check if types at i:th position in each row are compatible
<span class="nc bnc" id="L5730" title="All 2 branches missed.">      for (int col = 0; col &lt; columnCount; col++) {</span>
<span class="nc" id="L5731">        final int c = col;</span>
<span class="nc" id="L5732">        final RelDataType type =</span>
<span class="nc" id="L5733">            typeFactory.leastRestrictive(</span>
<span class="nc" id="L5734">                new AbstractList&lt;RelDataType&gt;() {</span>
                  @Override public RelDataType get(int row) {
<span class="nc" id="L5736">                    SqlCall thisRow = (SqlCall) operands.get(row);</span>
<span class="nc" id="L5737">                    return deriveType(scope, thisRow.operand(c));</span>
                  }

                  @Override public int size() {
<span class="nc" id="L5741">                    return rowCount;</span>
                  }
                });

<span class="nc bnc" id="L5745" title="All 2 branches missed.">        if (null == type) {</span>
<span class="nc" id="L5746">          throw newValidationError(node,</span>
<span class="nc" id="L5747">              RESOURCE.incompatibleValueType(</span>
<span class="nc" id="L5748">                  SqlStdOperatorTable.VALUES.getName()));</span>
        }
      }
    }
<span class="nc" id="L5752">  }</span>

  @Override public void validateDataType(SqlDataTypeSpec dataType) {
<span class="nc" id="L5755">  }</span>

  @Override public void validateDynamicParam(SqlDynamicParam dynamicParam) {
<span class="nc" id="L5758">  }</span>

  /**
   * Throws a validator exception with access to the validator context.
   * The exception is determined when an instance is created.
   */
  private class ValidationError implements Supplier&lt;CalciteContextException&gt; {
    private final SqlNode sqlNode;
    private final Resources.ExInst&lt;SqlValidatorException&gt; validatorException;

    ValidationError(SqlNode sqlNode,
<span class="nc" id="L5769">        Resources.ExInst&lt;SqlValidatorException&gt; validatorException) {</span>
<span class="nc" id="L5770">      this.sqlNode = sqlNode;</span>
<span class="nc" id="L5771">      this.validatorException = validatorException;</span>
<span class="nc" id="L5772">    }</span>

    @Override public CalciteContextException get() {
<span class="nc" id="L5775">      return newValidationError(sqlNode, validatorException);</span>
    }
  }

  /**
   * Throws a validator exception with access to the validator context.
   * The exception is determined when the function is applied.
   */
<span class="nc" id="L5783">  class ValidationErrorFunction</span>
      implements BiFunction&lt;SqlNode, Resources.ExInst&lt;SqlValidatorException&gt;,
            CalciteContextException&gt; {
    @Override public CalciteContextException apply(
        SqlNode v0, Resources.ExInst&lt;SqlValidatorException&gt; v1) {
<span class="nc" id="L5788">      return newValidationError(v0, v1);</span>
    }
  }

  public ValidationErrorFunction getValidationErrorFunction() {
<span class="nc" id="L5793">    return validationErrorFunction;</span>
  }

  @Override public CalciteContextException newValidationError(SqlNode node,
      Resources.ExInst&lt;SqlValidatorException&gt; e) {
<span class="nc" id="L5798">    requireNonNull(node, &quot;node&quot;);</span>
<span class="nc" id="L5799">    final SqlParserPos pos = node.getParserPosition();</span>
<span class="nc" id="L5800">    return SqlUtil.newContextException(pos, e);</span>
  }

  protected SqlWindow getWindowByName(
      SqlIdentifier id,
      SqlValidatorScope scope) {
<span class="nc" id="L5806">    SqlWindow window = null;</span>
<span class="nc bnc" id="L5807" title="All 2 branches missed.">    if (id.isSimple()) {</span>
<span class="nc" id="L5808">      final String name = id.getSimple();</span>
<span class="nc" id="L5809">      window = scope.lookupWindow(name);</span>
    }
<span class="nc bnc" id="L5811" title="All 2 branches missed.">    if (window == null) {</span>
<span class="nc" id="L5812">      throw newValidationError(id, RESOURCE.windowNotFound(id.toString()));</span>
    }
<span class="nc" id="L5814">    return window;</span>
  }

  @Override public SqlWindow resolveWindow(
      SqlNode windowOrRef,
      SqlValidatorScope scope) {
    SqlWindow window;
<span class="nc bnc" id="L5821" title="All 2 branches missed.">    if (windowOrRef instanceof SqlIdentifier) {</span>
<span class="nc" id="L5822">      window = getWindowByName((SqlIdentifier) windowOrRef, scope);</span>
    } else {
<span class="nc" id="L5824">      window = (SqlWindow) windowOrRef;</span>
    }
    while (true) {
<span class="nc" id="L5827">      final SqlIdentifier refId = window.getRefName();</span>
<span class="nc bnc" id="L5828" title="All 2 branches missed.">      if (refId == null) {</span>
<span class="nc" id="L5829">        break;</span>
      }
<span class="nc" id="L5831">      final String refName = refId.getSimple();</span>
<span class="nc" id="L5832">      SqlWindow refWindow = scope.lookupWindow(refName);</span>
<span class="nc bnc" id="L5833" title="All 2 branches missed.">      if (refWindow == null) {</span>
<span class="nc" id="L5834">        throw newValidationError(refId, RESOURCE.windowNotFound(refName));</span>
      }
<span class="nc" id="L5836">      window = window.overlay(refWindow, this);</span>
<span class="nc" id="L5837">    }</span>

<span class="nc" id="L5839">    return window;</span>
  }

  public SqlNode getOriginal(SqlNode expr) {
<span class="nc" id="L5843">    SqlNode original = originalExprs.get(expr);</span>
<span class="nc bnc" id="L5844" title="All 2 branches missed.">    if (original == null) {</span>
<span class="nc" id="L5845">      original = expr;</span>
    }
<span class="nc" id="L5847">    return original;</span>
  }

  public void setOriginal(SqlNode expr, SqlNode original) {
    // Don't overwrite the original original.
<span class="nc" id="L5852">    originalExprs.putIfAbsent(expr, original);</span>
<span class="nc" id="L5853">  }</span>

  @Nullable SqlValidatorNamespace lookupFieldNamespace(RelDataType rowType, String name) {
<span class="nc" id="L5856">    final SqlNameMatcher nameMatcher = catalogReader.nameMatcher();</span>
<span class="nc" id="L5857">    final RelDataTypeField field = nameMatcher.field(rowType, name);</span>
<span class="nc bnc" id="L5858" title="All 2 branches missed.">    if (field == null) {</span>
<span class="nc" id="L5859">      return null;</span>
    }
<span class="nc" id="L5861">    return new FieldNamespace(this, field.getType());</span>
  }

  @Override public void validateWindow(
      SqlNode windowOrId,
      SqlValidatorScope scope,
      @Nullable SqlCall call) {
    // Enable nested aggregates with window aggregates (OVER operator)
<span class="nc" id="L5869">    inWindow = true;</span>

    final SqlWindow targetWindow;
<span class="nc bnc" id="L5872" title="All 3 branches missed.">    switch (windowOrId.getKind()) {</span>
    case IDENTIFIER:
      // Just verify the window exists in this query.  It will validate
      // when the definition is processed
<span class="nc" id="L5876">      targetWindow = getWindowByName((SqlIdentifier) windowOrId, scope);</span>
<span class="nc" id="L5877">      break;</span>
    case WINDOW:
<span class="nc" id="L5879">      targetWindow = (SqlWindow) windowOrId;</span>
<span class="nc" id="L5880">      break;</span>
    default:
<span class="nc" id="L5882">      throw Util.unexpected(windowOrId.getKind());</span>
    }

<span class="nc" id="L5885">    requireNonNull(call, () -&gt; &quot;call is null when validating windowOrId &quot; + windowOrId);</span>
<span class="nc bnc" id="L5886" title="All 2 branches missed.">    assert targetWindow.getWindowCall() == null;</span>
<span class="nc" id="L5887">    targetWindow.setWindowCall(call);</span>
<span class="nc" id="L5888">    targetWindow.validate(this, scope);</span>
<span class="nc" id="L5889">    targetWindow.setWindowCall(null);</span>
<span class="nc" id="L5890">    call.validate(this, scope);</span>

<span class="nc" id="L5892">    validateAggregateParams(call, null, null, null, scope);</span>

    // Disable nested aggregates post validation
<span class="nc" id="L5895">    inWindow = false;</span>
<span class="nc" id="L5896">  }</span>

  @Override public void validateLambda(SqlLambda lambdaExpr) {
<span class="nc" id="L5899">    final SqlLambdaScope scope = (SqlLambdaScope) scopes.get(lambdaExpr);</span>
<span class="nc" id="L5900">    requireNonNull(scope, &quot;scope&quot;);</span>
<span class="nc" id="L5901">    final LambdaNamespace ns =</span>
<span class="nc" id="L5902">        getNamespaceOrThrow(lambdaExpr).unwrap(LambdaNamespace.class);</span>

<span class="nc" id="L5904">    deriveType(scope, lambdaExpr.getExpression());</span>
<span class="nc" id="L5905">    RelDataType type = deriveTypeImpl(scope, lambdaExpr);</span>
<span class="nc" id="L5906">    setValidatedNodeType(lambdaExpr, type);</span>
<span class="nc" id="L5907">    ns.setType(type);</span>
<span class="nc" id="L5908">  }</span>

  @Override public void validateMatchRecognize(SqlCall call) {
<span class="nc" id="L5911">    final SqlMatchRecognize matchRecognize = (SqlMatchRecognize) call;</span>
<span class="nc" id="L5912">    final MatchRecognizeScope scope =</span>
<span class="nc" id="L5913">        (MatchRecognizeScope) getMatchRecognizeScope(matchRecognize);</span>

<span class="nc" id="L5915">    final MatchRecognizeNamespace ns =</span>
<span class="nc" id="L5916">        getNamespaceOrThrow(call).unwrap(MatchRecognizeNamespace.class);</span>
<span class="nc bnc" id="L5917" title="All 2 branches missed.">    assert ns.rowType == null;</span>

    // rows per match
<span class="nc" id="L5920">    final SqlLiteral rowsPerMatch = matchRecognize.getRowsPerMatch();</span>
<span class="nc bnc" id="L5921" title="All 2 branches missed.">    final boolean allRows = rowsPerMatch != null</span>
<span class="nc bnc" id="L5922" title="All 2 branches missed.">        &amp;&amp; rowsPerMatch.getValue()</span>
        == SqlMatchRecognize.RowsPerMatchOption.ALL_ROWS;

<span class="nc" id="L5925">    final RelDataTypeFactory.Builder typeBuilder = typeFactory.builder();</span>

    // parse PARTITION BY column
<span class="nc bnc" id="L5928" title="All 2 branches missed.">    for (SqlNode node : matchRecognize.getPartitionList()) {</span>
<span class="nc" id="L5929">      SqlIdentifier identifier = (SqlIdentifier) node;</span>
<span class="nc" id="L5930">      identifier.validate(this, scope);</span>
<span class="nc" id="L5931">      RelDataType type = deriveType(scope, identifier);</span>
<span class="nc" id="L5932">      String name = identifier.names.get(1);</span>
<span class="nc" id="L5933">      typeBuilder.add(name, type);</span>
<span class="nc" id="L5934">    }</span>

    // parse ORDER BY column
<span class="nc bnc" id="L5937" title="All 2 branches missed.">    for (SqlNode node : matchRecognize.getOrderList()) {</span>
<span class="nc" id="L5938">      node.validate(this, scope);</span>
      SqlIdentifier identifier;
<span class="nc bnc" id="L5940" title="All 2 branches missed.">      if (node instanceof SqlBasicCall) {</span>
<span class="nc" id="L5941">        identifier = ((SqlBasicCall) node).operand(0);</span>
      } else {
<span class="nc" id="L5943">        identifier =</span>
<span class="nc" id="L5944">            requireNonNull((SqlIdentifier) node,</span>
<span class="nc" id="L5945">                () -&gt; &quot;order by field is null. All fields: &quot;</span>
<span class="nc" id="L5946">                    + matchRecognize.getOrderList());</span>
      }

<span class="nc bnc" id="L5949" title="All 2 branches missed.">      if (allRows) {</span>
<span class="nc" id="L5950">        RelDataType type = deriveType(scope, identifier);</span>
<span class="nc" id="L5951">        String name = identifier.names.get(1);</span>
<span class="nc bnc" id="L5952" title="All 2 branches missed.">        if (!typeBuilder.nameExists(name)) {</span>
<span class="nc" id="L5953">          typeBuilder.add(name, type);</span>
        }
      }
<span class="nc" id="L5956">    }</span>

<span class="nc bnc" id="L5958" title="All 2 branches missed.">    if (allRows) {</span>
<span class="nc" id="L5959">      final SqlValidatorNamespace sqlNs =</span>
<span class="nc" id="L5960">          getNamespaceOrThrow(matchRecognize.getTableRef());</span>
<span class="nc" id="L5961">      final RelDataType inputDataType = sqlNs.getRowType();</span>
<span class="nc bnc" id="L5962" title="All 2 branches missed.">      for (RelDataTypeField fs : inputDataType.getFieldList()) {</span>
<span class="nc bnc" id="L5963" title="All 2 branches missed.">        if (!typeBuilder.nameExists(fs.getName())) {</span>
<span class="nc" id="L5964">          typeBuilder.add(fs);</span>
        }
<span class="nc" id="L5966">      }</span>
    }

    // retrieve pattern variables used in pattern and subset
<span class="nc" id="L5970">    SqlNode pattern = matchRecognize.getPattern();</span>
<span class="nc" id="L5971">    PatternVarVisitor visitor = new PatternVarVisitor(scope);</span>
<span class="nc" id="L5972">    pattern.accept(visitor);</span>

<span class="nc" id="L5974">    SqlLiteral interval = matchRecognize.getInterval();</span>
<span class="nc bnc" id="L5975" title="All 2 branches missed.">    if (interval != null) {</span>
<span class="nc" id="L5976">      interval.validate(this, scope);</span>
<span class="nc bnc" id="L5977" title="All 2 branches missed.">      if (((SqlIntervalLiteral) interval).signum() &lt; 0) {</span>
<span class="nc" id="L5978">        String intervalValue = interval.toValue();</span>
<span class="nc" id="L5979">        throw newValidationError(interval,</span>
<span class="nc" id="L5980">            RESOURCE.intervalMustBeNonNegative(</span>
<span class="nc bnc" id="L5981" title="All 2 branches missed.">                intervalValue != null ? intervalValue : interval.toString()));</span>
      }
<span class="nc bnc" id="L5983" title="All 2 branches missed.">      if (matchRecognize.getOrderList().isEmpty()) {</span>
<span class="nc" id="L5984">        throw newValidationError(interval,</span>
<span class="nc" id="L5985">            RESOURCE.cannotUseWithinWithoutOrderBy());</span>
      }

<span class="nc" id="L5988">      SqlNode firstOrderByColumn = matchRecognize.getOrderList().get(0);</span>
      SqlIdentifier identifier;
<span class="nc bnc" id="L5990" title="All 2 branches missed.">      if (firstOrderByColumn instanceof SqlBasicCall) {</span>
<span class="nc" id="L5991">        identifier = ((SqlBasicCall) firstOrderByColumn).operand(0);</span>
      } else {
<span class="nc" id="L5993">        identifier =</span>
<span class="nc" id="L5994">            (SqlIdentifier) requireNonNull(firstOrderByColumn,</span>
                &quot;firstOrderByColumn&quot;);
      }
<span class="nc" id="L5997">      RelDataType firstOrderByColumnType = deriveType(scope, identifier);</span>
<span class="nc bnc" id="L5998" title="All 2 branches missed.">      if (!SqlTypeUtil.isTimestamp(firstOrderByColumnType)) {</span>
<span class="nc" id="L5999">        throw newValidationError(interval,</span>
<span class="nc" id="L6000">          RESOURCE.firstColumnOfOrderByMustBeTimestamp());</span>
      }

<span class="nc" id="L6003">      SqlNode expand = expand(interval, scope);</span>
<span class="nc" id="L6004">      RelDataType type = deriveType(scope, expand);</span>
<span class="nc" id="L6005">      setValidatedNodeType(interval, type);</span>
    }

<span class="nc" id="L6008">    validateDefinitions(matchRecognize, scope);</span>

<span class="nc" id="L6010">    SqlNodeList subsets = matchRecognize.getSubsetList();</span>
<span class="nc bnc" id="L6011" title="All 2 branches missed.">    if (!subsets.isEmpty()) {</span>
<span class="nc bnc" id="L6012" title="All 2 branches missed.">      for (SqlNode node : subsets) {</span>
<span class="nc" id="L6013">        List&lt;SqlNode&gt; operands = ((SqlCall) node).getOperandList();</span>
<span class="nc" id="L6014">        String leftString = ((SqlIdentifier) operands.get(0)).getSimple();</span>
<span class="nc bnc" id="L6015" title="All 2 branches missed.">        if (scope.getPatternVars().contains(leftString)) {</span>
<span class="nc" id="L6016">          throw newValidationError(operands.get(0),</span>
<span class="nc" id="L6017">              RESOURCE.patternVarAlreadyDefined(leftString));</span>
        }
<span class="nc" id="L6019">        scope.addPatternVar(leftString);</span>
<span class="nc bnc" id="L6020" title="All 2 branches missed.">        for (SqlNode right : (SqlNodeList) operands.get(1)) {</span>
<span class="nc" id="L6021">          SqlIdentifier id = (SqlIdentifier) right;</span>
<span class="nc bnc" id="L6022" title="All 2 branches missed.">          if (!scope.getPatternVars().contains(id.getSimple())) {</span>
<span class="nc" id="L6023">            throw newValidationError(id,</span>
<span class="nc" id="L6024">                RESOURCE.unknownPattern(id.getSimple()));</span>
          }
<span class="nc" id="L6026">          scope.addPatternVar(id.getSimple());</span>
<span class="nc" id="L6027">        }</span>
<span class="nc" id="L6028">      }</span>
    }

    // validate AFTER ... SKIP TO
<span class="nc" id="L6032">    final SqlNode skipTo = matchRecognize.getAfter();</span>
<span class="nc bnc" id="L6033" title="All 2 branches missed.">    if (skipTo instanceof SqlCall) {</span>
<span class="nc" id="L6034">      final SqlCall skipToCall = (SqlCall) skipTo;</span>
<span class="nc" id="L6035">      final SqlIdentifier id = skipToCall.operand(0);</span>
<span class="nc bnc" id="L6036" title="All 2 branches missed.">      if (!scope.getPatternVars().contains(id.getSimple())) {</span>
<span class="nc" id="L6037">        throw newValidationError(id,</span>
<span class="nc" id="L6038">            RESOURCE.unknownPattern(id.getSimple()));</span>
      }
    }

<span class="nc" id="L6042">    PairList&lt;String, RelDataType&gt; measureColumns =</span>
<span class="nc" id="L6043">        validateMeasure(matchRecognize, scope, allRows);</span>
<span class="nc" id="L6044">    measureColumns.forEach((name, type) -&gt; {</span>
<span class="nc bnc" id="L6045" title="All 2 branches missed.">      if (!typeBuilder.nameExists(name)) {</span>
<span class="nc" id="L6046">        typeBuilder.add(name, type);</span>
      }
<span class="nc" id="L6048">    });</span>

    final RelDataType rowType;
<span class="nc bnc" id="L6051" title="All 2 branches missed.">    if (matchRecognize.getMeasureList().isEmpty()) {</span>
<span class="nc" id="L6052">      rowType = getNamespaceOrThrow(matchRecognize.getTableRef()).getRowType();</span>
    } else {
<span class="nc" id="L6054">      rowType = typeBuilder.build();</span>
    }
<span class="nc" id="L6056">    ns.setType(rowType);</span>
<span class="nc" id="L6057">  }</span>

  private PairList&lt;String, RelDataType&gt; validateMeasure(SqlMatchRecognize mr,
      MatchRecognizeScope scope, boolean allRows) {
<span class="nc" id="L6061">    final List&lt;String&gt; aliases = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L6062">    final List&lt;SqlNode&gt; sqlNodes = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L6063">    final SqlNodeList measures = mr.getMeasureList();</span>
<span class="nc" id="L6064">    final PairList&lt;String, RelDataType&gt; fields = PairList.of();</span>

<span class="nc bnc" id="L6066" title="All 2 branches missed.">    for (SqlNode measure : measures) {</span>
<span class="nc bnc" id="L6067" title="All 2 branches missed.">      assert measure instanceof SqlCall;</span>
<span class="nc" id="L6068">      final String alias = SqlValidatorUtil.alias(measure, aliases.size());</span>
<span class="nc" id="L6069">      aliases.add(alias);</span>

<span class="nc" id="L6071">      SqlNode expand = expand(measure, scope);</span>
<span class="nc" id="L6072">      expand = navigationInMeasure(expand, allRows);</span>
<span class="nc" id="L6073">      setOriginal(expand, measure);</span>

<span class="nc" id="L6075">      inferUnknownTypes(unknownType, scope, expand);</span>
<span class="nc" id="L6076">      final RelDataType type = deriveType(scope, expand);</span>
<span class="nc" id="L6077">      setValidatedNodeType(measure, type);</span>

<span class="nc" id="L6079">      fields.add(alias, type);</span>
<span class="nc" id="L6080">      sqlNodes.add(</span>
<span class="nc" id="L6081">          SqlStdOperatorTable.AS.createCall(SqlParserPos.ZERO, expand,</span>
              new SqlIdentifier(alias, SqlParserPos.ZERO)));
<span class="nc" id="L6083">    }</span>

<span class="nc" id="L6085">    SqlNodeList list = new SqlNodeList(sqlNodes, measures.getParserPosition());</span>
<span class="nc" id="L6086">    inferUnknownTypes(unknownType, scope, list);</span>

<span class="nc bnc" id="L6088" title="All 2 branches missed.">    for (SqlNode node : list) {</span>
<span class="nc" id="L6089">      validateExpr(node, scope);</span>
<span class="nc" id="L6090">    }</span>

<span class="nc" id="L6092">    mr.setOperand(SqlMatchRecognize.OPERAND_MEASURES, list);</span>

<span class="nc" id="L6094">    return fields;</span>
  }

  private SqlNode navigationInMeasure(SqlNode node, boolean allRows) {
<span class="nc" id="L6098">    final Set&lt;String&gt; prefix = node.accept(new PatternValidator(true));</span>
<span class="nc" id="L6099">    Util.discard(prefix);</span>
<span class="nc" id="L6100">    final List&lt;SqlNode&gt; ops = ((SqlCall) node).getOperandList();</span>

    final SqlOperator defaultOp =
<span class="nc bnc" id="L6103" title="All 2 branches missed.">        allRows ? SqlStdOperatorTable.RUNNING : SqlStdOperatorTable.FINAL;</span>
<span class="nc" id="L6104">    final SqlNode op0 = ops.get(0);</span>
<span class="nc bnc" id="L6105" title="All 4 branches missed.">    if (!isRunningOrFinal(op0.getKind())</span>
<span class="nc bnc" id="L6106" title="All 2 branches missed.">        || !allRows &amp;&amp; op0.getKind() == SqlKind.RUNNING) {</span>
<span class="nc" id="L6107">      SqlNode newNode = defaultOp.createCall(SqlParserPos.ZERO, op0);</span>
<span class="nc" id="L6108">      node = SqlStdOperatorTable.AS.createCall(SqlParserPos.ZERO, newNode, ops.get(1));</span>
    }

<span class="nc" id="L6111">    node = new NavigationExpander().go(node);</span>
<span class="nc" id="L6112">    return node;</span>
  }

  private void validateDefinitions(SqlMatchRecognize mr,
      MatchRecognizeScope scope) {
<span class="nc" id="L6117">    final Set&lt;String&gt; aliases = catalogReader.nameMatcher().createSet();</span>
<span class="nc bnc" id="L6118" title="All 2 branches missed.">    for (SqlNode item : mr.getPatternDefList()) {</span>
<span class="nc" id="L6119">      final String alias = alias(item);</span>
<span class="nc bnc" id="L6120" title="All 2 branches missed.">      if (!aliases.add(alias)) {</span>
<span class="nc" id="L6121">        throw newValidationError(item,</span>
<span class="nc" id="L6122">            Static.RESOURCE.patternVarAlreadyDefined(alias));</span>
      }
<span class="nc" id="L6124">      scope.addPatternVar(alias);</span>
<span class="nc" id="L6125">    }</span>

<span class="nc" id="L6127">    final List&lt;SqlNode&gt; sqlNodes = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L6128" title="All 2 branches missed.">    for (SqlNode item : mr.getPatternDefList()) {</span>
<span class="nc" id="L6129">      final String alias = alias(item);</span>
<span class="nc" id="L6130">      SqlNode expand = expand(item, scope);</span>
<span class="nc" id="L6131">      expand = navigationInDefine(expand, alias);</span>
<span class="nc" id="L6132">      setOriginal(expand, item);</span>

<span class="nc" id="L6134">      inferUnknownTypes(booleanType, scope, expand);</span>
<span class="nc" id="L6135">      expand.validate(this, scope);</span>

      // Some extra work need required here.
      // In PREV, NEXT, FINAL and LAST, only one pattern variable is allowed.
<span class="nc" id="L6139">      sqlNodes.add(</span>
<span class="nc" id="L6140">          SqlStdOperatorTable.AS.createCall(SqlParserPos.ZERO, expand,</span>
              new SqlIdentifier(alias, SqlParserPos.ZERO)));

<span class="nc" id="L6143">      final RelDataType type = deriveType(scope, expand);</span>
<span class="nc bnc" id="L6144" title="All 2 branches missed.">      if (!SqlTypeUtil.inBooleanFamily(type)) {</span>
<span class="nc" id="L6145">        throw newValidationError(expand, RESOURCE.condMustBeBoolean(&quot;DEFINE&quot;));</span>
      }
<span class="nc" id="L6147">      setValidatedNodeType(item, type);</span>
<span class="nc" id="L6148">    }</span>

<span class="nc" id="L6150">    SqlNodeList list =</span>
<span class="nc" id="L6151">        new SqlNodeList(sqlNodes, mr.getPatternDefList().getParserPosition());</span>
<span class="nc" id="L6152">    inferUnknownTypes(unknownType, scope, list);</span>
<span class="nc bnc" id="L6153" title="All 2 branches missed.">    for (SqlNode node : list) {</span>
<span class="nc" id="L6154">      validateExpr(node, scope);</span>
<span class="nc" id="L6155">    }</span>
<span class="nc" id="L6156">    mr.setOperand(SqlMatchRecognize.OPERAND_PATTERN_DEFINES, list);</span>
<span class="nc" id="L6157">  }</span>

  /** Returns the alias of a &quot;expr AS alias&quot; expression. */
  private static String alias(SqlNode item) {
<span class="nc bnc" id="L6161" title="All 2 branches missed.">    assert item instanceof SqlCall;</span>
<span class="nc bnc" id="L6162" title="All 2 branches missed.">    assert item.getKind() == SqlKind.AS;</span>
<span class="nc" id="L6163">    final SqlIdentifier identifier = ((SqlCall) item).operand(1);</span>
<span class="nc" id="L6164">    return identifier.getSimple();</span>
  }

  public void validatePivot(SqlPivot pivot) {
<span class="nc" id="L6168">    final PivotScope scope = (PivotScope) getJoinScope(pivot);</span>

<span class="nc" id="L6170">    final PivotNamespace ns =</span>
<span class="nc" id="L6171">        getNamespaceOrThrow(pivot).unwrap(PivotNamespace.class);</span>
<span class="nc bnc" id="L6172" title="All 2 branches missed.">    assert ns.rowType == null;</span>

    // Given
    //   query PIVOT (agg1 AS a, agg2 AS b, ...
    //   FOR (axis1, ..., axisN)
    //   IN ((v11, ..., v1N) AS label1,
    //       (v21, ..., v2N) AS label2, ...))
    // the type is
    //   k1, ... kN, a_label1, b_label1, ..., a_label2, b_label2, ...
    // where k1, ... kN are columns that are not referenced as an argument to
    // an aggregate or as an axis.

    // Aggregates, e.g. &quot;PIVOT (sum(x) AS sum_x, count(*) AS c)&quot;
<span class="nc" id="L6185">    final PairList&lt;@Nullable String, RelDataType&gt; aggNames = PairList.of();</span>
<span class="nc" id="L6186">    pivot.forEachAgg((alias, call) -&gt; {</span>
<span class="nc" id="L6187">      call.validate(this, scope);</span>
<span class="nc" id="L6188">      final RelDataType type = deriveType(scope, call);</span>
<span class="nc" id="L6189">      aggNames.add(alias, type);</span>
<span class="nc bnc" id="L6190" title="All 2 branches missed.">      if (!(call instanceof SqlCall)</span>
<span class="nc bnc" id="L6191" title="All 2 branches missed.">          || !(((SqlCall) call).getOperator() instanceof SqlAggFunction)) {</span>
<span class="nc" id="L6192">        throw newValidationError(call, RESOURCE.pivotAggMalformed());</span>
      }
<span class="nc" id="L6194">    });</span>

    // Axes, e.g. &quot;FOR (JOB, DEPTNO)&quot;
<span class="nc" id="L6197">    final List&lt;RelDataType&gt; axisTypes = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L6198">    final List&lt;SqlIdentifier&gt; axisIdentifiers = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L6199" title="All 2 branches missed.">    for (SqlNode axis : pivot.axisList) {</span>
<span class="nc" id="L6200">      SqlIdentifier identifier = (SqlIdentifier) axis;</span>
<span class="nc" id="L6201">      identifier.validate(this, scope);</span>
<span class="nc" id="L6202">      final RelDataType type = deriveType(scope, identifier);</span>
<span class="nc" id="L6203">      axisTypes.add(type);</span>
<span class="nc" id="L6204">      axisIdentifiers.add(identifier);</span>
<span class="nc" id="L6205">    }</span>

    // Columns that have been seen as arguments to aggregates or as axes
    // do not appear in the output.
<span class="nc" id="L6209">    final Set&lt;String&gt; columnNames = pivot.usedColumnNames();</span>
<span class="nc" id="L6210">    final RelDataTypeFactory.Builder typeBuilder = typeFactory.builder();</span>
<span class="nc" id="L6211">    scope.getChild().getRowType().getFieldList().forEach(field -&gt; {</span>
<span class="nc bnc" id="L6212" title="All 2 branches missed.">      if (!columnNames.contains(field.getName())) {</span>
<span class="nc" id="L6213">        typeBuilder.add(field);</span>
      }
<span class="nc" id="L6215">    });</span>

    // Values, e.g. &quot;IN (('CLERK', 10) AS c10, ('MANAGER, 20) AS m20)&quot;
<span class="nc" id="L6218">    pivot.forEachNameValues((alias, nodeList) -&gt; {</span>
<span class="nc bnc" id="L6219" title="All 2 branches missed.">      if (nodeList.size() != axisTypes.size()) {</span>
<span class="nc" id="L6220">        throw newValidationError(nodeList,</span>
<span class="nc" id="L6221">            RESOURCE.pivotValueArityMismatch(nodeList.size(),</span>
<span class="nc" id="L6222">                axisTypes.size()));</span>
      }
<span class="nc" id="L6224">      final SqlOperandTypeChecker typeChecker =</span>
          OperandTypes.COMPARABLE_UNORDERED_COMPARABLE_UNORDERED;
<span class="nc" id="L6226">      Pair.forEach(axisIdentifiers, nodeList, (identifier, subNode) -&gt; {</span>
<span class="nc" id="L6227">        subNode.validate(this, scope);</span>
<span class="nc" id="L6228">        typeChecker.checkOperandTypes(</span>
            new SqlCallBinding(this, scope,
<span class="nc" id="L6230">                SqlStdOperatorTable.EQUALS.createCall(</span>
<span class="nc" id="L6231">                    subNode.getParserPosition(), identifier, subNode)),</span>
            true);
<span class="nc" id="L6233">      });</span>
<span class="nc" id="L6234">      aggNames.forEach((aggAlias, aggType) -&gt;</span>
<span class="nc bnc" id="L6235" title="All 2 branches missed.">          typeBuilder.add(aggAlias == null ? alias : alias + &quot;_&quot; + aggAlias,</span>
              aggType));
<span class="nc" id="L6237">    });</span>

<span class="nc" id="L6239">    final RelDataType rowType = typeBuilder.build();</span>
<span class="nc" id="L6240">    ns.setType(rowType);</span>
<span class="nc" id="L6241">  }</span>

  public void validateUnpivot(SqlUnpivot unpivot) {
<span class="nc" id="L6244">    final UnpivotScope scope = (UnpivotScope) getJoinScope(unpivot);</span>

<span class="nc" id="L6246">    final UnpivotNamespace ns =</span>
<span class="nc" id="L6247">        getNamespaceOrThrow(unpivot).unwrap(UnpivotNamespace.class);</span>
<span class="nc bnc" id="L6248" title="All 2 branches missed.">    assert ns.rowType == null;</span>

    // Given
    //   query UNPIVOT ((measure1, ..., measureM)
    //   FOR (axis1, ..., axisN)
    //   IN ((c11, ..., c1M) AS (value11, ..., value1N),
    //       (c21, ..., c2M) AS (value21, ..., value2N), ...)
    // the type is
    //   k1, ... kN, axis1, ..., axisN, measure1, ..., measureM
    // where k1, ... kN are columns that are not referenced as an argument to
    // an aggregate or as an axis.

    // First, And make sure that each
<span class="nc" id="L6261">    final int measureCount = unpivot.measureList.size();</span>
<span class="nc" id="L6262">    final int axisCount = unpivot.axisList.size();</span>
<span class="nc" id="L6263">    unpivot.forEachNameValues((nodeList, valueList) -&gt; {</span>
      // Make sure that each (ci1, ... ciM) list has the same arity as
      // (measure1, ..., measureM).
<span class="nc bnc" id="L6266" title="All 2 branches missed.">      if (nodeList.size() != measureCount) {</span>
<span class="nc" id="L6267">        throw newValidationError(nodeList,</span>
<span class="nc" id="L6268">            RESOURCE.unpivotValueArityMismatch(nodeList.size(),</span>
                measureCount));
      }

      // Make sure that each (vi1, ... viN) list has the same arity as
      // (axis1, ..., axisN).
<span class="nc bnc" id="L6274" title="All 4 branches missed.">      if (valueList != null &amp;&amp; valueList.size() != axisCount) {</span>
<span class="nc" id="L6275">        throw newValidationError(valueList,</span>
<span class="nc" id="L6276">            RESOURCE.unpivotValueArityMismatch(valueList.size(),</span>
                axisCount));
      }

      // Make sure that each IN expression is a valid column from the input.
<span class="nc" id="L6281">      nodeList.forEach(node -&gt; deriveType(scope, node));</span>
<span class="nc" id="L6282">    });</span>

    // What columns from the input are not referenced by a column in the IN
    // list?
<span class="nc" id="L6286">    final SqlValidatorNamespace inputNs =</span>
<span class="nc" id="L6287">        requireNonNull(getNamespace(unpivot.query));</span>
<span class="nc" id="L6288">    final Set&lt;String&gt; unusedColumnNames =</span>
<span class="nc" id="L6289">        catalogReader.nameMatcher().createSet();</span>
<span class="nc" id="L6290">    unusedColumnNames.addAll(inputNs.getRowType().getFieldNames());</span>
<span class="nc" id="L6291">    unusedColumnNames.removeAll(unpivot.usedColumnNames());</span>

    // What columns will be present in the output row type?
<span class="nc" id="L6294">    final Set&lt;String&gt; columnNames = catalogReader.nameMatcher().createSet();</span>
<span class="nc" id="L6295">    columnNames.addAll(unusedColumnNames);</span>

    // Gather the name and type of each measure.
<span class="nc" id="L6298">    final PairList&lt;String, RelDataType&gt; measureNameTypes = PairList.of();</span>
<span class="nc" id="L6299">    forEach(unpivot.measureList, (measure, i) -&gt; {</span>
<span class="nc" id="L6300">      final String measureName = ((SqlIdentifier) measure).getSimple();</span>
<span class="nc" id="L6301">      final List&lt;RelDataType&gt; types = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L6302">      final List&lt;SqlNode&gt; nodes = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L6303">      unpivot.forEachNameValues((nodeList, valueList) -&gt; {</span>
<span class="nc" id="L6304">        final SqlNode alias = nodeList.get(i);</span>
<span class="nc" id="L6305">        nodes.add(alias);</span>
<span class="nc" id="L6306">        types.add(deriveType(scope, alias));</span>
<span class="nc" id="L6307">      });</span>
<span class="nc" id="L6308">      final RelDataType type0 = typeFactory.leastRestrictive(types);</span>
<span class="nc bnc" id="L6309" title="All 2 branches missed.">      if (type0 == null) {</span>
<span class="nc" id="L6310">        throw newValidationError(nodes.get(0),</span>
<span class="nc" id="L6311">            RESOURCE.unpivotCannotDeriveMeasureType(measureName));</span>
      }
<span class="nc bnc" id="L6313" title="All 2 branches missed.">      final RelDataType type =</span>
<span class="nc" id="L6314">          typeFactory.createTypeWithNullability(type0,</span>
<span class="nc bnc" id="L6315" title="All 2 branches missed.">              unpivot.includeNulls || unpivot.measureList.size() &gt; 1);</span>
<span class="nc" id="L6316">      setValidatedNodeType(measure, type);</span>
<span class="nc bnc" id="L6317" title="All 2 branches missed.">      if (!columnNames.add(measureName)) {</span>
<span class="nc" id="L6318">        throw newValidationError(measure,</span>
<span class="nc" id="L6319">            RESOURCE.unpivotDuplicate(measureName));</span>
      }
<span class="nc" id="L6321">      measureNameTypes.add(measureName, type);</span>
<span class="nc" id="L6322">    });</span>

    // Gather the name and type of each axis.
    // Consider
    //   FOR (job, deptno)
    //   IN (a AS ('CLERK', 10),
    //       b AS ('ANALYST', 20))
    // There are two axes, (job, deptno), and so each value list ('CLERK', 10),
    // ('ANALYST', 20) must have arity two.
    //
    // The type of 'job' is derived as the least restrictive type of the values
    // ('CLERK', 'ANALYST'), namely VARCHAR(7). The derived type of 'deptno' is
    // the type of values (10, 20), namely INTEGER.
<span class="nc" id="L6335">    final PairList&lt;String, RelDataType&gt; axisNameTypes = PairList.of();</span>
<span class="nc" id="L6336">    forEach(unpivot.axisList, (axis, i) -&gt; {</span>
<span class="nc" id="L6337">      final String axisName = ((SqlIdentifier) axis).getSimple();</span>
<span class="nc" id="L6338">      final List&lt;RelDataType&gt; types = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L6339">      unpivot.forEachNameValues((aliasList, valueList) -&gt;</span>
<span class="nc" id="L6340">          types.add(</span>
<span class="nc bnc" id="L6341" title="All 2 branches missed.">              valueList == null</span>
<span class="nc" id="L6342">                  ? typeFactory.createSqlType(SqlTypeName.VARCHAR,</span>
<span class="nc" id="L6343">                        SqlUnpivot.aliasValue(aliasList).length())</span>
<span class="nc" id="L6344">                  : deriveType(scope, valueList.get(i))));</span>
<span class="nc" id="L6345">      final RelDataType type = typeFactory.leastRestrictive(types);</span>
<span class="nc bnc" id="L6346" title="All 2 branches missed.">      if (type == null) {</span>
<span class="nc" id="L6347">        throw newValidationError(axis,</span>
<span class="nc" id="L6348">            RESOURCE.unpivotCannotDeriveAxisType(axisName));</span>
      }
<span class="nc" id="L6350">      setValidatedNodeType(axis, type);</span>
<span class="nc bnc" id="L6351" title="All 2 branches missed.">      if (!columnNames.add(axisName)) {</span>
<span class="nc" id="L6352">        throw newValidationError(axis, RESOURCE.unpivotDuplicate(axisName));</span>
      }
<span class="nc" id="L6354">      axisNameTypes.add(axisName, type);</span>
<span class="nc" id="L6355">    });</span>

    // Columns that have been seen as arguments to aggregates or as axes
    // do not appear in the output.
<span class="nc" id="L6359">    final RelDataTypeFactory.Builder typeBuilder = typeFactory.builder();</span>
<span class="nc" id="L6360">    scope.getChild().getRowType().getFieldList().forEach(field -&gt; {</span>
<span class="nc bnc" id="L6361" title="All 2 branches missed.">      if (unusedColumnNames.contains(field.getName())) {</span>
<span class="nc" id="L6362">        typeBuilder.add(field);</span>
      }
<span class="nc" id="L6364">    });</span>
<span class="nc" id="L6365">    typeBuilder.addAll(axisNameTypes);</span>
<span class="nc" id="L6366">    typeBuilder.addAll(measureNameTypes);</span>

<span class="nc" id="L6368">    final RelDataType rowType = typeBuilder.build();</span>
<span class="nc" id="L6369">    ns.setType(rowType);</span>
<span class="nc" id="L6370">  }</span>

  /** Checks that all pattern variables within a function are the same,
   * and canonizes expressions such as {@code PREV(B.price)} to
   * {@code LAST(B.price, 0)}. */
  private SqlNode navigationInDefine(SqlNode node, String alpha) {
<span class="nc" id="L6376">    Set&lt;String&gt; prefix = node.accept(new PatternValidator(false));</span>
<span class="nc" id="L6377">    Util.discard(prefix);</span>
<span class="nc" id="L6378">    node = new NavigationExpander().go(node);</span>
<span class="nc" id="L6379">    node = new NavigationReplacer(alpha).go(node);</span>
<span class="nc" id="L6380">    return node;</span>
  }

  @Override public void validateAggregateParams(SqlCall aggCall,
      @Nullable SqlNode filter, @Nullable SqlNodeList distinctList,
      @Nullable SqlNodeList orderList, SqlValidatorScope scope) {
    // For &quot;agg(expr)&quot;, expr cannot itself contain aggregate function
    // invocations.  For example, &quot;SUM(2 * MAX(x))&quot; is illegal; when
    // we see it, we'll report the error for the SUM (not the MAX).
    // For more than one level of nesting, the error which results
    // depends on the traversal order for validation.
    //
    // For a windowed aggregate &quot;agg(expr)&quot;, expr can contain an aggregate
    // function. For example,
    //   SELECT AVG(2 * MAX(x)) OVER (PARTITION BY y)
    //   FROM t
    //   GROUP BY y
    // is legal. Only one level of nesting is allowed since non-windowed
    // aggregates cannot nest aggregates.

    // Store nesting level of each aggregate. If an aggregate is found at an invalid
    // nesting level, throw an assert.
    final AggFinder a;
<span class="nc bnc" id="L6403" title="All 2 branches missed.">    if (inWindow) {</span>
<span class="nc" id="L6404">      a = overFinder;</span>
    } else {
<span class="nc" id="L6406">      a = aggOrOverFinder;</span>
    }

<span class="nc bnc" id="L6409" title="All 2 branches missed.">    for (SqlNode param : aggCall.getOperandList()) {</span>
<span class="nc bnc" id="L6410" title="All 2 branches missed.">      if (a.findAgg(param) != null) {</span>
<span class="nc" id="L6411">        throw newValidationError(aggCall, RESOURCE.nestedAggIllegal());</span>
      }
<span class="nc" id="L6413">    }</span>
<span class="nc bnc" id="L6414" title="All 2 branches missed.">    if (filter != null) {</span>
<span class="nc bnc" id="L6415" title="All 2 branches missed.">      if (a.findAgg(filter) != null) {</span>
<span class="nc" id="L6416">        throw newValidationError(filter, RESOURCE.aggregateInFilterIllegal());</span>
      }
    }
<span class="nc bnc" id="L6419" title="All 2 branches missed.">    if (distinctList != null) {</span>
<span class="nc bnc" id="L6420" title="All 2 branches missed.">      for (SqlNode param : distinctList) {</span>
<span class="nc bnc" id="L6421" title="All 2 branches missed.">        if (a.findAgg(param) != null) {</span>
<span class="nc" id="L6422">          throw newValidationError(aggCall,</span>
<span class="nc" id="L6423">              RESOURCE.aggregateInWithinDistinctIllegal());</span>
        }
<span class="nc" id="L6425">      }</span>
    }
<span class="nc bnc" id="L6427" title="All 2 branches missed.">    if (orderList != null) {</span>
<span class="nc bnc" id="L6428" title="All 2 branches missed.">      for (SqlNode param : orderList) {</span>
<span class="nc bnc" id="L6429" title="All 2 branches missed.">        if (a.findAgg(param) != null) {</span>
<span class="nc" id="L6430">          throw newValidationError(aggCall,</span>
<span class="nc" id="L6431">              RESOURCE.aggregateInWithinGroupIllegal());</span>
        }
<span class="nc" id="L6433">      }</span>
    }

<span class="nc" id="L6436">    final SqlAggFunction op = (SqlAggFunction) aggCall.getOperator();</span>
<span class="nc bnc" id="L6437" title="All 5 branches missed.">    switch (op.requiresGroupOrder()) {</span>
    case MANDATORY:
<span class="nc bnc" id="L6439" title="All 4 branches missed.">      if (orderList == null || orderList.isEmpty()) {</span>
<span class="nc" id="L6440">        throw newValidationError(aggCall,</span>
<span class="nc" id="L6441">            RESOURCE.aggregateMissingWithinGroupClause(op.getName()));</span>
      }
      break;
    case OPTIONAL:
<span class="nc" id="L6445">      break;</span>
    case IGNORED:
      // rewrite the order list to empty
<span class="nc bnc" id="L6448" title="All 2 branches missed.">      if (orderList != null) {</span>
<span class="nc" id="L6449">        orderList.clear();</span>
      }
      break;
    case FORBIDDEN:
<span class="nc bnc" id="L6453" title="All 4 branches missed.">      if (orderList != null &amp;&amp; !orderList.isEmpty()) {</span>
<span class="nc" id="L6454">        throw newValidationError(aggCall,</span>
<span class="nc" id="L6455">            RESOURCE.withinGroupClauseIllegalInAggregate(op.getName()));</span>
      }
      break;
    default:
<span class="nc" id="L6459">      throw new AssertionError(op);</span>
    }

    // Because there are two forms of the PERCENTILE_CONT/PERCENTILE_DISC functions,
    // they are distinguished by their operand count and then validated accordingly.
    // For example, the standard single operand form requires group order while the
    // 2-operand form allows for null treatment and requires an OVER() clause.
<span class="nc bnc" id="L6466" title="All 2 branches missed.">    if (op.isPercentile()) {</span>
<span class="nc bnc" id="L6467" title="All 3 branches missed.">      switch (aggCall.operandCount()) {</span>
      case 1:
<span class="nc bnc" id="L6469" title="All 2 branches missed.">        assert op.requiresGroupOrder() == Optionality.MANDATORY;</span>
<span class="nc bnc" id="L6470" title="All 2 branches missed.">        assert orderList != null;</span>
        // Validate that percentile function have a single ORDER BY expression
<span class="nc bnc" id="L6472" title="All 2 branches missed.">        if (orderList.size() != 1) {</span>
<span class="nc" id="L6473">          throw newValidationError(orderList,</span>
<span class="nc" id="L6474">              RESOURCE.orderByRequiresOneKey(op.getName()));</span>
        }
        // Validate that the ORDER BY field is of NUMERIC type
<span class="nc" id="L6477">        SqlNode node = requireNonNull(orderList.get(0));</span>
<span class="nc" id="L6478">        final RelDataType type = deriveType(scope, node);</span>
<span class="nc" id="L6479">        final @Nullable SqlTypeFamily family = type.getSqlTypeName().getFamily();</span>
<span class="nc bnc" id="L6480" title="All 2 branches missed.">        if (family == null</span>
<span class="nc bnc" id="L6481" title="All 2 branches missed.">            || family.allowableDifferenceTypes().isEmpty()) {</span>
<span class="nc" id="L6482">          throw newValidationError(orderList,</span>
<span class="nc" id="L6483">              RESOURCE.unsupportedTypeInOrderBy(</span>
<span class="nc" id="L6484">                  type.getSqlTypeName().getName(),</span>
<span class="nc" id="L6485">                  op.getName()));</span>
        }
        break;
      case 2:
<span class="nc bnc" id="L6489" title="All 2 branches missed.">        assert op.allowsNullTreatment();</span>
<span class="nc bnc" id="L6490" title="All 2 branches missed.">        assert op.requiresOver();</span>
<span class="nc bnc" id="L6491" title="All 2 branches missed.">        assert op.requiresGroupOrder() == Optionality.FORBIDDEN;</span>
        break;
      default:
<span class="nc" id="L6494">        throw newValidationError(aggCall, RESOURCE.percentileFunctionsArgumentLimit());</span>
      }
    }
<span class="nc" id="L6497">  }</span>

  @Override public void validateCall(
      SqlCall call,
      SqlValidatorScope scope) {
<span class="nc" id="L6502">    final SqlOperator operator = call.getOperator();</span>
<span class="nc bnc" id="L6503" title="All 2 branches missed.">    if ((call.operandCount() == 0)</span>
<span class="nc bnc" id="L6504" title="All 2 branches missed.">        &amp;&amp; (operator.getSyntax() == SqlSyntax.FUNCTION_ID)</span>
<span class="nc bnc" id="L6505" title="All 2 branches missed.">        &amp;&amp; !call.isExpanded()</span>
<span class="nc bnc" id="L6506" title="All 2 branches missed.">        &amp;&amp; !this.config.conformance().allowNiladicParentheses()) {</span>
      // For example, &quot;LOCALTIME()&quot; is illegal. (It should be
      // &quot;LOCALTIME&quot;, which would have been handled as a
      // SqlIdentifier.)
<span class="nc" id="L6510">      throw handleUnresolvedFunction(call, operator,</span>
<span class="nc" id="L6511">          ImmutableList.of(), null);</span>
    }

<span class="nc" id="L6514">    SqlValidatorScope operandScope = scope.getOperandScope(call);</span>

<span class="nc bnc" id="L6516" title="All 2 branches missed.">    if (operator instanceof SqlFunction</span>
<span class="nc bnc" id="L6517" title="All 4 branches missed.">        &amp;&amp; ((SqlFunction) operator).getFunctionType()</span>
            == SqlFunctionCategory.MATCH_RECOGNIZE
        &amp;&amp; !(operandScope instanceof MatchRecognizeScope)) {
<span class="nc" id="L6520">      throw newValidationError(call,</span>
<span class="nc" id="L6521">          Static.RESOURCE.functionMatchRecognizeOnly(call.toString()));</span>
    }
    // Delegate validation to the operator.
<span class="nc" id="L6524">    operator.validateCall(call, this, scope, operandScope);</span>
<span class="nc" id="L6525">  }</span>

  /**
   * Validates that a particular feature is enabled. By default, all features
   * are enabled; subclasses may override this method to be more
   * discriminating.
   *
   * @param feature feature being used, represented as a resource instance
   * @param context parser position context for error reporting, or null if
   */
  protected void validateFeature(
      Feature feature,
      SqlParserPos context) {
    // By default, do nothing except to verify that the resource
    // represents a real feature definition.
<span class="nc bnc" id="L6540" title="All 2 branches missed.">    assert feature.getProperties().get(&quot;FeatureDefinition&quot;) != null;</span>
<span class="nc" id="L6541">  }</span>

  @Override public SqlLiteral resolveLiteral(SqlLiteral literal) {
<span class="nc bnc" id="L6544" title="All 2 branches missed.">    switch (literal.getTypeName()) {</span>
    case UNKNOWN:
<span class="nc" id="L6546">      final SqlUnknownLiteral unknownLiteral = (SqlUnknownLiteral) literal;</span>
<span class="nc" id="L6547">      final SqlIdentifier identifier =</span>
          new SqlIdentifier(unknownLiteral.tag, SqlParserPos.ZERO);
<span class="nc" id="L6549">      final @Nullable RelDataType type = catalogReader.getNamedType(identifier);</span>
      final SqlTypeName typeName;
<span class="nc bnc" id="L6551" title="All 2 branches missed.">      if (type != null) {</span>
<span class="nc" id="L6552">        typeName = type.getSqlTypeName();</span>
      } else {
<span class="nc" id="L6554">        typeName = SqlTypeName.lookup(unknownLiteral.tag);</span>
      }
<span class="nc" id="L6556">      return unknownLiteral.resolve(typeName);</span>

    default:
<span class="nc" id="L6559">      return literal;</span>
    }
  }

  public SqlNode expandSelectExpr(SqlNode expr,
      SelectScope scope, SqlSelect select) {
<span class="nc" id="L6565">    final Expander expander = new SelectExpander(this, scope, select);</span>
<span class="nc" id="L6566">    final SqlNode newExpr = expander.go(expr);</span>
<span class="nc bnc" id="L6567" title="All 2 branches missed.">    if (expr != newExpr) {</span>
<span class="nc" id="L6568">      setOriginal(newExpr, expr);</span>
    }
<span class="nc" id="L6570">    return newExpr;</span>
  }

  @Override public SqlNode expand(SqlNode expr, SqlValidatorScope scope) {
<span class="nc" id="L6574">    final Expander expander = new Expander(this, scope);</span>
<span class="nc" id="L6575">    SqlNode newExpr = expander.go(expr);</span>
<span class="nc bnc" id="L6576" title="All 2 branches missed.">    if (expr != newExpr) {</span>
<span class="nc" id="L6577">      setOriginal(newExpr, expr);</span>
    }
<span class="nc" id="L6579">    return newExpr;</span>
  }

  /** Expands an expression in a GROUP BY, HAVING or QUALIFY clause. */
  private SqlNode extendedExpand(SqlNode expr,
      SqlValidatorScope scope, SqlSelect select, Clause clause) {
<span class="nc" id="L6585">    final Expander expander =</span>
        new ExtendedExpander(this, scope, select, expr, clause);
<span class="nc" id="L6587">    SqlNode newExpr = expander.go(expr);</span>
<span class="nc bnc" id="L6588" title="All 2 branches missed.">    if (expr != newExpr) {</span>
<span class="nc" id="L6589">      setOriginal(newExpr, expr);</span>
    }
<span class="nc" id="L6591">    return newExpr;</span>
  }

  public SqlNode extendedExpandGroupBy(SqlNode expr,
      SqlValidatorScope scope, SqlSelect select) {
<span class="nc" id="L6596">    return extendedExpand(expr, scope, select, Clause.GROUP_BY);</span>
  }

  @Override public boolean isSystemField(RelDataTypeField field) {
<span class="nc" id="L6600">    return false;</span>
  }

  @Override public List&lt;@Nullable List&lt;String&gt;&gt; getFieldOrigins(SqlNode sqlQuery) {
<span class="nc bnc" id="L6604" title="All 2 branches missed.">    if (sqlQuery instanceof SqlExplain) {</span>
<span class="nc" id="L6605">      return emptyList();</span>
    }
<span class="nc" id="L6607">    final RelDataType rowType = getValidatedNodeType(sqlQuery);</span>
<span class="nc" id="L6608">    final int fieldCount = rowType.getFieldCount();</span>
<span class="nc bnc" id="L6609" title="All 2 branches missed.">    if (!sqlQuery.isA(SqlKind.QUERY)) {</span>
<span class="nc" id="L6610">      return Collections.nCopies(fieldCount, null);</span>
    }
<span class="nc" id="L6612">    final List&lt;@Nullable List&lt;String&gt;&gt; list = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L6613" title="All 2 branches missed.">    for (int i = 0; i &lt; fieldCount; i++) {</span>
<span class="nc" id="L6614">      list.add(getFieldOrigin(sqlQuery, i));</span>
    }
<span class="nc" id="L6616">    return ImmutableNullableList.copyOf(list);</span>
  }

  private @Nullable List&lt;String&gt; getFieldOrigin(SqlNode sqlQuery, int i) {
<span class="nc bnc" id="L6620" title="All 2 branches missed.">    if (sqlQuery instanceof SqlSelect) {</span>
<span class="nc" id="L6621">      SqlSelect sqlSelect = (SqlSelect) sqlQuery;</span>
<span class="nc" id="L6622">      final SelectScope scope = getRawSelectScopeNonNull(sqlSelect);</span>
<span class="nc" id="L6623">      final List&lt;SqlNode&gt; selectList =</span>
<span class="nc" id="L6624">          requireNonNull(scope.getExpandedSelectList(),</span>
<span class="nc" id="L6625">              () -&gt; &quot;expandedSelectList for &quot; + scope);</span>
<span class="nc" id="L6626">      final SqlNode selectItem = stripAs(selectList.get(i));</span>
<span class="nc bnc" id="L6627" title="All 2 branches missed.">      if (selectItem instanceof SqlIdentifier) {</span>
<span class="nc" id="L6628">        final SqlQualified qualified =</span>
<span class="nc" id="L6629">            scope.fullyQualify((SqlIdentifier) selectItem);</span>
<span class="nc" id="L6630">        SqlValidatorNamespace namespace =</span>
<span class="nc" id="L6631">            requireNonNull(qualified.namespace,</span>
<span class="nc" id="L6632">                () -&gt; &quot;namespace for &quot; + qualified);</span>
<span class="nc bnc" id="L6633" title="All 2 branches missed.">        if (namespace.isWrapperFor(AliasNamespace.class)) {</span>
<span class="nc" id="L6634">          AliasNamespace aliasNs = namespace.unwrap(AliasNamespace.class);</span>
<span class="nc" id="L6635">          SqlNode aliased = requireNonNull(aliasNs.getNode(), () -&gt;</span>
<span class="nc" id="L6636">              &quot;sqlNode for aliasNs &quot; + aliasNs);</span>
<span class="nc" id="L6637">          namespace = getNamespaceOrThrow(stripAs(aliased));</span>
        }

<span class="nc" id="L6640">        final SqlValidatorTable table = namespace.getTable();</span>
<span class="nc bnc" id="L6641" title="All 2 branches missed.">        if (table == null) {</span>
<span class="nc" id="L6642">          return null;</span>
        }
<span class="nc" id="L6644">        final List&lt;String&gt; origin =</span>
<span class="nc" id="L6645">            new ArrayList&lt;&gt;(table.getQualifiedName());</span>
<span class="nc bnc" id="L6646" title="All 2 branches missed.">        for (String name : qualified.suffix()) {</span>
<span class="nc bnc" id="L6647" title="All 2 branches missed.">          if (namespace.isWrapperFor(UnnestNamespace.class)) {</span>
            // If identifier is drawn from a repeated subrecord via unnest, add name of array field
<span class="nc" id="L6649">            UnnestNamespace unnestNamespace = namespace.unwrap(UnnestNamespace.class);</span>
<span class="nc" id="L6650">            final SqlQualified columnUnnestedFrom = unnestNamespace.getColumnUnnestedFrom(name);</span>
<span class="nc bnc" id="L6651" title="All 2 branches missed.">            if (columnUnnestedFrom != null) {</span>
<span class="nc" id="L6652">              origin.addAll(columnUnnestedFrom.suffix());</span>
            }
          }
<span class="nc" id="L6655">          namespace = namespace.lookupChild(name);</span>

<span class="nc bnc" id="L6657" title="All 2 branches missed.">          if (namespace == null) {</span>
<span class="nc" id="L6658">            return null;</span>
          }
<span class="nc" id="L6660">          origin.add(name);</span>
<span class="nc" id="L6661">        }</span>
<span class="nc" id="L6662">        return origin;</span>
      }
<span class="nc" id="L6664">      return null;</span>
<span class="nc bnc" id="L6665" title="All 2 branches missed.">    } else if (sqlQuery instanceof SqlOrderBy) {</span>
<span class="nc" id="L6666">      return getFieldOrigin(((SqlOrderBy) sqlQuery).query, i);</span>
    } else {
<span class="nc" id="L6668">      return null;</span>
    }
  }

  @Override public RelDataType getParameterRowType(SqlNode sqlQuery) {
    // NOTE: We assume that bind variables occur in depth-first tree
    // traversal in the same order that they occurred in the SQL text.
<span class="nc" id="L6675">    final List&lt;RelDataType&gt; types = new ArrayList&lt;&gt;();</span>
    // NOTE: but parameters on fetch/offset would be counted twice
    // as they are counted in the SqlOrderBy call and the inner SqlSelect call
<span class="nc" id="L6678">    final Set&lt;SqlNode&gt; alreadyVisited = new HashSet&lt;&gt;();</span>
<span class="nc" id="L6679">    sqlQuery.accept(</span>
<span class="nc" id="L6680">        new SqlShuttle() {</span>

          @Override public SqlNode visit(SqlDynamicParam param) {
<span class="nc bnc" id="L6683" title="All 2 branches missed.">            if (alreadyVisited.add(param)) {</span>
<span class="nc" id="L6684">              RelDataType type = getValidatedNodeType(param);</span>
<span class="nc" id="L6685">              types.add(type);</span>
            }
<span class="nc" id="L6687">            return param;</span>
          }
        });
<span class="nc" id="L6690">    return typeFactory.createStructType(</span>
        types,
<span class="nc" id="L6692">        new AbstractList&lt;String&gt;() {</span>
          @Override public String get(int index) {
<span class="nc" id="L6694">            return &quot;?&quot; + index;</span>
          }

          @Override public int size() {
<span class="nc" id="L6698">            return types.size();</span>
          }
        });
  }

  private static boolean isPhysicalNavigation(SqlKind kind) {
<span class="nc bnc" id="L6704" title="All 4 branches missed.">    return kind == SqlKind.PREV || kind == SqlKind.NEXT;</span>
  }

  private static boolean isLogicalNavigation(SqlKind kind) {
<span class="nc bnc" id="L6708" title="All 4 branches missed.">    return kind == SqlKind.FIRST || kind == SqlKind.LAST;</span>
  }

  private static boolean isAggregation(SqlKind kind) {
<span class="nc bnc" id="L6712" title="All 12 branches missed.">    return kind == SqlKind.SUM || kind == SqlKind.SUM0</span>
        || kind == SqlKind.AVG || kind == SqlKind.COUNT
        || kind == SqlKind.MAX || kind == SqlKind.MIN;
  }

  private static boolean isRunningOrFinal(SqlKind kind) {
<span class="nc bnc" id="L6718" title="All 4 branches missed.">    return kind == SqlKind.RUNNING || kind == SqlKind.FINAL;</span>
  }

  private static boolean isSingleVarRequired(SqlKind kind) {
<span class="nc bnc" id="L6722" title="All 2 branches missed.">    return isPhysicalNavigation(kind)</span>
<span class="nc bnc" id="L6723" title="All 2 branches missed.">        || isLogicalNavigation(kind)</span>
<span class="nc bnc" id="L6724" title="All 2 branches missed.">        || isAggregation(kind);</span>
  }

  //~ Inner Classes ----------------------------------------------------------

  /**
   * Common base class for DML statement namespaces.
   */
  public static class DmlNamespace extends IdentifierNamespace {
    protected DmlNamespace(SqlValidatorImpl validator, SqlNode id,
        SqlNode enclosingNode, SqlValidatorScope parentScope) {
<span class="nc" id="L6735">      super(validator, id, enclosingNode, parentScope);</span>
<span class="nc" id="L6736">    }</span>
  }

  /**
   * Namespace for an INSERT statement.
   */
  private static class InsertNamespace extends DmlNamespace {
    private final SqlInsert node;

    InsertNamespace(SqlValidatorImpl validator, SqlInsert node,
        SqlNode enclosingNode, SqlValidatorScope parentScope) {
<span class="nc" id="L6747">      super(validator, node.getTargetTable(), enclosingNode, parentScope);</span>
<span class="nc" id="L6748">      this.node = requireNonNull(node, &quot;node&quot;);</span>
<span class="nc" id="L6749">    }</span>

    @Override public @Nullable SqlNode getNode() {
<span class="nc" id="L6752">      return node;</span>
    }
  }

  /**
   * Namespace for an UPDATE statement.
   */
  private static class UpdateNamespace extends DmlNamespace {
    private final SqlUpdate node;

    UpdateNamespace(SqlValidatorImpl validator, SqlUpdate node,
        SqlNode enclosingNode, SqlValidatorScope parentScope) {
<span class="nc" id="L6764">      super(validator, node.getTargetTable(), enclosingNode, parentScope);</span>
<span class="nc" id="L6765">      this.node = requireNonNull(node, &quot;node&quot;);</span>
<span class="nc" id="L6766">    }</span>

    @Override public @Nullable SqlNode getNode() {
<span class="nc" id="L6769">      return node;</span>
    }
  }

  /**
   * Namespace for a DELETE statement.
   */
  private static class DeleteNamespace extends DmlNamespace {
    private final SqlDelete node;

    DeleteNamespace(SqlValidatorImpl validator, SqlDelete node,
        SqlNode enclosingNode, SqlValidatorScope parentScope) {
<span class="nc" id="L6781">      super(validator, node.getTargetTable(), enclosingNode, parentScope);</span>
<span class="nc" id="L6782">      this.node = requireNonNull(node, &quot;node&quot;);</span>
<span class="nc" id="L6783">    }</span>

    @Override public @Nullable SqlNode getNode() {
<span class="nc" id="L6786">      return node;</span>
    }
  }

  /**
   * Namespace for a MERGE statement.
   */
  private static class MergeNamespace extends DmlNamespace {
    private final SqlMerge node;

    MergeNamespace(SqlValidatorImpl validator, SqlMerge node,
        SqlNode enclosingNode, SqlValidatorScope parentScope) {
<span class="nc" id="L6798">      super(validator, node.getTargetTable(), enclosingNode, parentScope);</span>
<span class="nc" id="L6799">      this.node = requireNonNull(node, &quot;node&quot;);</span>
<span class="nc" id="L6800">    }</span>

    @Override public @Nullable SqlNode getNode() {
<span class="nc" id="L6803">      return node;</span>
    }
  }

  /** Visitor that retrieves pattern variables defined. */
  private static class PatternVarVisitor implements SqlVisitor&lt;Void&gt; {
    private final MatchRecognizeScope scope;

<span class="nc" id="L6811">    PatternVarVisitor(MatchRecognizeScope scope) {</span>
<span class="nc" id="L6812">      this.scope = scope;</span>
<span class="nc" id="L6813">    }</span>

    @Override public Void visit(SqlLiteral literal) {
<span class="nc" id="L6816">      return null;</span>
    }

    @Override public Void visit(SqlCall call) {
<span class="nc bnc" id="L6820" title="All 2 branches missed.">      for (int i = 0; i &lt; call.getOperandList().size(); i++) {</span>
<span class="nc" id="L6821">        call.getOperandList().get(i).accept(this);</span>
      }
<span class="nc" id="L6823">      return null;</span>
    }

    @Override public Void visit(SqlNodeList nodeList) {
<span class="nc" id="L6827">      throw Util.needToImplement(nodeList);</span>
    }

    @Override public Void visit(SqlIdentifier id) {
<span class="nc" id="L6831">      checkArgument(id.isSimple());</span>
<span class="nc" id="L6832">      scope.addPatternVar(id.getSimple());</span>
<span class="nc" id="L6833">      return null;</span>
    }

    @Override public Void visit(SqlDataTypeSpec type) {
<span class="nc" id="L6837">      throw Util.needToImplement(type);</span>
    }

    @Override public Void visit(SqlDynamicParam param) {
<span class="nc" id="L6841">      throw Util.needToImplement(param);</span>
    }

    @Override public Void visit(SqlIntervalQualifier intervalQualifier) {
<span class="nc" id="L6845">      throw Util.needToImplement(intervalQualifier);</span>
    }
  }

  /**
   * Visitor which derives the type of a given {@link SqlNode}.
   *
   * &lt;p&gt;Each method must return the derived type. This visitor is basically a
   * single-use dispatcher; the visit is never recursive.
   */
  private class DeriveTypeVisitor implements SqlVisitor&lt;RelDataType&gt; {
    private final SqlValidatorScope scope;

<span class="nc" id="L6858">    DeriveTypeVisitor(SqlValidatorScope scope) {</span>
<span class="nc" id="L6859">      this.scope = scope;</span>
<span class="nc" id="L6860">    }</span>

    @Override public RelDataType visit(SqlLiteral literal) {
<span class="nc" id="L6863">      return resolveLiteral(literal).createSqlType(typeFactory);</span>
    }

    @Override public RelDataType visit(SqlCall call) {
      try {
<span class="nc" id="L6868">        final SqlOperator operator = call.getOperator();</span>
<span class="nc" id="L6869">        return operator.deriveType(SqlValidatorImpl.this, scope, call);</span>
<span class="nc" id="L6870">      } catch (Exception e) {</span>
        // If we can't derive the type, return ANY type
<span class="nc" id="L6872">        return SqlValidatorImpl.this.getTypeFactory().createSqlType(SqlTypeName.ANY);</span>
      }
    }

    @Override public RelDataType visit(SqlNodeList nodeList) {
      // Operand is of a type that we can't derive a type for. If the
      // operand is of a peculiar type, such as a SqlNodeList, then you
      // should override the operator's validateCall() method so that it
      // doesn't try to validate that operand as an expression.
<span class="nc" id="L6881">      throw Util.needToImplement(nodeList);</span>
    }

    @Override public RelDataType visit(SqlIdentifier id) {
      // First check for builtin functions which don't have parentheses,
      // like &quot;LOCALTIME&quot;.
<span class="nc" id="L6887">      final SqlCall call = makeNullaryCall(id);</span>
<span class="nc bnc" id="L6888" title="All 2 branches missed.">      if (call != null) {</span>
<span class="nc" id="L6889">        return call.getOperator().validateOperands(</span>
            SqlValidatorImpl.this,
            scope,
            call);
      }

<span class="nc" id="L6895">      RelDataType type = null;</span>
<span class="nc bnc" id="L6896" title="All 2 branches missed.">      if (!(scope instanceof EmptyScope)) {</span>
<span class="nc" id="L6897">        id = scope.fullyQualify(id).identifier;</span>
      }

      // Resolve the longest prefix of id that we can
      int i;
<span class="nc bnc" id="L6902" title="All 2 branches missed.">      for (i = id.names.size() - 1; i &gt; 0; i--) {</span>
        // REVIEW jvs 9-June-2005: The name resolution rules used
        // here are supposed to match SQL:2003 Part 2 Section 6.6
        // (identifier chain), but we don't currently have enough
        // information to get everything right.  In particular,
        // routine parameters are currently looked up via resolve;
        // we could do a better job if they were looked up via
        // resolveColumn.

<span class="nc" id="L6911">        final SqlNameMatcher nameMatcher = catalogReader.nameMatcher();</span>
<span class="nc" id="L6912">        final SqlValidatorScope.ResolvedImpl resolved =</span>
            new SqlValidatorScope.ResolvedImpl();
<span class="nc" id="L6914">        scope.resolve(id.names.subList(0, i), nameMatcher, false, resolved);</span>
<span class="nc bnc" id="L6915" title="All 2 branches missed.">        if (resolved.count() == 1) {</span>
          // There's a namespace with the name we seek.
<span class="nc" id="L6917">          final SqlValidatorScope.Resolve resolve = resolved.only();</span>
<span class="nc" id="L6918">          type = resolve.rowType();</span>
<span class="nc bnc" id="L6919" title="All 2 branches missed.">          for (SqlValidatorScope.Step p : Util.skip(resolve.path.steps())) {</span>
<span class="nc" id="L6920">            type = type.getFieldList().get(p.i).getType();</span>
<span class="nc" id="L6921">          }</span>
<span class="nc" id="L6922">          break;</span>
        }
      }

      // Give precedence to namespace found, unless there
      // are no more identifier components.
<span class="nc bnc" id="L6928" title="All 4 branches missed.">      if (type == null || id.names.size() == 1) {</span>
        // See if there's a column with the name we seek in
        // precisely one of the namespaces in this scope.
<span class="nc" id="L6931">        RelDataType colType = scope.resolveColumn(id.names.get(0), id);</span>
<span class="nc bnc" id="L6932" title="All 2 branches missed.">        if (colType != null) {</span>
<span class="nc" id="L6933">          type = colType;</span>
        }
<span class="nc" id="L6935">        ++i;</span>
      }

<span class="nc bnc" id="L6938" title="All 2 branches missed.">      if (type == null) {</span>
<span class="nc" id="L6939">        final SqlIdentifier last = id.getComponent(i - 1, i);</span>
<span class="nc" id="L6940">        throw newValidationError(last,</span>
<span class="nc" id="L6941">            RESOURCE.unknownIdentifier(last.toString()));</span>
      }

      // Resolve rest of identifier
<span class="nc bnc" id="L6945" title="All 2 branches missed.">      for (; i &lt; id.names.size(); i++) {</span>
<span class="nc" id="L6946">        String name = id.names.get(i);</span>
        final RelDataTypeField field;
<span class="nc bnc" id="L6948" title="All 2 branches missed.">        if (name.isEmpty()) {</span>
          // The wildcard &quot;*&quot; is represented as an empty name. It never
          // resolves to a field.
<span class="nc" id="L6951">          name = &quot;*&quot;;</span>
<span class="nc" id="L6952">          field = null;</span>
        } else {
<span class="nc" id="L6954">          final SqlNameMatcher nameMatcher = catalogReader.nameMatcher();</span>
<span class="nc" id="L6955">          field = nameMatcher.field(type, name);</span>
        }
<span class="nc bnc" id="L6957" title="All 2 branches missed.">        if (field == null) {</span>
<span class="nc" id="L6958">          throw newValidationError(id.getComponent(i),</span>
<span class="nc" id="L6959">              RESOURCE.unknownField(name));</span>
        }
<span class="nc" id="L6961">        type = field.getType();</span>
      }
<span class="nc" id="L6963">      type =</span>
<span class="nc" id="L6964">          SqlTypeUtil.addCharsetAndCollation(</span>
              type,
<span class="nc" id="L6966">              getTypeFactory());</span>
<span class="nc" id="L6967">      return type;</span>
    }

    @Override public RelDataType visit(SqlDataTypeSpec dataType) {
      // Q. How can a data type have a type?
      // A. When it appears in an expression. (Say as the 2nd arg to the
      //    CAST operator.)
<span class="nc" id="L6974">      validateDataType(dataType);</span>
<span class="nc" id="L6975">      return dataType.deriveType(SqlValidatorImpl.this);</span>
    }

    @Override public RelDataType visit(SqlDynamicParam param) {
<span class="nc" id="L6979">      return unknownType;</span>
    }

    @Override public RelDataType visit(SqlIntervalQualifier intervalQualifier) {
<span class="nc" id="L6983">      return typeFactory.createSqlIntervalType(intervalQualifier);</span>
    }
  }

  /**
   * Converts an expression into canonical form by fully-qualifying any
   * identifiers.
   */
  private static class Expander extends SqlScopedShuttle {
    protected final SqlValidatorImpl validator;

    Expander(SqlValidatorImpl validator, SqlValidatorScope scope) {
<span class="nc" id="L6995">      super(scope);</span>
<span class="nc" id="L6996">      this.validator = validator;</span>
<span class="nc" id="L6997">    }</span>

    public SqlNode go(SqlNode root) {
<span class="nc" id="L7000">      return requireNonNull(root.accept(this),</span>
<span class="nc" id="L7001">          () -&gt; this + &quot; returned null for &quot; + root);</span>
    }

    @Override public @Nullable SqlNode visit(SqlIdentifier id) {
      // First check for builtin functions which don't have
      // parentheses, like &quot;LOCALTIME&quot;.
<span class="nc" id="L7007">      final SqlCall call = validator.makeNullaryCall(id);</span>
<span class="nc bnc" id="L7008" title="All 2 branches missed.">      if (call != null) {</span>
<span class="nc" id="L7009">        return call.accept(this);</span>
      }
      try {
<span class="nc" id="L7012">        final SqlIdentifier fqId = getScope().fullyQualify(id).identifier;</span>
<span class="nc" id="L7013">        SqlNode expandedExpr = expandDynamicStar(id, fqId);</span>
<span class="nc" id="L7014">        validator.setOriginal(expandedExpr, id);</span>
<span class="nc" id="L7015">        return expandedExpr;</span>
<span class="nc" id="L7016">      } catch (Exception e) {</span>
<span class="nc" id="L7017">        SqlLiteral literal = SqlLiteral.createCharString(id.toString(), id.getParserPosition());</span>
//        SqlLiteral literal = SqlLiteral.createUnknown(&quot;UNKNOWN&quot;, id.toString(), id.getParserPosition());
<span class="nc" id="L7019">        return literal.accept(this);</span>
//        return UnknownSqlNode.create(id.getParserPosition(), id.toString());
      }
    }

    @Override public @Nullable SqlNode visit(SqlLiteral literal) {
<span class="nc" id="L7025">      return validator.resolveLiteral(literal);</span>
    }

    @Override protected SqlNode visitScoped(SqlCall call) {
<span class="nc bnc" id="L7029" title="All 2 branches missed.">      switch (call.getKind()) {</span>
      case SCALAR_QUERY:
      case CURRENT_VALUE:
      case NEXT_VALUE:
      case WITH:
      case LAMBDA:
<span class="nc" id="L7035">        return call;</span>
      default:
        break;
      }
      // Only visits arguments which are expressions. We don't want to
      // qualify non-expressions such as 'x' in 'empno * 5 AS x'.
<span class="nc" id="L7041">      CallCopyingArgHandler argHandler =</span>
          new CallCopyingArgHandler(call, false);
<span class="nc" id="L7043">      call.getOperator().acceptCall(this, call, true, argHandler);</span>
<span class="nc" id="L7044">      final SqlNode result = argHandler.result();</span>
<span class="nc" id="L7045">      validator.setOriginal(result, call);</span>
<span class="nc" id="L7046">      return result;</span>
    }

    protected SqlNode expandDynamicStar(SqlIdentifier id, SqlIdentifier fqId) {
<span class="nc bnc" id="L7050" title="All 2 branches missed.">      if (DynamicRecordType.isDynamicStarColName(Util.last(fqId.names))</span>
<span class="nc bnc" id="L7051" title="All 2 branches missed.">          &amp;&amp; !DynamicRecordType.isDynamicStarColName(Util.last(id.names))) {</span>
        // Convert a column ref into ITEM(*, 'col_name')
        // for a dynamic star field in dynTable's rowType.
<span class="nc" id="L7054">        return new SqlBasicCall(</span>
            SqlStdOperatorTable.ITEM,
<span class="nc" id="L7056">            ImmutableList.of(fqId,</span>
<span class="nc" id="L7057">                SqlLiteral.createCharString(Util.last(id.names),</span>
<span class="nc" id="L7058">                    id.getParserPosition())),</span>
<span class="nc" id="L7059">            id.getParserPosition());</span>
      }
<span class="nc" id="L7061">      return fqId;</span>
    }
  }

  /**
   * Shuttle which walks over an expression in the ORDER BY clause, replacing
   * usages of aliases with the underlying expression.
   */
  class OrderExpressionExpander extends SqlScopedShuttle {
    private final List&lt;String&gt; aliasList;
    private final SqlSelect select;
    private final SqlNode root;

<span class="nc" id="L7074">    OrderExpressionExpander(SqlSelect select, SqlNode root) {</span>
<span class="nc" id="L7075">      super(getOrderScope(select));</span>
<span class="nc" id="L7076">      this.select = select;</span>
<span class="nc" id="L7077">      this.root = root;</span>
<span class="nc" id="L7078">      this.aliasList = getNamespaceOrThrow(select).getRowType().getFieldNames();</span>
<span class="nc" id="L7079">    }</span>

    public SqlNode go() {
<span class="nc" id="L7082">      return requireNonNull(root.accept(this),</span>
<span class="nc" id="L7083">          () -&gt; &quot;OrderExpressionExpander returned null for &quot; + root);</span>
    }

    @Override public @Nullable SqlNode visit(SqlLiteral literal) {
      // Ordinal markers, e.g. 'select a, b from t order by 2'.
      // Only recognize them if they are the whole expression,
      // and if the dialect permits.
<span class="nc bnc" id="L7090" title="All 4 branches missed.">      if (literal == root &amp;&amp; config.conformance().isSortByOrdinal()) {</span>
<span class="nc bnc" id="L7091" title="All 2 branches missed.">        switch (literal.getTypeName()) {</span>
        case DECIMAL:
        case DOUBLE:
<span class="nc" id="L7094">          final int intValue = literal.intValue(false);</span>
<span class="nc bnc" id="L7095" title="All 2 branches missed.">          if (intValue &gt;= 0) {</span>
<span class="nc bnc" id="L7096" title="All 4 branches missed.">            if (intValue &lt; 1 || intValue &gt; aliasList.size()) {</span>
<span class="nc" id="L7097">              throw newValidationError(</span>
<span class="nc" id="L7098">                  literal, RESOURCE.orderByOrdinalOutOfRange());</span>
            }

            // SQL ordinals are 1-based, but Sort's are 0-based
<span class="nc" id="L7102">            int ordinal = intValue - 1;</span>
<span class="nc" id="L7103">            return nthSelectItem(ordinal, literal.getParserPosition());</span>
          }
          break;
        default:
          break;
        }
      }

<span class="nc" id="L7111">      return super.visit(literal);</span>
    }

    /**
     * Returns the &lt;code&gt;ordinal&lt;/code&gt;th item in the select list.
     */
    private SqlNode nthSelectItem(int ordinal, final SqlParserPos pos) {
      // TODO: Don't expand the list every time. Maybe keep an expanded
      // version of each expression -- select lists and identifiers -- in
      // the validator.

<span class="nc" id="L7122">      SqlNodeList expandedSelectList =</span>
<span class="nc" id="L7123">          expandStar(</span>
<span class="nc" id="L7124">              SqlNonNullableAccessors.getSelectList(select),</span>
              select,
              false);
<span class="nc" id="L7127">      SqlNode expr = expandedSelectList.get(ordinal);</span>
<span class="nc" id="L7128">      expr = stripAs(expr);</span>
<span class="nc bnc" id="L7129" title="All 2 branches missed.">      if (expr instanceof SqlIdentifier) {</span>
<span class="nc" id="L7130">        expr = getScope().fullyQualify((SqlIdentifier) expr).identifier;</span>
      }

      // Create a copy of the expression with the position of the order
      // item.
<span class="nc" id="L7135">      return expr.clone(pos);</span>
    }

    @Override public SqlNode visit(SqlIdentifier id) {
      // Aliases, e.g. 'select a as x, b from t order by x'.
<span class="nc bnc" id="L7140" title="All 2 branches missed.">      if (id.isSimple()</span>
<span class="nc bnc" id="L7141" title="All 2 branches missed.">          &amp;&amp; config.conformance().isSortByAlias()) {</span>
<span class="nc" id="L7142">        String alias = id.getSimple();</span>
<span class="nc" id="L7143">        final SqlValidatorNamespace selectNs = getNamespaceOrThrow(select);</span>
<span class="nc" id="L7144">        final RelDataType rowType =</span>
<span class="nc" id="L7145">            selectNs.getRowTypeSansSystemColumns();</span>
<span class="nc" id="L7146">        final SqlNameMatcher nameMatcher = catalogReader.nameMatcher();</span>
<span class="nc" id="L7147">        RelDataTypeField field = nameMatcher.field(rowType, alias);</span>
<span class="nc bnc" id="L7148" title="All 2 branches missed.">        if (field != null) {</span>
<span class="nc" id="L7149">          return nthSelectItem(</span>
<span class="nc" id="L7150">              field.getIndex(),</span>
<span class="nc" id="L7151">              id.getParserPosition());</span>
        }
      }

      // No match. Return identifier unchanged.
<span class="nc" id="L7156">      return getScope().fullyQualify(id).identifier;</span>
    }

    @Override protected @Nullable SqlNode visitScoped(SqlCall call) {
      // Don't attempt to expand sub-queries. We haven't implemented
      // these yet.
<span class="nc bnc" id="L7162" title="All 2 branches missed.">      if (call instanceof SqlSelect) {</span>
<span class="nc" id="L7163">        return call;</span>
      }
<span class="nc" id="L7165">      return super.visitScoped(call);</span>
    }
  }

  /**
   * Converts an expression into canonical form by fully-qualifying any
   * identifiers. For common columns in USING, it will be converted to
   * COALESCE(A.col, B.col) AS col.
   */
  static class SelectExpander extends Expander {
    final SqlSelect select;

    SelectExpander(SqlValidatorImpl validator, SelectScope scope,
        SqlSelect select) {
<span class="nc" id="L7179">      super(validator, scope);</span>
<span class="nc" id="L7180">      this.select = select;</span>
<span class="nc" id="L7181">    }</span>

    @Override public @Nullable SqlNode visit(SqlIdentifier id) {
<span class="nc" id="L7184">      final SqlNode node =</span>
<span class="nc" id="L7185">          expandCommonColumn(select, id, (SelectScope) getScope(), validator);</span>
<span class="nc bnc" id="L7186" title="All 2 branches missed.">      if (node != id) {</span>
<span class="nc" id="L7187">        return node;</span>
      } else {
<span class="nc" id="L7189">        return super.visit(id);</span>
      }
    }
  }

  /**
   * Shuttle which walks over an expression in the GROUP BY/HAVING clause, replacing
   * usages of aliases or ordinals with the underlying expression.
   */
  static class ExtendedExpander extends Expander {
    final SqlSelect select;
    final SqlNode root;
    final Clause clause;

    ExtendedExpander(SqlValidatorImpl validator, SqlValidatorScope scope,
        SqlSelect select, SqlNode root, Clause clause) {
<span class="nc" id="L7205">      super(validator, scope);</span>
<span class="nc" id="L7206">      this.select = select;</span>
<span class="nc" id="L7207">      this.root = root;</span>
<span class="nc" id="L7208">      this.clause = clause;</span>
<span class="nc" id="L7209">    }</span>

    @Override public @Nullable SqlNode visit(SqlIdentifier id) {
<span class="nc bnc" id="L7212" title="All 2 branches missed.">      if (!id.isSimple()) {</span>
<span class="nc" id="L7213">        return super.visit(id);</span>
      }

<span class="nc" id="L7216">      final boolean replaceAliases = clause.shouldReplaceAliases(validator.config);</span>
<span class="nc bnc" id="L7217" title="All 2 branches missed.">      if (!replaceAliases) {</span>
<span class="nc" id="L7218">        final SelectScope scope = validator.getRawSelectScopeNonNull(select);</span>
<span class="nc" id="L7219">        SqlNode node = expandCommonColumn(select, id, scope, validator);</span>
<span class="nc bnc" id="L7220" title="All 2 branches missed.">        if (node != id) {</span>
<span class="nc" id="L7221">          return node;</span>
        }
<span class="nc" id="L7223">        return super.visit(id);</span>
      }

<span class="nc" id="L7226">      String name = id.getSimple();</span>
<span class="nc" id="L7227">      SqlNode expr = null;</span>
<span class="nc" id="L7228">      final SqlNameMatcher nameMatcher =</span>
<span class="nc" id="L7229">          validator.catalogReader.nameMatcher();</span>
<span class="nc" id="L7230">      int n = 0;</span>
<span class="nc bnc" id="L7231" title="All 2 branches missed.">      for (SqlNode s : SqlNonNullableAccessors.getSelectList(select)) {</span>
<span class="nc" id="L7232">        final @Nullable String alias = SqlValidatorUtil.alias(s);</span>
<span class="nc bnc" id="L7233" title="All 4 branches missed.">        if (alias != null &amp;&amp; nameMatcher.matches(alias, name)) {</span>
<span class="nc" id="L7234">          expr = s;</span>
<span class="nc" id="L7235">          n++;</span>
        }
<span class="nc" id="L7237">      }</span>

<span class="nc bnc" id="L7239" title="All 2 branches missed.">      if (n == 0) {</span>
<span class="nc" id="L7240">        return super.visit(id);</span>
<span class="nc bnc" id="L7241" title="All 2 branches missed.">      } else if (n &gt; 1) {</span>
        // More than one column has this alias.
<span class="nc" id="L7243">        throw validator.newValidationError(id,</span>
<span class="nc" id="L7244">            RESOURCE.columnAmbiguous(name));</span>
      }
<span class="nc" id="L7246">      Iterable&lt;SqlCall&gt; allAggList = validator.aggFinder.findAll(ImmutableList.of(root));</span>
<span class="nc bnc" id="L7247" title="All 2 branches missed.">      for (SqlCall agg : allAggList) {</span>
<span class="nc bnc" id="L7248" title="All 4 branches missed.">        if (clause == Clause.HAVING &amp;&amp; containsIdentifier(agg, id)) {</span>
<span class="nc" id="L7249">          return super.visit(id);</span>
        }
<span class="nc" id="L7251">      }</span>

<span class="nc" id="L7253">      expr = stripAs(expr);</span>
<span class="nc bnc" id="L7254" title="All 2 branches missed.">      if (expr instanceof SqlIdentifier) {</span>
<span class="nc" id="L7255">        SqlIdentifier sid = (SqlIdentifier) expr;</span>
<span class="nc" id="L7256">        final SqlIdentifier fqId = getScope().fullyQualify(sid).identifier;</span>
<span class="nc" id="L7257">        expr = expandDynamicStar(sid, fqId);</span>
      }

<span class="nc" id="L7260">      return expr;</span>
    }

    @Override public @Nullable SqlNode visit(SqlLiteral literal) {
<span class="nc bnc" id="L7264" title="All 2 branches missed.">      if (clause != Clause.GROUP_BY</span>
<span class="nc bnc" id="L7265" title="All 2 branches missed.">          || !validator.config().conformance().isGroupByOrdinal()) {</span>
<span class="nc" id="L7266">        return super.visit(literal);</span>
      }
<span class="nc bnc" id="L7268" title="All 2 branches missed.">      boolean isOrdinalLiteral = literal == root;</span>
<span class="nc bnc" id="L7269" title="All 2 branches missed.">      switch (root.getKind()) {</span>
      case GROUPING_SETS:
      case ROLLUP:
      case CUBE:
<span class="nc bnc" id="L7273" title="All 2 branches missed.">        if (root instanceof SqlBasicCall) {</span>
<span class="nc" id="L7274">          List&lt;SqlNode&gt; operandList = ((SqlBasicCall) root).getOperandList();</span>
<span class="nc bnc" id="L7275" title="All 2 branches missed.">          for (SqlNode node : operandList) {</span>
<span class="nc bnc" id="L7276" title="All 2 branches missed.">            if (node.equals(literal)) {</span>
<span class="nc" id="L7277">              isOrdinalLiteral = true;</span>
<span class="nc" id="L7278">              break;</span>
            }
<span class="nc" id="L7280">          }</span>
<span class="nc" id="L7281">        }</span>
        break;
      default:
        break;
      }
<span class="nc bnc" id="L7286" title="All 2 branches missed.">      if (isOrdinalLiteral) {</span>
<span class="nc bnc" id="L7287" title="All 2 branches missed.">        switch (literal.getTypeName()) {</span>
        case DECIMAL:
        case DOUBLE:
<span class="nc" id="L7290">          final int intValue = literal.intValue(false);</span>
<span class="nc bnc" id="L7291" title="All 2 branches missed.">          if (intValue &gt;= 0) {</span>
<span class="nc bnc" id="L7292" title="All 4 branches missed.">            if (intValue &lt; 1 || intValue &gt; SqlNonNullableAccessors.getSelectList(select).size()) {</span>
<span class="nc" id="L7293">              throw validator.newValidationError(literal,</span>
<span class="nc" id="L7294">                  RESOURCE.orderByOrdinalOutOfRange());</span>
            }

            // SQL ordinals are 1-based, but Sort's are 0-based
<span class="nc" id="L7298">            int ordinal = intValue - 1;</span>
<span class="nc" id="L7299">            return stripAs(SqlNonNullableAccessors.getSelectList(select)</span>
<span class="nc" id="L7300">                .get(ordinal));</span>
          }
          break;
        default:
          break;
        }
      }

<span class="nc" id="L7308">      return super.visit(literal);</span>
    }

    /**
     * Returns whether a given node contains a {@link SqlIdentifier}.
     *
     * @param sqlNode a SqlNode
     * @param target a SqlIdentifier
     */
    private boolean containsIdentifier(SqlNode sqlNode, SqlIdentifier target) {
      try {
<span class="nc" id="L7319">        SqlVisitor&lt;Void&gt; visitor =</span>
<span class="nc" id="L7320">            new SqlBasicVisitor&lt;Void&gt;() {</span>
              @Override public Void visit(SqlIdentifier identifier) {
<span class="nc bnc" id="L7322" title="All 2 branches missed.">                if (identifier.equalsDeep(target, Litmus.IGNORE)) {</span>
<span class="nc" id="L7323">                  throw new Util.FoundOne(target);</span>
                }
<span class="nc" id="L7325">                return super.visit(identifier);</span>
              }
            };
<span class="nc" id="L7328">        sqlNode.accept(visitor);</span>
<span class="nc" id="L7329">        return false;</span>
<span class="nc" id="L7330">      } catch (Util.FoundOne e) {</span>
<span class="nc" id="L7331">        Util.swallow(e, null);</span>
<span class="nc" id="L7332">        return true;</span>
      }
    }
  }


  /** Information about an identifier in a particular scope. */
  protected static class IdInfo {
    public final SqlValidatorScope scope;
    public final SqlIdentifier id;

<span class="nc" id="L7343">    public IdInfo(SqlValidatorScope scope, SqlIdentifier id) {</span>
<span class="nc" id="L7344">      this.scope = scope;</span>
<span class="nc" id="L7345">      this.id = id;</span>
<span class="nc" id="L7346">    }</span>
  }

  /**
   * Utility object used to maintain information about the parameters in a
   * function call.
   */
  protected static class FunctionParamInfo {
    /**
     * Maps a cursor (based on its position relative to other cursor
     * parameters within a function call) to the SELECT associated with the
     * cursor.
     */
    public final Map&lt;Integer, SqlSelect&gt; cursorPosToSelectMap;

    /**
     * Maps a column list parameter to the parent cursor parameter it
     * references. The parameters are id'd by their names.
     */
    public final Map&lt;String, String&gt; columnListParamToParentCursorMap;

<span class="nc" id="L7367">    public FunctionParamInfo() {</span>
<span class="nc" id="L7368">      cursorPosToSelectMap = new HashMap&lt;&gt;();</span>
<span class="nc" id="L7369">      columnListParamToParentCursorMap = new HashMap&lt;&gt;();</span>
<span class="nc" id="L7370">    }</span>
  }

  /**
   * Modify the nodes in navigation function
   * such as FIRST, LAST, PREV AND NEXT.
   */
  private static class NavigationModifier extends SqlShuttle {
    public SqlNode go(SqlNode node) {
<span class="nc" id="L7379">      return requireNonNull(node.accept(this),</span>
<span class="nc" id="L7380">          () -&gt; &quot;NavigationModifier returned for &quot; + node);</span>
    }
  }

  /**
   * Shuttle that expands navigation expressions in a MATCH_RECOGNIZE clause.
   *
   * &lt;p&gt;Examples:
   *
   * &lt;ul&gt;
   * &lt;li&gt;{@code PREV(A.price + A.amount)} &amp;rarr;
   * {@code PREV(A.price) + PREV(A.amount)}
   *
   * &lt;li&gt;{@code FIRST(A.price * 2)} &amp;rarr; {@code FIRST(A.PRICE) * 2}
   * &lt;/ul&gt;
   */
  private static class NavigationExpander extends NavigationModifier {
    final @Nullable SqlOperator op;
    final @Nullable SqlNode offset;

    NavigationExpander() {
<span class="nc" id="L7401">      this(null, null);</span>
<span class="nc" id="L7402">    }</span>

<span class="nc" id="L7404">    NavigationExpander(@Nullable SqlOperator operator, @Nullable SqlNode offset) {</span>
<span class="nc" id="L7405">      this.offset = offset;</span>
<span class="nc" id="L7406">      this.op = operator;</span>
<span class="nc" id="L7407">    }</span>

    @Override public @Nullable SqlNode visit(SqlCall call) {
<span class="nc" id="L7410">      SqlKind kind = call.getKind();</span>
<span class="nc" id="L7411">      List&lt;SqlNode&gt; operands = call.getOperandList();</span>
<span class="nc" id="L7412">      List&lt;@Nullable SqlNode&gt; newOperands = new ArrayList&lt;&gt;();</span>

<span class="nc bnc" id="L7414" title="All 2 branches missed.">      if (call.getFunctionQuantifier() != null</span>
<span class="nc bnc" id="L7415" title="All 2 branches missed.">          &amp;&amp; call.getFunctionQuantifier().getValue() == SqlSelectKeyword.DISTINCT) {</span>
<span class="nc" id="L7416">        final SqlParserPos pos = call.getParserPosition();</span>
<span class="nc" id="L7417">        throw SqlUtil.newContextException(pos,</span>
<span class="nc" id="L7418">            Static.RESOURCE.functionQuantifierNotAllowed(call.toString()));</span>
      }

<span class="nc bnc" id="L7421" title="All 4 branches missed.">      if (isLogicalNavigation(kind) || isPhysicalNavigation(kind)) {</span>
<span class="nc" id="L7422">        SqlNode inner = operands.get(0);</span>
<span class="nc" id="L7423">        SqlNode offset = operands.get(1);</span>

        // merge two straight prev/next, update offset
<span class="nc bnc" id="L7426" title="All 2 branches missed.">        if (isPhysicalNavigation(kind)) {</span>
<span class="nc" id="L7427">          SqlKind innerKind = inner.getKind();</span>
<span class="nc bnc" id="L7428" title="All 2 branches missed.">          if (isPhysicalNavigation(innerKind)) {</span>
<span class="nc" id="L7429">            List&lt;SqlNode&gt; innerOperands = ((SqlCall) inner).getOperandList();</span>
<span class="nc" id="L7430">            SqlNode innerOffset = innerOperands.get(1);</span>
<span class="nc bnc" id="L7431" title="All 2 branches missed.">            SqlOperator newOperator = innerKind == kind</span>
<span class="nc" id="L7432">                ? SqlStdOperatorTable.PLUS : SqlStdOperatorTable.MINUS;</span>
<span class="nc" id="L7433">            offset =</span>
<span class="nc" id="L7434">              newOperator.createCall(SqlParserPos.ZERO, offset, innerOffset);</span>
<span class="nc" id="L7435">            inner =</span>
<span class="nc" id="L7436">              call.getOperator().createCall(SqlParserPos.ZERO,</span>
<span class="nc" id="L7437">                  innerOperands.get(0), offset);</span>
          }
        }
<span class="nc" id="L7440">        SqlNode newInnerNode =</span>
<span class="nc" id="L7441">            inner.accept(new NavigationExpander(call.getOperator(), offset));</span>
<span class="nc bnc" id="L7442" title="All 2 branches missed.">        if (op != null) {</span>
<span class="nc" id="L7443">          newInnerNode =</span>
<span class="nc" id="L7444">              op.createCall(SqlParserPos.ZERO, newInnerNode, this.offset);</span>
        }
<span class="nc" id="L7446">        return newInnerNode;</span>
      }

<span class="nc bnc" id="L7449" title="All 2 branches missed.">      if (!operands.isEmpty()) {</span>
<span class="nc bnc" id="L7450" title="All 2 branches missed.">        for (SqlNode node : operands) {</span>
<span class="nc bnc" id="L7451" title="All 2 branches missed.">          if (node != null) {</span>
<span class="nc" id="L7452">            SqlNode newNode = node.accept(new NavigationExpander());</span>
<span class="nc bnc" id="L7453" title="All 2 branches missed.">            if (op != null) {</span>
<span class="nc" id="L7454">              newNode = op.createCall(SqlParserPos.ZERO, newNode, offset);</span>
            }
<span class="nc" id="L7456">            newOperands.add(newNode);</span>
<span class="nc" id="L7457">          } else {</span>
<span class="nc" id="L7458">            newOperands.add(null);</span>
          }
<span class="nc" id="L7460">        }</span>
<span class="nc" id="L7461">        return call.getOperator().createCall(SqlParserPos.ZERO, newOperands);</span>
      } else {
<span class="nc bnc" id="L7463" title="All 2 branches missed.">        if (op == null) {</span>
<span class="nc" id="L7464">          return call;</span>
        } else {
<span class="nc" id="L7466">          return op.createCall(SqlParserPos.ZERO, call, offset);</span>
        }
      }
    }

    @Override public SqlNode visit(SqlIdentifier id) {
<span class="nc bnc" id="L7472" title="All 2 branches missed.">      if (op == null) {</span>
<span class="nc" id="L7473">        return id;</span>
      } else {
<span class="nc" id="L7475">        return op.createCall(SqlParserPos.ZERO, id, offset);</span>
      }
    }
  }

  /**
   * Shuttle that replaces {@code A as A.price &gt; PREV(B.price)} with
   * {@code PREV(A.price, 0) &gt; LAST(B.price, 0)}.
   *
   * &lt;p&gt;Replacing {@code A.price} with {@code PREV(A.price, 0)} makes the
   * implementation of
   * {@link RexVisitor#visitPatternFieldRef(RexPatternFieldRef)} more unified.
   * Otherwise, it's difficult to implement this method. If it returns the
   * specified field, then the navigation such as {@code PREV(A.price, 1)}
   * becomes impossible; if not, then comparisons such as
   * {@code A.price &gt; PREV(A.price, 1)} become meaningless.
   */
  private static class NavigationReplacer extends NavigationModifier {
    private final String alpha;

<span class="nc" id="L7495">    NavigationReplacer(String alpha) {</span>
<span class="nc" id="L7496">      this.alpha = alpha;</span>
<span class="nc" id="L7497">    }</span>

    @Override public @Nullable SqlNode visit(SqlCall call) {
<span class="nc" id="L7500">      SqlKind kind = call.getKind();</span>
<span class="nc bnc" id="L7501" title="All 2 branches missed.">      if (isLogicalNavigation(kind)</span>
<span class="nc bnc" id="L7502" title="All 2 branches missed.">          || isAggregation(kind)</span>
<span class="nc bnc" id="L7503" title="All 2 branches missed.">          || isRunningOrFinal(kind)) {</span>
<span class="nc" id="L7504">        return call;</span>
      }

<span class="nc bnc" id="L7507" title="All 2 branches missed.">      switch (kind) {</span>
      case PREV:
<span class="nc" id="L7509">        final List&lt;SqlNode&gt; operands = call.getOperandList();</span>
<span class="nc bnc" id="L7510" title="All 2 branches missed.">        if (operands.get(0) instanceof SqlIdentifier) {</span>
<span class="nc" id="L7511">          String name = ((SqlIdentifier) operands.get(0)).names.get(0);</span>
<span class="nc bnc" id="L7512" title="All 2 branches missed.">          return name.equals(alpha) ? call</span>
<span class="nc" id="L7513">              : SqlStdOperatorTable.LAST.createCall(SqlParserPos.ZERO, operands);</span>
        }
        break;
      default:
        break;
      }
<span class="nc" id="L7519">      return super.visit(call);</span>
    }

    @Override public SqlNode visit(SqlIdentifier id) {
<span class="nc bnc" id="L7523" title="All 2 branches missed.">      if (id.isSimple()) {</span>
<span class="nc" id="L7524">        return id;</span>
      }
<span class="nc bnc" id="L7526" title="All 2 branches missed.">      SqlOperator operator = id.names.get(0).equals(alpha)</span>
<span class="nc" id="L7527">          ? SqlStdOperatorTable.PREV : SqlStdOperatorTable.LAST;</span>

<span class="nc" id="L7529">      return operator.createCall(SqlParserPos.ZERO, id,</span>
<span class="nc" id="L7530">        SqlLiteral.createExactNumeric(&quot;0&quot;, SqlParserPos.ZERO));</span>
    }
  }

  /** Validates that within one navigation function, the pattern var is the
   * same. */
  private class PatternValidator extends SqlBasicVisitor&lt;@Nullable Set&lt;String&gt;&gt; {
    private final boolean isMeasure;
    int firstLastCount;
    int prevNextCount;
    int aggregateCount;

    PatternValidator(boolean isMeasure) {
<span class="nc" id="L7543">      this(isMeasure, 0, 0, 0);</span>
<span class="nc" id="L7544">    }</span>

    PatternValidator(boolean isMeasure, int firstLastCount, int prevNextCount,
<span class="nc" id="L7547">        int aggregateCount) {</span>
<span class="nc" id="L7548">      this.isMeasure = isMeasure;</span>
<span class="nc" id="L7549">      this.firstLastCount = firstLastCount;</span>
<span class="nc" id="L7550">      this.prevNextCount = prevNextCount;</span>
<span class="nc" id="L7551">      this.aggregateCount = aggregateCount;</span>
<span class="nc" id="L7552">    }</span>

    @Override public Set&lt;String&gt; visit(SqlCall call) {
<span class="nc" id="L7555">      boolean isSingle = false;</span>
<span class="nc" id="L7556">      Set&lt;String&gt; vars = new HashSet&lt;&gt;();</span>
<span class="nc" id="L7557">      SqlKind kind = call.getKind();</span>
<span class="nc" id="L7558">      List&lt;SqlNode&gt; operands = call.getOperandList();</span>

<span class="nc bnc" id="L7560" title="All 2 branches missed.">      if (isSingleVarRequired(kind)) {</span>
<span class="nc" id="L7561">        isSingle = true;</span>
<span class="nc bnc" id="L7562" title="All 2 branches missed.">        if (isPhysicalNavigation(kind)) {</span>
<span class="nc bnc" id="L7563" title="All 2 branches missed.">          if (isMeasure) {</span>
<span class="nc" id="L7564">            throw newValidationError(call,</span>
<span class="nc" id="L7565">                Static.RESOURCE.patternPrevFunctionInMeasure(call.toString()));</span>
          }
<span class="nc bnc" id="L7567" title="All 2 branches missed.">          if (firstLastCount != 0) {</span>
<span class="nc" id="L7568">            throw newValidationError(call,</span>
<span class="nc" id="L7569">                Static.RESOURCE.patternPrevFunctionOrder(call.toString()));</span>
          }
<span class="nc" id="L7571">          prevNextCount++;</span>
<span class="nc bnc" id="L7572" title="All 2 branches missed.">        } else if (isLogicalNavigation(kind)) {</span>
<span class="nc bnc" id="L7573" title="All 2 branches missed.">          if (firstLastCount != 0) {</span>
<span class="nc" id="L7574">            throw newValidationError(call,</span>
<span class="nc" id="L7575">                Static.RESOURCE.patternPrevFunctionOrder(call.toString()));</span>
          }
<span class="nc" id="L7577">          firstLastCount++;</span>
<span class="nc bnc" id="L7578" title="All 2 branches missed.">        } else if (isAggregation(kind)) {</span>
          // cannot apply aggregation in PREV/NEXT, FIRST/LAST
<span class="nc bnc" id="L7580" title="All 4 branches missed.">          if (firstLastCount != 0 || prevNextCount != 0) {</span>
<span class="nc" id="L7581">            throw newValidationError(call,</span>
<span class="nc" id="L7582">                Static.RESOURCE.patternAggregationInNavigation(call.toString()));</span>
          }
<span class="nc bnc" id="L7584" title="All 4 branches missed.">          if (kind == SqlKind.COUNT &amp;&amp; call.getOperandList().size() &gt; 1) {</span>
<span class="nc" id="L7585">            throw newValidationError(call,</span>
<span class="nc" id="L7586">                Static.RESOURCE.patternCountFunctionArg());</span>
          }
<span class="nc" id="L7588">          aggregateCount++;</span>
        }
      }

<span class="nc bnc" id="L7592" title="All 4 branches missed.">      if (isRunningOrFinal(kind) &amp;&amp; !isMeasure) {</span>
<span class="nc" id="L7593">        throw newValidationError(call,</span>
<span class="nc" id="L7594">            Static.RESOURCE.patternRunningFunctionInDefine(call.toString()));</span>
      }

<span class="nc bnc" id="L7597" title="All 2 branches missed.">      for (SqlNode node : operands) {</span>
<span class="nc bnc" id="L7598" title="All 2 branches missed.">        if (node != null) {</span>
<span class="nc" id="L7599">          vars.addAll(</span>
<span class="nc" id="L7600">              requireNonNull(</span>
<span class="nc" id="L7601">                  node.accept(</span>
                      new PatternValidator(isMeasure, firstLastCount, prevNextCount,
                          aggregateCount)),
<span class="nc" id="L7604">                  () -&gt; &quot;node.accept(PatternValidator) for node &quot; + node));</span>
        }
<span class="nc" id="L7606">      }</span>

<span class="nc bnc" id="L7608" title="All 2 branches missed.">      if (isSingle) {</span>
<span class="nc bnc" id="L7609" title="All 2 branches missed.">        switch (kind) {</span>
        case COUNT:
<span class="nc bnc" id="L7611" title="All 2 branches missed.">          if (vars.size() &gt; 1) {</span>
<span class="nc" id="L7612">            throw newValidationError(call,</span>
<span class="nc" id="L7613">                Static.RESOURCE.patternCountFunctionArg());</span>
          }
          break;
        default:
<span class="nc bnc" id="L7617" title="All 2 branches missed.">          if (operands.isEmpty()</span>
<span class="nc bnc" id="L7618" title="All 2 branches missed.">              || !(operands.get(0) instanceof SqlCall)</span>
<span class="nc bnc" id="L7619" title="All 2 branches missed.">              || ((SqlCall) operands.get(0)).getOperator() != SqlStdOperatorTable.CLASSIFIER) {</span>
<span class="nc bnc" id="L7620" title="All 2 branches missed.">            if (vars.isEmpty()) {</span>
<span class="nc" id="L7621">              throw newValidationError(call,</span>
<span class="nc" id="L7622">                  Static.RESOURCE.patternFunctionNullCheck(call.toString()));</span>
            }
<span class="nc bnc" id="L7624" title="All 2 branches missed.">            if (vars.size() != 1) {</span>
<span class="nc" id="L7625">              throw newValidationError(call,</span>
<span class="nc" id="L7626">                  Static.RESOURCE.patternFunctionVariableCheck(call.toString()));</span>
            }
          }
          break;
        }
      }
<span class="nc" id="L7632">      return vars;</span>
    }

    @Override public Set&lt;String&gt; visit(SqlIdentifier identifier) {
<span class="nc bnc" id="L7636" title="All 6 branches missed.">      boolean check = prevNextCount &gt; 0 || firstLastCount &gt; 0 || aggregateCount &gt; 0;</span>
<span class="nc" id="L7637">      Set&lt;String&gt; vars = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L7638" title="All 4 branches missed.">      if (identifier.names.size() &gt; 1 &amp;&amp; check) {</span>
<span class="nc" id="L7639">        vars.add(identifier.names.get(0));</span>
      }
<span class="nc" id="L7641">      return vars;</span>
    }

    @Override public Set&lt;String&gt; visit(SqlLiteral literal) {
<span class="nc" id="L7645">      return ImmutableSet.of();</span>
    }

    @Override public Set&lt;String&gt; visit(SqlIntervalQualifier qualifier) {
<span class="nc" id="L7649">      return ImmutableSet.of();</span>
    }

    @Override public Set&lt;String&gt; visit(SqlDataTypeSpec type) {
<span class="nc" id="L7653">      return ImmutableSet.of();</span>
    }

    @Override public Set&lt;String&gt; visit(SqlDynamicParam param) {
<span class="nc" id="L7657">      return ImmutableSet.of();</span>
    }
  }

  /** Permutation of fields in NATURAL JOIN or USING. */
  private class Permute {
    final List&lt;ImmutableIntList&gt; sources;
    final RelDataType rowType;
    final boolean trivial;
    final int offset;

<span class="nc" id="L7668">    Permute(SqlNode from, int offset) {</span>
<span class="nc" id="L7669">      this.offset = offset;</span>
<span class="nc bnc" id="L7670" title="All 2 branches missed.">      switch (from.getKind()) {</span>
      case JOIN:
<span class="nc" id="L7672">        final SqlJoin join = (SqlJoin) from;</span>
<span class="nc" id="L7673">        final Permute left = new Permute(join.getLeft(), offset);</span>
<span class="nc" id="L7674">        final int fieldCount =</span>
<span class="nc" id="L7675">            getValidatedNodeType(join.getLeft()).getFieldList().size();</span>
<span class="nc" id="L7676">        final Permute right =</span>
<span class="nc" id="L7677">            new Permute(join.getRight(), offset + fieldCount);</span>
<span class="nc" id="L7678">        final List&lt;String&gt; names = usingNames(join);</span>
<span class="nc" id="L7679">        final List&lt;ImmutableIntList&gt; sources = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L7680">        final Set&lt;ImmutableIntList&gt; sourceSet = new HashSet&lt;&gt;();</span>
<span class="nc" id="L7681">        final RelDataTypeFactory.Builder b = typeFactory.builder();</span>
<span class="nc bnc" id="L7682" title="All 2 branches missed.">        if (names != null) {</span>
<span class="nc bnc" id="L7683" title="All 2 branches missed.">          for (String name : names) {</span>
<span class="nc" id="L7684">            final RelDataTypeField f = left.field(name);</span>
<span class="nc" id="L7685">            final ImmutableIntList source = left.sources.get(f.getIndex());</span>
<span class="nc" id="L7686">            sourceSet.add(source);</span>
<span class="nc" id="L7687">            final RelDataTypeField f2 = right.field(name);</span>
<span class="nc" id="L7688">            final ImmutableIntList source2 = right.sources.get(f2.getIndex());</span>
<span class="nc" id="L7689">            sourceSet.add(source2);</span>
<span class="nc" id="L7690">            sources.add(source.appendAll(source2));</span>
<span class="nc" id="L7691">            final boolean nullable =</span>
<span class="nc bnc" id="L7692" title="All 2 branches missed.">                (f.getType().isNullable()</span>
<span class="nc bnc" id="L7693" title="All 2 branches missed.">                    || join.getJoinType().generatesNullsOnLeft())</span>
<span class="nc bnc" id="L7694" title="All 2 branches missed.">                &amp;&amp; (f2.getType().isNullable()</span>
<span class="nc bnc" id="L7695" title="All 2 branches missed.">                    || join.getJoinType().generatesNullsOnRight());</span>
<span class="nc" id="L7696">            b.add(f).nullable(nullable);</span>
<span class="nc" id="L7697">          }</span>
        }
<span class="nc bnc" id="L7699" title="All 2 branches missed.">        for (RelDataTypeField f : left.rowType.getFieldList()) {</span>
<span class="nc" id="L7700">          final ImmutableIntList source = left.sources.get(f.getIndex());</span>
<span class="nc bnc" id="L7701" title="All 2 branches missed.">          if (sourceSet.add(source)) {</span>
<span class="nc" id="L7702">            sources.add(source);</span>
<span class="nc" id="L7703">            b.add(f);</span>
          }
<span class="nc" id="L7705">        }</span>
<span class="nc bnc" id="L7706" title="All 2 branches missed.">        for (RelDataTypeField f : right.rowType.getFieldList()) {</span>
<span class="nc" id="L7707">          final ImmutableIntList source = right.sources.get(f.getIndex());</span>
<span class="nc bnc" id="L7708" title="All 2 branches missed.">          if (sourceSet.add(source)) {</span>
<span class="nc" id="L7709">            sources.add(source);</span>
<span class="nc" id="L7710">            b.add(f);</span>
          }
<span class="nc" id="L7712">        }</span>
<span class="nc" id="L7713">        rowType = b.build();</span>
<span class="nc" id="L7714">        this.sources = ImmutableList.copyOf(sources);</span>
<span class="nc bnc" id="L7715" title="All 6 branches missed.">        this.trivial = left.trivial</span>
            &amp;&amp; right.trivial
<span class="nc bnc" id="L7717" title="All 2 branches missed.">            &amp;&amp; (names == null || names.isEmpty());</span>
<span class="nc" id="L7718">        break;</span>

      default:
<span class="nc" id="L7721">        rowType = getValidatedNodeType(from);</span>
<span class="nc" id="L7722">        this.sources =</span>
<span class="nc" id="L7723">            Functions.generate(rowType.getFieldCount(),</span>
<span class="nc" id="L7724">                i -&gt; ImmutableIntList.of(offset + i));</span>
<span class="nc" id="L7725">        this.trivial = true;</span>
      }
<span class="nc" id="L7727">    }</span>

    private RelDataTypeField field(String name) {
<span class="nc" id="L7730">      RelDataTypeField field = catalogReader.nameMatcher().field(rowType, name);</span>
<span class="nc bnc" id="L7731" title="All 2 branches missed.">      if (field == null) {</span>
<span class="nc" id="L7732">        throw new AssertionError(&quot;field &quot; + name + &quot; was not found in &quot;</span>
            + rowType);
      }
<span class="nc" id="L7735">      return field;</span>
    }

    /** Moves fields according to the permutation. */
    void permute(List&lt;SqlNode&gt; selectItems,
        PairList&lt;String, RelDataType&gt; fields) {
<span class="nc bnc" id="L7741" title="All 2 branches missed.">      if (trivial) {</span>
<span class="nc" id="L7742">        return;</span>
      }

<span class="nc" id="L7745">      final List&lt;SqlNode&gt; oldSelectItems = ImmutableList.copyOf(selectItems);</span>
<span class="nc" id="L7746">      selectItems.clear();</span>
<span class="nc" id="L7747">      selectItems.addAll(oldSelectItems.subList(0, offset));</span>
<span class="nc" id="L7748">      final PairList&lt;String, RelDataType&gt; oldFields = fields.immutable();</span>
<span class="nc" id="L7749">      fields.clear();</span>
<span class="nc" id="L7750">      fields.addAll(oldFields.subList(0, offset));</span>
<span class="nc bnc" id="L7751" title="All 2 branches missed.">      for (ImmutableIntList source : sources) {</span>
<span class="nc" id="L7752">        final int p0 = source.get(0);</span>
<span class="nc" id="L7753">        Map.Entry&lt;String, RelDataType&gt; field = oldFields.get(p0);</span>
<span class="nc" id="L7754">        final String name = field.getKey();</span>
<span class="nc" id="L7755">        RelDataType type = field.getValue();</span>
<span class="nc" id="L7756">        SqlNode selectItem = oldSelectItems.get(p0);</span>
<span class="nc bnc" id="L7757" title="All 2 branches missed.">        for (int p1 : Util.skip(source)) {</span>
<span class="nc" id="L7758">          final Map.Entry&lt;String, RelDataType&gt; field1 = oldFields.get(p1);</span>
<span class="nc" id="L7759">          final SqlNode selectItem1 = oldSelectItems.get(p1);</span>
<span class="nc" id="L7760">          final RelDataType type1 = field1.getValue();</span>
          // output is nullable only if both inputs are
<span class="nc bnc" id="L7762" title="All 4 branches missed.">          final boolean nullable = type.isNullable() &amp;&amp; type1.isNullable();</span>
<span class="nc" id="L7763">          RelDataType currentType = type;</span>
<span class="nc" id="L7764">          final RelDataType type2 =</span>
<span class="nc" id="L7765">              requireNonNull(</span>
<span class="nc" id="L7766">                  SqlTypeUtil.leastRestrictiveForComparison(typeFactory, type,</span>
                      type1),
<span class="nc" id="L7768">                  () -&gt; &quot;leastRestrictiveForComparison for types &quot; + currentType</span>
                      + &quot; and &quot; + type1);
<span class="nc" id="L7770">          selectItem =</span>
<span class="nc" id="L7771">              SqlStdOperatorTable.AS.createCall(SqlParserPos.ZERO,</span>
<span class="nc" id="L7772">                  SqlStdOperatorTable.COALESCE.createCall(SqlParserPos.ZERO,</span>
<span class="nc" id="L7773">                      maybeCast(selectItem, type, type2),</span>
<span class="nc" id="L7774">                      maybeCast(selectItem1, type1, type2)),</span>
                  new SqlIdentifier(name, SqlParserPos.ZERO));
<span class="nc" id="L7776">          type = typeFactory.createTypeWithNullability(type2, nullable);</span>
<span class="nc" id="L7777">        }</span>
<span class="nc" id="L7778">        fields.add(name, type);</span>
<span class="nc" id="L7779">        selectItems.add(selectItem);</span>
<span class="nc" id="L7780">      }</span>
<span class="nc" id="L7781">    }</span>
  }

  //~ Enums ------------------------------------------------------------------

  /**
   * Validation status.
   */
<span class="nc" id="L7789">  public enum Status {</span>
    /**
     * Validation has not started for this scope.
     */
<span class="nc" id="L7793">    UNVALIDATED,</span>

    /**
     * Validation is in progress for this scope.
     */
<span class="nc" id="L7798">    IN_PROGRESS,</span>

    /**
     * Validation has completed (perhaps unsuccessfully).
     */
<span class="nc" id="L7803">    VALID</span>
  }

  /** Allows {@link #clauseScopes} to have multiple values per SELECT. */
<span class="nc" id="L7807">  private enum Clause {</span>
<span class="nc" id="L7808">    WHERE,</span>
<span class="nc" id="L7809">    GROUP_BY,</span>
<span class="nc" id="L7810">    SELECT,</span>
<span class="nc" id="L7811">    MEASURE,</span>
<span class="nc" id="L7812">    ORDER,</span>
<span class="nc" id="L7813">    CURSOR,</span>
<span class="nc" id="L7814">    HAVING,</span>
<span class="nc" id="L7815">    QUALIFY;</span>

    /**
     * Determines if the extender should replace aliases with expanded values.
     * For example:
     *
     * &lt;blockquote&gt;&lt;pre&gt;{@code
     * SELECT a + a as twoA
     * GROUP BY twoA
     * }&lt;/pre&gt;&lt;/blockquote&gt;
     *
     * &lt;p&gt;turns into
     *
     * &lt;blockquote&gt;&lt;pre&gt;{@code
     * SELECT a + a as twoA
     * GROUP BY a + a
     * }&lt;/pre&gt;&lt;/blockquote&gt;
     *
     * &lt;p&gt;This is determined both by the clause and the config.
     *
     * @param config The configuration
     * @return Whether we should replace the alias with its expanded value
     */
    boolean shouldReplaceAliases(Config config) {
<span class="nc bnc" id="L7839" title="All 4 branches missed.">      switch (this) {</span>
      case GROUP_BY:
<span class="nc" id="L7841">        return config.conformance().isGroupByAlias();</span>

      case HAVING:
<span class="nc" id="L7844">        return config.conformance().isHavingAlias();</span>

      case QUALIFY:
<span class="nc" id="L7847">        return true;</span>

      default:
<span class="nc" id="L7850">        throw Util.unexpected(this);</span>
      }
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>