<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AggregateChecker.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sql-core</a> &gt; <a href="index.source.html" class="el_package">com.calcite_new.sql.core.converter</a> &gt; <span class="el_source">AggregateChecker.java</span></div><h1>AggregateChecker.java</h1><pre class="source lang-java linenums">package com.calcite_new.sql.core.converter;

import org.apache.calcite.sql.*;
import org.apache.calcite.sql.fun.SqlStdOperatorTable;
import org.apache.calcite.sql.util.SqlBasicVisitor;

import java.util.HashSet;
import java.util.Objects;
import java.util.Set;

<span class="nc" id="L11">public class AggregateChecker {</span>
// Add other necessary imports from your project structure if needed

  /**
   * Determines if a SqlSelect statement represents an aggregation query.
   *
   * &lt;p&gt;An aggregation query is defined as one that either:&lt;/p&gt;
   * &lt;ul&gt;
   *     &lt;li&gt;Contains a {@code GROUP BY} clause.&lt;/li&gt;
   *     &lt;li&gt;Contains a {@code HAVING} clause.&lt;/li&gt;
   *     &lt;li&gt;Contains one or more aggregate functions (e.g., {@code SUM, COUNT, AVG})
   *         in the {@code SELECT} list, provided they are *not* exclusively used
   *         within an {@code OVER} clause (window functions).&lt;/li&gt;
   * &lt;/ul&gt;
   *
   * &lt;p&gt;This method performs the check by inspecting the structure of the
   * {@link SqlSelect} node directly, without relying on {@code SqlValidator}
   * annotations or state.&lt;/p&gt;
   *
   * &lt;p&gt;&lt;b&gt;Corner Cases Considered:&lt;/b&gt;&lt;/p&gt;
   * &lt;ul&gt;
   *     &lt;li&gt;Explicit {@code GROUP BY}.&lt;/li&gt;
   *     &lt;li&gt;Presence of {@code HAVING} (implies aggregation even if syntactically invalid
   *         in some contexts without {@code GROUP BY}).&lt;/li&gt;
   *     &lt;li&gt;Aggregate functions in the {@code SELECT} list (e.g., {@code COUNT(*)}, {@code SUM(col)}).&lt;/li&gt;
   *     &lt;li&gt;Global aggregation (aggregate functions in {@code SELECT} but no {@code GROUP BY}).&lt;/li&gt;
   *     &lt;li&gt;Aggregate functions used inside window functions (e.g., {@code SUM(col) OVER (...)}) -
   *         these do *not* make the query itself an aggregate query in the {@code GROUP BY} sense.&lt;/li&gt;
   *     &lt;li&gt;Aggregate functions nested inside other expressions (e.g., {@code MAX(a+b)},
   *         {@code CASE WHEN x THEN COUNT(y)...}).&lt;/li&gt;
   *     &lt;li&gt;Aliases in the {@code SELECT} list (e.g., {@code SELECT COUNT(*) AS total}).&lt;/li&gt;
   *     &lt;li&gt;Subqueries in the {@code SELECT} list (e.g., {@code SELECT (SELECT MAX(x) FROM t2) FROM t1}) -
   *         aggregates within such subqueries do *not* make the outer query aggregate.&lt;/li&gt;
   *     &lt;li&gt;Empty or null {@code GROUP BY}, {@code HAVING}, or {@code SELECT} list.&lt;/li&gt;
   * &lt;/ul&gt;
   *
   * @param select The non-null {@link SqlSelect} node to analyze.
   * @return {@code true} if the select statement involves aggregation according to the rules above,
   *         {@code false} otherwise.
   */
  public static boolean isAggregate(SqlSelect select) {
<span class="nc" id="L52">    Objects.requireNonNull(select, &quot;Input SqlSelect node cannot be null&quot;);</span>

    // 1. Check for explicit GROUP BY clause.
    // An empty GROUP BY list (GROUP BY ()) is possible in some dialects but still indicates aggregation.
<span class="nc bnc" id="L56" title="All 2 branches missed.">    if (select.getGroup() != null) {</span>
      // Note: select.getGroup().size() &gt; 0 might be technically more precise if GROUP BY ()
      // isn't considered aggregation, but generally, its presence implies aggregation intent.
      // Let's consider any non-null group list as aggregation.
<span class="nc" id="L60">      return true;</span>
    }

    // 2. Check for HAVING clause.
    // The presence of a HAVING clause fundamentally requires aggregation,
    // even if the SQL might be semantically invalid without a GROUP BY or aggregates in SELECT.
<span class="nc bnc" id="L66" title="All 2 branches missed.">    if (select.getHaving() != null) {</span>
<span class="nc" id="L67">      return true;</span>
    }

    // 3. Check for aggregate functions in the SELECT list (excluding those within OVER).
<span class="nc" id="L71">    SqlNodeList selectList = select.getSelectList();</span>
<span class="nc bnc" id="L72" title="All 2 branches missed.">    if (selectList != null) {</span>
      // Use a dedicated visitor to find aggregate functions, correctly handling OVER clauses
      // and avoiding descent into subqueries found within the select list.
<span class="nc" id="L75">      SelectListItemAggregateFinder finder = new SelectListItemAggregateFinder();</span>
<span class="nc bnc" id="L76" title="All 2 branches missed.">      for (SqlNode selectItem : selectList) {</span>
<span class="nc bnc" id="L77" title="All 2 branches missed.">        if (selectItem == null) {</span>
<span class="nc" id="L78">          continue; // Should not happen in a valid parse tree, but handle defensively.</span>
        }

        // Handle potential alias (AS operator). We need to inspect the expression being aliased.
<span class="nc" id="L82">        SqlNode expressionToCheck = selectItem;</span>
<span class="nc bnc" id="L83" title="All 4 branches missed.">        if (selectItem.getKind() == SqlKind.AS &amp;&amp; selectItem instanceof SqlCall) {</span>
<span class="nc" id="L84">          SqlCall asCall = (SqlCall) selectItem;</span>
          // Ensure operand list is not empty before accessing index 0
<span class="nc bnc" id="L86" title="All 2 branches missed.">          if (!asCall.getOperandList().isEmpty()) {</span>
<span class="nc" id="L87">            expressionToCheck = asCall.getOperandList().get(0);</span>
          } else {
            // Invalid AS structure, treat as non-aggregate for safety
<span class="nc" id="L90">            expressionToCheck = null;</span>
          }
        }

        // Apply the visitor to the core expression node.
<span class="nc bnc" id="L95" title="All 2 branches missed.">        if (expressionToCheck != null) {</span>
<span class="nc" id="L96">          expressionToCheck.accept(finder);</span>
<span class="nc bnc" id="L97" title="All 2 branches missed.">          if (finder.hasFoundAggregate()) {</span>
            // Early exit: Found a relevant aggregate function.
<span class="nc" id="L99">            return true;</span>
          }
          // Reset finder for the next select item if needed (though this finder stops on first hit)
          // finder.reset(); // Not strictly necessary with the current finder logic
        }
<span class="nc" id="L104">      }</span>
    }

    // 4. No GROUP BY, no HAVING, and no relevant aggregate functions found in SELECT list.
<span class="nc" id="L108">    return false;</span>
  }

  /**
   * A specialized visitor to detect the presence of aggregate functions within the
   * expression tree of a single SELECT list item.
   *
   * &lt;p&gt;Key behaviors:&lt;/p&gt;
   * &lt;ul&gt;
   *     &lt;li&gt;Identifies calls to operators that are instances of {@link SqlAggFunction}.&lt;/li&gt;
   *     &lt;li&gt;Explicitly stops traversal down the branch of an {@code OVER} clause, as aggregates
   *         within window functions do not count towards query-level aggregation.&lt;/li&gt;
   *     &lt;li&gt;Explicitly stops traversal down into subqueries ({@code SELECT, UNION, VALUES,} etc.)
   *         encountered as expressions, as their internal aggregates are irrelevant here.&lt;/li&gt;
   *     &lt;li&gt;Stops the entire visit process as soon as the first relevant aggregate function is found.&lt;/li&gt;
   * &lt;/ul&gt;
   */
<span class="nc" id="L125">  private static class SelectListItemAggregateFinder extends SqlBasicVisitor&lt;Void&gt; {</span>
<span class="nc" id="L126">    private boolean foundAggregate = false;</span>
    // Use a Set to handle potential cycles or redundant visits in complex expression trees,
    // although cycles are unlikely in valid SQL expressions.
<span class="nc" id="L129">    private final Set&lt;SqlNode&gt; visitedNodes = new HashSet&lt;&gt;();</span>

    /**
     * Checks if a relevant aggregate function was found during the visit.
     * @return {@code true} if an aggregate was found, {@code false} otherwise.
     */
    public boolean hasFoundAggregate() {
<span class="nc" id="L136">      return foundAggregate;</span>
    }

    // Optional: Reset state if the visitor instance were reused across multiple select items.
    // public void reset() {
    //     foundAggregate = false;
    //     visitedNodes.clear();
    // }

    @Override
    public Void visit(SqlCall call) {
      // --- Pre-visit checks for early exit or skipping ---

      // 1. Stop if already found.
<span class="nc bnc" id="L150" title="All 2 branches missed.">      if (foundAggregate) {</span>
<span class="nc" id="L151">        return null;</span>
      }

      // 2. Avoid redundant visits/cycles.
<span class="nc bnc" id="L155" title="All 2 branches missed.">      if (!visitedNodes.add(call)) {</span>
<span class="nc" id="L156">        return null;</span>
      }

<span class="nc" id="L159">      SqlOperator operator = call.getOperator();</span>

      // --- Core Logic: Identify aggregates or nodes to skip ---

      // 3. Found an aggregate function? Mark and stop.
<span class="nc bnc" id="L164" title="All 2 branches missed.">      if (operator instanceof SqlAggFunction) {</span>
        // Check it's not part of an OVER clause (handled by OVER check below,
        // but this direct check is correct).
<span class="nc" id="L167">        foundAggregate = true;</span>
<span class="nc" id="L168">        return null; // Stop visiting this branch and signal success.</span>
      }

      // 4. Is it an OVER clause? Stop traversal down this specific path.
      // We do *not* want to find aggregates within the OVER(...) part.
<span class="nc bnc" id="L173" title="All 2 branches missed.">      if (operator.equals(SqlStdOperatorTable.OVER)) {</span>
        // Do not visit operands of OVER. Stop here for this branch.
<span class="nc" id="L175">        return null;</span>
      }

      // 5. Is it a subquery used as an expression? Stop traversal down this path.
      // Aggregates inside subqueries don't make the *outer* query aggregate.
<span class="nc" id="L180">      SqlKind kind = call.getKind();</span>
<span class="nc bnc" id="L181" title="All 20 branches missed.">      if (kind == SqlKind.SELECT || kind == SqlKind.UNION || kind == SqlKind.INTERSECT ||</span>
          kind == SqlKind.EXCEPT || kind == SqlKind.VALUES || kind == SqlKind.WITH ||
          kind == SqlKind.ORDER_BY || kind == SqlKind.SCALAR_QUERY || kind == SqlKind.EXISTS ||
          kind == SqlKind.CURSOR) // CURSOR might wrap a query
      {
        // Do not visit operands of the subquery structure. Stop here for this branch.
<span class="nc" id="L187">        return null;</span>
      }

      // --- Default Behavior: Recurse into operands ---

      // 6. If none of the above, it's a regular function/operator. Visit operands
      //    to find potential nested aggregates.
<span class="nc bnc" id="L194" title="All 2 branches missed.">      for (SqlNode operand : call.getOperandList()) {</span>
<span class="nc bnc" id="L195" title="All 2 branches missed.">        if (operand != null) {</span>
<span class="nc" id="L196">          operand.accept(this);</span>
          // Check if found after visiting an operand for early exit.
<span class="nc bnc" id="L198" title="All 2 branches missed.">          if (foundAggregate) {</span>
<span class="nc" id="L199">            return null;</span>
          }
        }
<span class="nc" id="L202">      }</span>
<span class="nc" id="L203">      return null;</span>
    }

    @Override
    public Void visit(SqlNodeList nodeList) {
<span class="nc bnc" id="L208" title="All 4 branches missed.">      if (foundAggregate || !visitedNodes.add(nodeList)) {</span>
<span class="nc" id="L209">        return null;</span>
      }
<span class="nc bnc" id="L211" title="All 2 branches missed.">      for (SqlNode node : nodeList) {</span>
<span class="nc bnc" id="L212" title="All 2 branches missed.">        if (node != null) {</span>
<span class="nc" id="L213">          node.accept(this);</span>
<span class="nc bnc" id="L214" title="All 2 branches missed.">          if (foundAggregate) {</span>
<span class="nc" id="L215">            return null;</span>
          }
        }
<span class="nc" id="L218">      }</span>
<span class="nc" id="L219">      return null;</span>
    }

    // Overriding visit for other types (SqlLiteral, SqlIdentifier, etc.) is usually
    // not necessary as they cannot contain aggregate calls themselves. The default
    // SqlBasicVisitor behavior for these is typically a no-op or returns null,
    // which is acceptable here. Add overrides if specific handling is needed.
    // For example:
    // @Override public Void visit(SqlIdentifier id) { visitedNodes.add(id); return null; }
    // @Override public Void visit(SqlLiteral literal) { visitedNodes.add(literal); return null; }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>